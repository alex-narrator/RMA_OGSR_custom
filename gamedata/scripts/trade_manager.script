-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_npc_spawn",   	fun = this.update})
	sm:subscribe({signal = "on_npc_destroy",   	fun = this.clear})
	sm:subscribe({signal = "on_npc_use", 		fun = this.update})
	sm:subscribe({signal = "on_trader_spawn",   fun = this.update})
	sm:subscribe({signal = "on_trader_destroy", fun = this.clear})
	sm:subscribe({signal = "on_trader_use", 	fun = this.update})
end

local MIN_H, MAX_H = 8, 12--//межі рандомайзеру часу до оновлення асортиментів (ігрові години)
local c_time = game.CTime()
local trade_manager = {}

function trade_init(npc, cfg)
	----log3("TRADE INIT: [%s]", npc:name())
	
	local tt = trade_manager[npc:id()]
	if not tt or tt.cfg_ltx ~= cfg then
		tt = {}
		tt.cfg_ltx = cfg
		tt.config = ini_file_cached(cfg)
		trade_manager[npc:id()] = tt
	end
	
	-- коэфициенты покупки
	local str = read_if_exists(tt.config, "r_string", "trader", "buy_condition", nil)
	if not str then
		abort("Incorrect trader settings. Cannot find buy_condition. [%s]->[%s]", npc:name(), cfg)
	end
	--log3("TRADE INIT: [%s] tt.buy_condition = %s", npc:name(), str)
	tt.buy_condition = xr_logic.parse_condlist(npc, "trade_manager", "buy_condition", str)
	
	-- коэфициенты продажи
	str = read_if_exists(tt.config, "r_string", "trader", "sell_condition", nil)
	if str == nil then
		abort("Incorrect trader settings. Cannot find sell_condition. [%s]->[%s]", npc:name(), cfg)
	end
	--log3("TRADE INIT: [%s] tt.sell_condition = %s", npc:name(), str)
	tt.sell_condition = xr_logic.parse_condlist(npc, "trade_manager", "sell_condition", str)
	
	-- список закупки
	str = read_if_exists(tt.config, "r_string", "trader", "buy_supplies", nil)
	if str then
		tt.buy_supplies = xr_logic.parse_condlist(npc, "trade_manager", "buy_supplies", str)
		--log3("TRADE INIT: [%s] tt.buy_supplies = %s", npc:name(), str)
	else
		tt.buy_supplies = nil
	end
end

function update(npc)
	local tt = trade_manager[npc:id()]
	if not tt then 
		--log3("~TRADE UPDATE [%s]: skiped", npc:name())
	return end
	if not npc:alive() then
		clear(npc)
	return end
	
	--log3("~TRADE UPDATE [%s]: start", npc:name())
	
	local str = xr_logic.pick_section_from_condlist(actor, npc, tt.buy_condition)
	if tt.current_buy_condition ~= str then
		--log3("TRADE UPDATE [%s]: buy condition = %s", npc:name(), str)
		npc:buy_condition(tt.config, str)
		tt.current_buy_condition = str
	end

	str = xr_logic.pick_section_from_condlist(actor, npc, tt.sell_condition)
	if tt.current_sell_condition ~= str then
		--log3("TRADE UPDATE [%s]: sell condition = %s", npc:name(), str)
		npc:sell_condition(tt.config, str)
		tt.current_sell_condition = str
	end

	if not tt.buy_supplies then return end
	
	str = xr_logic.pick_section_from_condlist(actor, npc, tt.buy_supplies)
	if tt.current_buy_supplies ~= str or not tt.resuply_time or tt.resuply_time:diffSec(game.get_game_time()) <= 0 then
		--log3("TRADE UPDATE [%s]: buy_supplies = %s", npc:name(), tostring(str))
		npc:buy_supplies(tt.config, str)
		tt.current_buy_supplies = str
		local resuply_hours = math.random(MIN_H, MAX_H)
		c_time:setHMS(resuply_hours, 0, 0)
		tt.resuply_time = game.get_game_time() + c_time
		--log3("TRADE UPDATE [%s]: next resuply in %s hours", npc:name(), resuply_hours)
	end
end


function save(obj, packet)
	local tt = trade_manager[obj:id()]

	--' Сохраняем присутствует ли инициализированная торговля в принципе.
	if tt then
		packet:w_bool(true)
	else
		----log3("TRADE SAVE [%s]: ignored", obj:name())
		packet:w_bool(false)
		return
	end

	packet:w_stringZ(tt.cfg_ltx)

	if tt.current_buy_condition then
		packet:w_stringZ(tt.current_buy_condition)
		--log3("TRADE SAVE [%s]: current_buy_condition = %s", obj:name(), tostring(tt.current_buy_condition))
	else
		packet:w_stringZ("")
	end

	if tt.current_sell_condition then
		packet:w_stringZ(tt.current_sell_condition)
		--log3("TRADE SAVE [%s]: current_sell_condition = %s", obj:name(), tostring(tt.current_sell_condition))
	else
		packet:w_stringZ("")
	end

	if tt.current_buy_supplies then
		packet:w_stringZ(tt.current_buy_supplies)
		--log3("TRADE SAVE [%s]: current_buy_supplies = %s", obj:name(), tostring(tt.current_buy_supplies))
	else
		packet:w_stringZ("")
	end

	packet:w_s32(-1)--//update_time was here

	if tt.resuply_time then
		local diff = tt.resuply_time:diffSec(game.get_game_time())
		if diff < 0 then
			diff = 0
		end
		packet:w_s32(diff)
		--log3("TRADE SAVE [%s]: resuply_time diff = %s | %s hours", obj:name(), diff, diff/3600)
	else
	 	packet:w_s32(-1)
	end
end

function load(obj, packet)
	if not packet:r_bool() then
		--log3("TRADE LOAD [%s]: ignored", obj:name())
		return
	end

	local tt = {}
	trade_manager[obj:id()] = tt

	tt.cfg_ltx = packet:r_stringZ()
	--log3("TRADE LOAD [%s]: cfg_ltx = %s", obj:name(), tt.cfg_ltx)

	tt.config = ini_file_cached(tt.cfg_ltx)

	local a = packet:r_stringZ()
	if a ~= "" then
		tt.current_buy_condition = a
		obj:buy_condition(tt.config, a)
		--log3("TRADE LOAD [%s]: current_buy_condition = %s", obj:name(), tostring(a))
	end
	
	a = packet:r_stringZ()
	if a ~= "" then
		tt.current_sell_condition = a
		obj:sell_condition(tt.config, a)
		--log3("TRADE LOAD [%s]: current_sell_condition = %s", obj:name(), tostring(a))
	end

	a = packet:r_stringZ()
	if a ~= "" then
		tt.current_buy_supplies = a
		--log3("TRADE LOAD [%s]: current_buy_supplies = %s", obj:name(), tostring(a))
	end

	packet:r_s32()--//update_time was here

	a = packet:r_s32()
	if a > 0 then
		c_time:setHMS(0, 0, a)
		tt.resuply_time = game.get_game_time() + c_time
		--log3("TRADE LOAD [%s]: resuply_time diff = %s | %s hours", obj:name(), a, a/3600)
	end
end

function clear(npc)
	trade_manager[npc:id()] = nil
end