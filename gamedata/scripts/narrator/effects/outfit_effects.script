-- -*- mode: lua; coding: windows-1251-dos -*-
local main_wnd = get_main_window()
local mask_texture = [[ui\dinamic_hud\hud_]]
local breathe_texture = [[ui\dinamic_hud\breathe]]
local brake_sound = xr_sound.get_safe_sound_object([[material\glass\glass_fall01hl]],sound_object.s2d)

local hud_obj, hud_params, mask_static, breathe_static, last_cond_idx, last_power_idx, last_power_idx, breathe_val

local dec_breathe, show_minimap = false, false

function get_hud_params(sect)
	hud_data = {}
	
	hud_data.shader = read_if_exists(sys_ini, "r_bool", sect, "hud_shader", false)
	
	hud_data.texture = read_if_exists(sys_ini, "r_string", sect, "hud_texture", nil)
	
	if hud_data.texture then
		hud_data.texture = mask_texture..hud_data.texture
		hud_data.breakable = read_if_exists(sys_ini, "r_bool", sect, "hud_breakable", false)
	end
	
	hud_data.breathe = read_if_exists(sys_ini, "r_float", sect, "hud_breathe", 0)
	
	return hud_data
end

function has_hud(sect)
	local params = get_hud_params(sect)
	return params.shader or params.texture or params.breathe > 0
end

function get_cond_idx()
	local cond = hud_obj:condition()
	--log3("hud_obj %s | cond %s", hud_obj:name(), cond)
	if cond <= 0.1 then
		return 6
	elseif cond <= 0.3 then
		return 5
	elseif cond <= 0.5 then
		return 4
	elseif cond <= 0.7 then
		return 3
	elseif cond <= 0.9 then
		return 2
	else 
		return 1
	end
end

function get_power_idx()
	local power = actor.power
	if power <= 0.2 then
		return 5
	elseif power <= 0.4 then
		return 4
	elseif power <= 0.6 then
		return 3
	elseif power <= 0.8 then
		return 2
	else 
		return 1
	end
end

function attach(sm)
	sm:subscribe({signal = "on_drop",   fun = this.on_non_slot})
	sm:subscribe({signal = "on_ruck",   fun = this.on_non_slot})
	sm:subscribe({signal = "on_belt",   fun = this.on_non_slot})
	sm:subscribe({signal = "on_slot",   fun = this.on_slot})
	sm:subscribe({signal = "on_save",   fun = this.on_save})
	sm:subscribe({signal = "on_load",   fun = this.on_load})	
end

local known_outfits = {}

function on_save(packet)
	xr_vars.save_var("known_outfits", known_outfits)
end

function on_load(reader)
	known_outfits = xr_vars.load_var("known_outfits", known_outfits)
end

function allowed_item(obj)
	return obj:is_outfit() or obj:is_helmet()
end

local equip_outfit_snd = [[interface\item_usage\mask_clean]]
local equip_outfit_effector = "outfit_on_off"
local equip_outfit_effector_id = 5556
local gasmask_effector_id = 5557

function on_slot(obj, prev_place)
	if not allowed_item(obj) then
	return end

	--//костиль для впадків коли предмет що вдягнули блокує слоти в яких вже є предмети
	--//ці предмети можуть також мати худ-маски
	--//в такому випадку спочатку вдягається цільовий предмет, а потім - знімається предмет із заблокованого слоту
	--//тож треба зачекати поки зніметься предмет та скинеться худ що був
	add_update_delayed_action(1,
		function()
			if obj:is_outfit() or not get_hud_sect(obj) or xr_conditions.black_screen() then
				enable_effects(obj)
			else
				play_gasmask_anim(obj, true)
			end
		end
	)
	
	if obj:is_outfit() and not xr_conditions.black_screen() and not has_alife_info("bar_arena_fight") then
		if known_outfits[obj:section()] then
			outfit_anim.play("outfit_equip_fast_hud")
		else
			outfit_anim.play("outfit_equip_hud")
			known_outfits[obj:section()] = true
		end
	end
end

function on_non_slot(obj, prev_place)
	if prev_place ~= item_place.slot then
	return end
	
	if not allowed_item(obj) then
	return end
	
	disable_effects(obj)
	
	if get_hud_sect(obj) and not xr_conditions.black_screen() and not level.is_removing_objects() then
		play_gasmask_anim(obj, false)
	end	
		
	if obj:is_outfit() and actor:alive() and level.main_input_receiver() then
		add_update_delayed_action(1, function() backpack.play_anim(3) end)
	end
end

function play_gasmask_anim(item, is_on)
	local hud_sect = get_hud_sect(item)
	
	local already_blocked = actor.inventory:is_active_slot_blocked()
	
	if not already_blocked then
		actor:hide_weapon(true)
	end
	
	level.add_call(
		function() 
			return not actor:active_item() and not actor:active_device()
		end,
		function()
			actor:hide_crosshair(true)
			
			game.play_hud_motion(2, hud_sect, is_on and "anm_equip" or "anm_takeoff", false, 1, true)

			local snd_name = read_if_exists(sys_ini, "r_string", hud_sect, is_on and "sound_on" or "sound_off", nil)
			if snd_name then
				xr_sound.get_safe_sound_object(snd_name,sound_object.s2d):play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)
			end

			local eff_name = read_if_exists(sys_ini, "r_string", hud_sect, is_on and "hud_effector_on" or "hud_effector_off", nil)
			if eff_name and actor:alive() then
				level.remove_complex_effector(gasmask_effector_id)
				level.add_complex_effector(eff_name, gasmask_effector_id)
			end
			
			block_non_move_action(true)
			level.add_call(
				function()
					return game.hud_motion_allowed()
				end,
				function()
					block_non_move_action(false)
					if not already_blocked then
						actor:restore_weapon()
					end
					if has_alife_info("ui_inventory") or has_alife_info("ui_car_body") then
						backpack.play_anim(3)
					end
					actor:hide_crosshair(false)
					if is_on then 
						enable_effects(item)
					end
				end
			)
		end
	)	
end

function enable_effects(obj)
	local sm = ogse_signals.get_mgr()
	local sect = obj:section()
	
	local icon = read_if_exists(sys_ini, "r_string", sect, "actor_icon", nil)
	if obj:is_outfit() and icon then
		actor:set_character_icon(icon)
		sm:call("on_actor_icon_update", icon)
	end
	
	show_minimap = read_if_exists(sys_ini, "r_bool", sect, "show_minimap", false)
	if show_minimap then
		sm:subscribe({signal = "on_update", fun = this.on_update_minimap})
	end
	
	if has_hud(sect) then
		hud_params = get_hud_params(sect)
		hud_obj = obj
		try_switch_shader_effects(true) 
		try_set_hud_mask(true)
	end
end

function disable_effects(obj, prev_place)
	local sm = ogse_signals.get_mgr()
	
	local default_icon = actor:get_default_character_icon()
	if obj:is_outfit() and default_icon ~= actor:get_character_icon() then
		actor:set_character_icon(default_icon)
		sm:call("on_actor_icon_update", default_icon)
	end
	
	if show_minimap and get_main_window().show_zone_map then
		get_main_window().show_zone_map = false
		sm:unsubscribe({signal = "on_update", fun = this.on_update_minimap})
	end
	
	if has_hud(obj:section()) then
		hud_params = get_hud_params(obj:section())
		try_switch_shader_effects(false)
		try_set_hud_mask(false)
	end
	
	hud_obj = nil
	hud_params = {}
end

function try_switch_shader_effects(val)
	if not hud_params.shader then 
	return end
	
	val = val and 1 or 0
	local console = get_console()
	console:execute("r2_rain_drops_control "..val)
	console:execute("r2_visor_refl_control "..val)
end

function try_set_hud_mask(val)
	local sm = ogse_signals.get_mgr()
	
	if hud_params.breathe > 0 then
		breathe_val = 0
		dec_breathe = false
		if val then
			sm:subscribe({signal = "update_items_effect", fun = this.on_update_mask})
			breathe_static = create_breathe_static()
			main_wnd:AttachChild(breathe_static)
			main_wnd:BringToBottom(breathe_static)
		else
			sm:unsubscribe({signal = "update_items_effect", fun = this.on_update_mask})
			main_wnd:DetachChild(breathe_static)
			breathe_static = nil
		end
	end
	
	if hud_params.texture then
		if val then
			sm:subscribe({signal = "on_hit_actor", fun = this.on_hit})
			mask_static = create_mask_static()
			main_wnd:AttachChild(mask_static)
			main_wnd:BringToBottom(mask_static)
		else
			sm:unsubscribe({signal = "on_hit_actor", fun = this.on_hit})
			main_wnd:DetachChild(mask_static)
			mask_static = nil
		end
	end
end

function create_mask_static()
	local texture_name = hud_params.texture
	if hud_params.breakable then
		last_cond_idx = get_cond_idx()
		texture_name = texture_name..last_cond_idx
	end
	local static = CUIStatic()
	static:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	static:InitTexture(texture_name)
	static:SetStretchTexture(true)
	return static
end

function create_breathe_static()
	last_power_idx = get_power_idx()
	local static = CUIStatic()
	static:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	static:InitTexture(breathe_texture..last_power_idx)
	static:SetStretchTexture(true)
	return static
end

function update_mask_texture()
	local cond_idx = get_cond_idx()
	if hud_params.breakable and last_cond_idx ~= cond_idx then
		mask_static:InitTexture(hud_params.texture..cond_idx)
		last_cond_idx = cond_idx
		
		if last_cond_idx == 2 then
			brake_sound:play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)--play_at_pos(actor, actor:position())
		end
	end
end

function on_hit(victim, health_lost, direction, draftsman, bone_id, hit_type)
	-- if bone_id ~= actor:get_bone_id("bip01_head") then
	-- return end
	
	if not hud_obj then
	return end
	
	local check_item = actor:item_in_slot(6)
	local check_id = hud_obj:id()
	if check_item and check_item:id() == check_id then
		update_mask_texture()
		--log3("check_item %s", check_item:name())
		return
	end
	
	check_item = actor:item_in_slot(11)
	if check_item and check_item:id() == check_id then
		update_mask_texture()
		--log3("check_item %s", check_item:name())
		return
	end
end

function on_update_mask(delta)
	--log3("%s | %s", script_name(), delta)
	local change = delta * hud_params.breathe
	change = change + (change * (1 - actor.power))
	
	if dec_breathe then
		change = -change
	end	
	
	breathe_val = breathe_val + change
	
	if breathe_val <= 0 then
		breathe_val = 0
		dec_breathe = false
	elseif breathe_val >= 1 then
		breathe_val = 1
		dec_breathe = true
	end
	
	breathe_static:SetColor(GetARGB(breathe_val*255,255,255,255))
	
	local power_idx = get_power_idx()
	if last_power_idx ~= power_idx and breathe_val == 0 then
		breathe_static:InitTexture(breathe_texture..power_idx)
		last_power_idx = power_idx
		--log3("last_power_idx %s", last_power_idx)
	end
	--log3("breathe_val %s", breathe_val)
end

function on_update_minimap()
	if show_minimap then
		get_main_window().show_zone_map = actor_get_pda() and actor_get_pda():is_power_on()
	end
end