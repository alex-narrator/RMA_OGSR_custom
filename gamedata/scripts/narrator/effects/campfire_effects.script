-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_campfire_use", fun = this.on_campfire_use})
end

local CAMPFIRE_EFFECT_DIST = actor.inventory.take_dist
local PSY_RESTORE_K = 0.5
local actor_obj = get_actor_obj()

local LIGHT_UP_PROB = 3
local OUTDOOR_K = 1
local RAIN_K = 1

local actor_use_campfire = false
local subscribed = false

function get_matches()
	return actor:object("matches")
end

function on_campfire_use(campfire_usable, campfire_zone)
	if not alife():object(campfire_zone:id()).enabled then
		
		local matches = get_matches()
		
		if not matches then
		return end
		
		local cond_dec = 1 / read_if_exists(sys_ini, "r_u32", matches:section(), "use_count", 10)
		matches:change_condition(-cond_dec)
		
		if matches:condition() <= 0 then
			actor:drop_item(matches)
			alife():release(alife():object(matches:id()), true)
		end
		
		actor:hide_weapon(true)
		level.disable_input()
		local sound = xr_sound.get_safe_sound_object(read_if_exists(sys_ini, "r_string", matches:section(), "use_sound", nil))
		if sound then
			sound:play(actor, 0, sound_object.s2d)
		end
			
		level.add_call(
			function()
				return not sound or not sound:playing()
			end,
			function()
				actor:restore_weapon(true)
				level.enable_input()
				local prob = LIGHT_UP_PROB
				--if not actor:is_ActorHide() then
				if not is_pos_under_roof(campfire_zone:position()) then
					prob = prob + level.rain_factor()
					log3("~rain factor %s", level.rain_factor())
				end
				log3("~light up prob %s", prob)
				if math.random(0, 10) > prob then
					campfire_zone:enable_anomaly()
					alife():object(campfire_zone:id()).enabled = true
				end
			end
		)
	return end
	
	if actor_use_campfire and actor_use_campfire:id() == campfire_zone:id() then
		unsubscribe()
	return end
	
	actor_use_campfire = campfire_zone
	--actor:hide_weapon()
	backpack.force_crouch(true)
	subscribe()	
end

function actor_used_campfire()
	return actor_use_campfire
end

function subscribe()
	if subscribed then
	return end
	subscribed = {
		{ signal = "update_items_effect", fun = this.update_items_effect },
	}
	local sm = ogse_signals.get_mgr()
	for _, s in ipairs( subscribed ) do
		sm:subscribe( s )
	end
end

function unsubscribe()
	if not subscribed then
	return end
	local sm = ogse_signals.get_mgr()
	for _, s in ipairs( subscribed ) do
		sm:unsubscribe( s )
	end
	subscribed = false
	actor_use_campfire = false
	backpack.force_crouch(false)
	--actor:restore_weapon()
end

function update_items_effect(delta)
	local used_now = actor_use_campfire 
		and distance_between_safe(actor, actor_use_campfire) <= CAMPFIRE_EFFECT_DIST 
		and (actor_obj:is_actor_crouch() or actor_obj:is_actor_crouching() or actor_obj:is_actor_creep() or actor_obj:is_actor_creeping())
		--and is_actor_looking_to_pos(actor_use_campfire:position(), actor_use_campfire:radius())
	if not used_now then
		unsubscribe()
	return end
	--aim_camera_to_target(actor_use_campfire)
	local pos = actor_use_campfire:center()
	pos.y = pos.y + 0.5
	aim_camera_to_pos(pos)
	local conds = actor_obj.condition
	local psy_add = conds.psy_health_v * PSY_RESTORE_K * delta
	actor.psy_health = psy_add
	--log3("~psy_add %s", psy_add)
end