function attach(sm)
	sm:subscribe({signal = "on_key_press",   		fun = this.on_key_press})
end

local torch_action = {
	[key_bindings.kTORCH] = true,
	[key_bindings.kNIGHT_VISION] = true,
}

local actor_obj = get_actor_obj()
local is_playing = false

function on_key_press(key, game_action)
	if not torch_action[game_action] or
		not actor_hands_free() or
		is_playing or
		not actor_get_torch()
	then
	return end
	
	actor_obj:block_action(key_bindings.kTORCH)
	actor_obj:block_action(key_bindings.kNIGHT_VISION)
	
	if game_action == key_bindings.kTORCH and 
		not read_if_exists(sys_ini, "r_string", actor_get_torch():section(), "light_definition", nil) 
	then return end
	
	if game_action == key_bindings.kNIGHT_VISION and 
		not read_if_exists(sys_ini, "r_string", actor_get_torch():section(), "night_vision_effector", nil) 
	then return end
	
	local hud_sect = get_hud_sect(actor_get_torch())
	
	game.play_hud_motion(1, hud_sect, "anm_switch", false, 1, false)
	is_playing = true
	
	add_time_delayed_action(
		read_if_exists(sys_ini, "r_float", hud_sect, "use_delay", 1.5),
		function()
			if game_action == key_bindings.kTORCH then
				actor_get_torch():switch_torch(not actor_get_torch():is_power_on())
			else
				actor_get_torch():switch_night_vision(not actor_get_torch():is_power_on())
			end
		end
	)
	
	level.add_call(
		function()
			return game.hud_motion_allowed()
		end,
		function()
			is_playing = false
		end
	)
end