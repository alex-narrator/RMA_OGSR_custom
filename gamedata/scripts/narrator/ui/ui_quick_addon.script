-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\ui_quick_addon_overlay.xml"

local subscribed = false
local sm = ogse_signals.get_mgr()

local color_focused = GetARGB(255, 255, 255, 0)
local color_none = GetARGB(255, 255, 255, 255)

local addon_params = {
	[0] = { name = "silencer_name", 		offset = "left_center_out", },
	[1] = { name = "scope_name", 			offset = "center_top_out", },
	[2] = { name = "grenade_launcher_name", offset = "right_center_out", },
	[3] = { name = "laser_name", 			offset = "left_top_out", },
	[4] = { name = "flashlight_name", 		offset = "right_top_out", },
	[5] = { name = "stock_name", 			offset = "right_down_out", },
}

class "QuickAddonOverlay" (CUIScriptWnd)

function QuickAddonOverlay:__init() super()
	self:InitControls()
end

function QuickAddonOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_drop", self = self, fun = self.UpdateCompatible},
		}
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function QuickAddonOverlay:Unsubscribe()
	if self.subscribed then
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function QuickAddonOverlay:InitControls()
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	
	self:DetachAll()
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	local name
	--//background
	self.back = xml:InitStatic("background", self)
	xml:InitAutoStaticGroup("background:auto_static", self.back)
	
	self.menu_time_factor = xml:ReadAttribFlt("background", "menu_time_factor", 1)
	self.items_indent = xml:ReadAttribFlt("background", "items_indent", 0)
	self.back_texture = xml:ReadAttrib("background", "back_texture", "ui_inv_back_gray")
	
	local name = "central"
	self.central = xml:InitStatic(name, self)
	self.central.color = self.central:GetColor()
	self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnCentralFocusReceived() end)
	self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnCentralFocusLost() end)
	self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:ShowHide() end)
	
	name = "close"
	self.close = xml:InitStatic("central:"..name, self.central)
	local offset = ui_inv_utils.GetOffset("center", self.close, self.central)
	self.close:SetWndPos(offset.x, offset.y)
	
	self.tip = xml:InitStatic("tip", self)
	self.tip:Show(false)
	
	self.addons = {}
	for k,v in pairs(addon_params) do
		self.addons[k] = {}
	end	
end

function QuickAddonOverlay:Update()
	CUIScriptWnd.Update(self)
	if not self:CanShow() then
		self.target_item_id = nil
		self:ShowHide()
	end
end

function QuickAddonOverlay:ClearLists()
	self.back:DetachAll()
	for k,v in pairs (self.addons) do
		v.items = {}
	end
end

function QuickAddonOverlay:UpdateCompatible()
	self.target_item_id = false
	
	local central_pos = self.central:GetWndPos()
	local cursor_pos = vector2():set(central_pos.x + self.central:GetWidth() * 0.5, central_pos.y + self.central:GetHeight() * 0.5)
	level.set_cursor_pos(cursor_pos)

	self:SetTip()
	
	self:ClearLists()
	
	local check_item = actor:active_item()
	if check_item then
		for k,v in pairs(self.addons) do
			self:CheckAddons(check_item, k)
		end
	end
end

function QuickAddonOverlay:CheckAddons(check_item, addon_type)
	local weapon = check_item:get_weapon()
	if not weapon then
	return end
	
	local base_size = vector2():set(self.central:GetWidth(), self.central:GetHeight())
	local pos = self.central:GetWndPos()
	
	local prev_static
	
	if weapon:is_addon_attached(addon_type) and weapon:addon_attachable(addon_type) and read_if_exists(sys_ini, "bool", weapon:get_addon_name(addon_type), "quick_attach", true) then
		self.target_item_id = check_item:id()
		local addon_sect = weapon:get_addon_name(addon_type)
		local name = "addon_"..addon_sect
		
		local item_back = CUIStatic()
		item_back:Init(0, 0, base_size.x, base_size.y)
		item_back:InitTexture(self.back_texture)
		item_back:SetStretchTexture(true)
		
		local table_end = self.addons[addon_type].items[#self.addons[addon_type].items]
		
		prev_static = table_end and table_end.back or self.central
		
		local offset = ui_inv_utils.GetOffset(addon_params[addon_type].offset, item_back, prev_static, self.items_indent)
		pos.x = pos.x + offset.x
		pos.y = pos.y + offset.y
		
		item_back:SetWndPos(pos.x, pos.y)

		local params = CIconParams(addon_sect)
		local icon_size = vector2():set(params.grid_width * base_size.x, params.grid_height * base_size.y)

		local item_icon = CUIStatic()
		item_icon:Init(0, 0, icon_size.x, icon_size.y)
		
		ui_inv_utils.CellItemFitToSize(params, item_icon, item_back)
		
		SetCellIcon(item_icon, params)
		ui_inv_utils.UpdateDetachAddonIcon(item_back)
		
		table.insert(self.addons[addon_type].items, {back = item_back})
		
		self.back:AttachChild(item_back)
		item_back:AttachChild(item_icon)
		
		self:Register(item_back, name)
		
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnDetachFocusReceived(addon_sect, item_back) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnDetachFocusLost(addon_sect, item_back) end)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnDetachClick(addon_sect) end)		
	end
	
	local items = {}
	local addons = read_if_exists(sys_ini, "string", check_item:section(), addon_params[addon_type].name, nil)
	local addons_list = split_string(addons, ",")
	if addons_list and weapon:addon_attachable(addon_type) then
		for k,addon_sect in pairs(addons_list) do
			local item = actor:object(addon_sect)
			if item and read_if_exists(sys_ini, "bool", addon_sect, "quick_attach", true) then
				ui_inv_utils.try_add_to_list(item, items, true)
			end
		end		
	end
	
	for k,v in pairs(items) do
		local item = v.item
		local id = item:id()
		
		local can_set = item:section() ~= weapon:get_addon_name(addon_type) or not weapon:is_addon_attached(addon_type)
		
		if can_set then
			self.target_item_id = check_item:id()
			
			local name = "addon_"..id
			
			local item_back = CUIStatic()
			item_back:Init(0, 0, base_size.x, base_size.y)
			item_back:InitTexture(self.back_texture)
			item_back:SetStretchTexture(true)
			
			local table_end = self.addons[addon_type].items[#self.addons[addon_type].items]
			
			prev_static = table_end and table_end.back or self.central
			
			local offset = ui_inv_utils.GetOffset(addon_params[addon_type].offset, item_back, prev_static, self.items_indent)
			pos.x = pos.x + offset.x
			pos.y = pos.y + offset.y
			item_back:SetWndPos(pos.x, pos.y)			
			
			local params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * base_size.x, params.grid_height * base_size.y)

			local item_icon = CUIStatic()
			item_icon:Init(0, 0, icon_size.x, icon_size.y)
			
			ui_inv_utils.CellItemFitToSize(params, item_icon, item_back)
		
			SetCellIcon(item_icon, params)
			ui_inv_utils.UpdateAttachAddonIcon(item_back)				

			table.insert(self.addons[addon_type].items, {back = item_back})
			
			self.back:AttachChild(item_back)
			item_back:AttachChild(item_icon)
			
			self:Register(item_back, name)
			
			self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnAttachFocusReceived(id, item_back) end)
			self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnAttachFocusLost(id, item_back) end)
			self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnAttachClick(id) end)
		end			
	end
end

function QuickAddonOverlay:HighlightStatic(static, color)
	static:SetColor(color)
end

function QuickAddonOverlay:OnCentralFocusReceived()
	self:HighlightStatic(self.close, color_focused)
end

function QuickAddonOverlay:OnCentralFocusLost()
	self:HighlightStatic(self.close, self.central.color)
end

function QuickAddonOverlay:SetTip(text)
	if not text then
		self.tip:Show(false)
	return end
	self.tip:SetText(text)
	self.tip:AdjustHeightToText()
	self.tip:AdjustWidthToText()
	local pos = self.central:GetWndPos()
	local offset = ui_inv_utils.GetOffset("center_down_out", self.tip, self.central, self.items_indent)
	self.tip:SetWndPos(pos.x + offset.x - (self.tip:GetWidth() * 0.5 - self.central:GetWidth() * 0.5), pos.y + offset.y)
	self:BringToTop(self.tip)
	self.tip:Show(true)
end

function QuickAddonOverlay:OnDetachFocusReceived(sect, static)
	self:HighlightStatic(static, color_focused)
	local text = string.format("%s\\n%s", game.translate_string("ui_st_detach"), get_inv_name_short(sect))
	self:SetTip(text)
end

function QuickAddonOverlay:OnDetachFocusLost(sect, static)
	self:HighlightStatic(static, color_none)
	self:SetTip()
end

function QuickAddonOverlay:OnDetachClick(sect)
	local slot_item = level.object_by_id(self.target_item_id)
	local slot_wpn = slot_item:get_weapon_m()
	
	actor:hide_weapon()
	level.add_call(
		function()
			return not actor:active_item()
		end,
		function()	
			block_non_move_action(true)
			local snd_name = read_if_exists(sys_ini, "string", sect, "detach_addon_sound", "interface\\inv_detach_addon")
			local snd = xr_sound.get_safe_sound_object(snd_name)
			snd:play(actor, 0, sound_object.s2d)
			sm:call("on_detach_addon_start", slot_item, snd:length())
			level.add_call(
				function()
					return not snd or not snd:playing() or need_force_stop_anim()
				end,
				function()
					if need_force_stop_anim() then
						if snd and snd:playing() then
							snd:stop()
						end
					else
						detach_addon(slot_item, sect)
					end
					block_non_move_action(false)
					actor:restore_weapon()
					sm:call("on_detach_addon_stop")
				end
			)
		end
	)		

	self:ShowHide()
end

function QuickAddonOverlay:OnAttachFocusReceived(id, static)
	local item = level.object_by_id(id)
	self:HighlightStatic(static, color_focused)
	sm:call("on_cell_item_focus", item)
	
	local text = string.format("%s\\n%s", game.translate_string("ui_st_attach"), get_inv_name_short(item:section()))
	self:SetTip(text)
end

function QuickAddonOverlay:OnAttachFocusLost(id, static)
	local item = level.object_by_id(id)
	self:HighlightStatic(static, color_none)
	sm:call("on_cell_item_focus_lost", item)
	
	self:SetTip()
end

function QuickAddonOverlay:OnAttachClick(id)
	local desired_item = level.object_by_id(id)
	if not desired_item then
	return end
	local slot_item = level.object_by_id(self.target_item_id)
	if not slot_item then
	return end
	
	local desired_iitem = desired_item:get_inventory_item()
	local slot_iitem = slot_item:get_inventory_item()
	
	local detach_addon_type = nil
	
	if not slot_iitem:can_attach_addon(desired_iitem) then
		for k, addon in pairs(ADDON_TYPES) do
			local addons = read_if_exists(sys_ini, "string", slot_item:section(), addon.."_name", nil)
			local addons_list = split_string(addons, ",")
			if addons_list then
				for _, addon_sect in pairs(addons_list) do
					if addon_sect == desired_item:section() then
						detach_addon_type = k-1
						break
					end
				end		
			end
		end		
	end
	
	actor:hide_weapon()
	level.add_call(
		function()
			return not actor:active_item()
		end,
		function()
			if detach_addon_type then
				-- detach_addon(slot_item, slot_item:get_weapon():get_addon_name(detach_addon_type))
				local sect = slot_item:get_weapon():get_addon_name(detach_addon_type)
				--//detach
				block_non_move_action(true)
				local snd_name = read_if_exists(sys_ini, "string", sect, "detach_addon_sound", "interface\\inv_detach_addon")
				local snd = xr_sound.get_safe_sound_object(snd_name)
				snd:play(actor, 0, sound_object.s2d)
				sm:call("on_detach_addon_start", slot_item, snd:length())
				level.add_call(
					function()
						return not snd or not snd:playing() or need_force_stop_anim()
					end,
					function()
						if need_force_stop_anim() then
							if snd and snd:playing() then
								snd:stop()
							end
							block_non_move_action(false)
							actor:restore_weapon()
							sm:call("on_detach_addon_stop")
						else
							detach_addon(slot_item, sect)
							-- block_non_move_action(true)
							local snd_name = read_if_exists(sys_ini, "string", desired_item:section(), "attach_addon_sound", "interface\\inv_attach_addon")
							local snd = xr_sound.get_safe_sound_object(snd_name)
							snd:play(actor, 0, sound_object.s2d)
							sm:call("on_attach_addon_start", slot_item, snd:length())
							level.add_call(
								function()
									return not snd or not snd:playing() or need_force_stop_anim()
								end,
								function()
									if need_force_stop_anim() then
										if snd and snd:playing() then
											snd:stop()
										end
									else
										attach_addon(slot_item, desired_item)
									end
									block_non_move_action(false)
									actor:restore_weapon()
									sm:call("on_attach_addon_stop")
								end
							)
						end
					end
				)
			else			
				block_non_move_action(true)
				local snd_name = read_if_exists(sys_ini, "string", desired_item:section(), "attach_addon_sound", "interface\\inv_attach_addon")
				local snd = xr_sound.get_safe_sound_object(snd_name)
				snd:play(actor, 0, sound_object.s2d)
				sm:call("on_attach_addon_start", slot_item, snd:length())
				level.add_call(
					function()
						return not snd or not snd:playing() or need_force_stop_anim()
					end,
					function()
						if need_force_stop_anim() then
							if snd and snd:playing() then
								snd:stop()
							end
						else
							attach_addon(slot_item, desired_item)
						end
						block_non_move_action(false)
						actor:restore_weapon()
						sm:call("on_attach_addon_stop")
					end
				)
			end
		end
	)	
	
	self:ShowHide()
end

function QuickAddonOverlay:CanShow()
	if not actor_hands_free() then
		return false
	end
	if self.target_item_id then
		return true
	end
	return false
end

function QuickAddonOverlay:ShowHide()
	if not level.main_input_receiver() or self:IsShown() then
		level.start_stop_menu(self, false)
		if self:IsShown() then
			self:OnShow()
		else
			self:OnHide()
		end
	end
end

function QuickAddonOverlay:ProcessSlowMotion(enable)
	local console = get_console()
	local timefactor = enable and self.menu_time_factor or 1
	console:execute("time_factor "..timefactor)
end

function QuickAddonOverlay:OnShow()
	self:InitControls()
	self:UpdateCompatible()
	if not self:CanShow() then
	return end
	self:Subscribe()
	local act_item = actor:active_item()
	if act_item then		
		act_item:zoom_out()
	end	
	self:ProcessSlowMotion(true)
	sm:call("on_quick_addon_show")
end

function QuickAddonOverlay:OnHide()
	sm:call("on_quick_addon_hide")
	self:Unsubscribe()
	self:ClearCallbacks()
	self:ProcessSlowMotion(false)
end

function QuickAddonOverlay:StopAnyMove()
	CUIScriptWnd.StopAnyMove(self)
	return false
end

local restricted_actions = {
	[key_bindings.kWPN_FIRE] = true,
	[key_bindings.kWPN_ZOOM] = true,
}

function QuickAddonOverlay:OnKeyboard(dik, keyboard_action)
	CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
	
	local game_action = dik_to_bind(dik)
	
	if game_action == key_bindings.kQUIT then
		self:OnHide()
	end		
	
	if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		if restricted_actions[game_action] then
			return true
		end
	end

	return false
end