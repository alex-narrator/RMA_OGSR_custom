-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\mainingame_overlay.xml"
local overlay = nil
local subscribed = false
local DYNAMIC_SHOW = true
local DEBUG_WARNING_SHOW = false
local USE_LUMINOCITY = false --read_if_exists(sys_ini, "r_bool", "features", "use_luminicity")
local actor_obj = get_actor_obj()

local MOTION_TEXTURE_PREFIX = "ui_hud_soldier_"
local MOTION_TEXTURE_POSTFIX = "_warning"

function visibility()
	return USE_LUMINOCITY and actor:get_luminocity() or actor_obj:get_visibility()
end

function attach(sm)
	sm:subscribe({signal = "on_spawn",   			fun = this.create_window})
	sm:subscribe({signal = "on_destroy",   			fun = this.destroy_window})
end

function create_window()
	if not overlay then
		overlay = MainIngameOverlay(get_main_window())
	end
end

function destroy_window()
	if overlay then
		overlay:DetachWnd()
		overlay = nil
	end
end

class "MainIngameOverlay" (CUIScriptWnd)

function MainIngameOverlay:__init(owner) super()
	self.owner = owner
	self:InitControls()
	self:Subscribe()
	self.pickup_item = nil
end

function MainIngameOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_quick_item_set", self = self, fun = self.UpdateQuickSlots},
			{signal = "on_quick_item_use", self = self, fun = self.UpdateQuickSlots},
			{signal = "on_drop", self = self, fun = self.UpdateQuickSlotsAndPanels},
			{signal = "on_use", self = self, fun = self.UpdateQuickSlots},
			{signal = "on_item_to_loadout", self = self, fun = self.UpdateQuickSlots},
			{signal = "on_item_from_loadout", self = self, fun = self.UpdateQuickSlots},
			{signal = "on_slot", self = self, fun = self.UpdatePanelItems},
			{signal = "on_ruck", self = self, fun = self.UpdateQuickSlotsAndPanels},
			{signal = "on_belt", self = self, fun = self.UpdatePanelItems},
			{signal = "on_loadout_update_count", self = self, fun = self.UpdatePanelItems},
			{signal = "on_hud_state_switch", self = self, fun = self.OnHudStateSwitch},
			{signal = "on_pickup_item_set", self = self, fun = self.OnPickUpItemSet},
			{signal = "on_key_press", self = self, fun = self.OnKeyPress},
			{signal = "on_key_release", self = self, fun = self.OnKeyRelease},
		}
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function MainIngameOverlay:Unsubscribe()
	if self.subscribed then
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function MainIngameOverlay:DetachWnd()
	self.minimap_back:DetachChild(self.compass)
	self:Unsubscribe()
	self:ClearCallbacks()
	self.owner:DetachChild(self)
end

function MainIngameOverlay:InitControls()
	self.owner:AttachChild(self)
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self:Show(true)
	
	self.blood_overlay = CUIStatic()
	self.blood_overlay:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self.blood_overlay:InitTexture("ui_blood_overlay")
	self.blood_overlay:SetStretchTexture(true)
	self:AttachChild(self.blood_overlay)	
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	self.actor_params = xml:InitStatic("actor_params", self)
	self.conditions = {
		["health"] 		= { condition = function() return actor.health end },
		["power"] 		= { condition = function() return actor.power end },
		["stamina"] 	= { condition = function() return stamina.get_val() end },
		["visibility"] 	= { condition = function() return visibility() end },
		["noise"] 		= { condition = function() return actor_obj.sound_noise end },
	}
	for k,v in pairs(self.conditions) do
		v.back = xml:InitStatic("actor_params:"..k, self.actor_params)
		v.static = xml:InitStatic("actor_params:"..k..":static", v.back)
		v.bar = xml:InitProgressBar("actor_params:"..k..":progress_bar", v.back)
		v.show_val = xml:ReadAttribFlt("actor_params:"..k, "show_val", 0)
	end
	
	self.conditions_circles = {
		["health_circle"] 		= { condition = function() return actor.health end},
		["power_circle"] 		= { condition = function() return actor.power end},
		["stamina_circle"] 		= { condition = function() return stamina.get_val() end},
	}
	for k,v in pairs(self.conditions_circles) do
		v.back = xml:InitStatic("actor_params:"..k, self.actor_params)
		v.icon = xml:InitStatic("actor_params:"..k..":icon", v.back)
		v.progress_shape = xml:InitProgressShape("actor_params:"..k..":progress_shape", v.back)
		v.show_val = xml:ReadAttribFlt("actor_params:"..k, "show_val", 1)
	end
	
	--//car condition bar
	self.car = xml:InitStatic("actor_params:car", self.actor_params)
	self.car_static = xml:InitStatic("actor_params:car:static", self.car)
	self.car_bar = xml:InitProgressBar("actor_params:car:progress_bar", self.car)
	self.car_color_def = self.car_static:GetColor()
	self.car_color_engine_on = GetARGB(255, 0, 255, 0)
	
	--//stationary machinegun overheat bar
	self.mgun = xml:InitStatic("actor_params:mgun", self.actor_params)
	self.mgun_static = xml:InitStatic("actor_params:mgun:static", self.mgun)
	self.mgun_overheat_bar = xml:InitProgressBar("actor_params:mgun:progress_bar", self.mgun)
	
	--//motion icon
	self.motion_icon = xml:InitStatic("motion_icon", self)
	self.current_motion_texture = false

	--// quick slots
	self.quick_slots = xml:InitStatic("quick_slots", self)
	self.quick_slots.show_on_gear = (xml:ReadAttribInt("quick_slots", "show_on_gear", 0) > 0) and true or false

	--//slot colors
	self.quick_color_has_item 	= GetARGB(255, 255, 255, 255)
	self.quick_color_no_item 	= GetARGB(120, 255, 255, 255)

	local pos_x = xml:ReadAttribFlt("quick_slots:slot", "x", 0)
	local pos_y = xml:ReadAttribFlt("quick_slots:slot", "y", 0)	
	local horz = (xml:ReadAttribInt("quick_slots", "horz", 1) > 0) and true or false
	local indent = xml:ReadAttribFlt("quick_slots", "indent", 0)

	self.slots = {}
	for i=0,3 do
		local s = xml:InitStatic("quick_slots:slot", self.quick_slots)
		self.slots[i] = s
		s:SetText(game.translate_string("ui_quick_slot_"..i))
		s:SetWndPos(pos_x, pos_y)
		if horz then
			pos_x = pos_x + s:GetWidth() + indent
		else
			pos_y = pos_y + s:GetHeight() + indent
		end
		s.icon = xml:InitStatic("quick_slots:slot:icon", s)
		s.count = xml:InitStatic("quick_slots:slot:count", s)
		self:DrawSlotIcon(i)
	end
	
	local tmp_tbl, def_font, def_color = nil, "letterica16", "255, 255, 255, 255"
	--// slot panel
	self.slot_panel = xml:InitStatic("slot_panel", self)
	self.slot_panel.scale = xml:ReadAttribFlt("slot_panel", "scale", 1)
	self.slot_panel.indent = xml:ReadAttribFlt("slot_panel", "indent", 0)
	self.slot_panel.vertical = xml:ReadAttribInt("slot_panel", "vertical", 0) > 0 and true or false
	self.slot_panel.font = xml:ReadAttrib("slot_panel", "font", def_font)
	tmp_tbl = split_string(xml:ReadAttrib("slot_panel", "text_color", def_color), ",")
	self.slot_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	tmp_tbl = split_string(xml:ReadAttrib("slot_panel", "text_offset", "0,0"), ",")
	self.slot_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.slot_panel.slots = split_string(xml:ReadAttrib("slot_panel", "slots", ""), ",")
	self.slot_panel.align_center = xml:ReadAttribInt("slot_panel", "center", 0) > 0 and true or false
	--// belt panel
	self.belt_panel = xml:InitStatic("belt_panel", self)
	self.belt_panel.scale = xml:ReadAttribFlt("belt_panel", "scale", 1)
	self.belt_panel.indent = xml:ReadAttribFlt("belt_panel", "indent", 0)
	self.belt_panel.vertical = xml:ReadAttribInt("belt_panel", "vertical", 0) > 0 and true or false
	self.belt_panel.group_similar = xml:ReadAttribInt("belt_panel", "group_similar", 0) > 0 and true or false
	self.belt_panel.font = xml:ReadAttrib("belt_panel", "font", def_font)
	tmp_tbl = split_string(xml:ReadAttrib("belt_panel", "text_color", def_color), ",")
	self.belt_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	tmp_tbl = split_string(xml:ReadAttrib("belt_panel", "text_offset", "0,0"), ",")
	self.belt_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.belt_panel.align_center = xml:ReadAttribInt("belt_panel", "center", 0) > 0 and true or false
	self.belt_panel.hide_in_quick_slot = xml:ReadAttribInt("belt_panel", "hide_in_quick_slot", 0) > 0 and true or false
	--// loadout panel
	-- self.loadout_panel = xml:InitStatic("loadout_panel", self)
	-- self.loadout_panel.scale = xml:ReadAttribFlt("loadout_panel", "scale", 1)
	-- self.loadout_panel.indent = xml:ReadAttribFlt("loadout_panel", "indent", 0)
	-- self.loadout_panel.vertical = xml:ReadAttribInt("loadout_panel", "vertical", 0) > 0 and true or false
	-- self.loadout_panel.group_similar = xml:ReadAttribInt("loadout_panel", "group_similar", 0) > 0 and true or false
	-- self.loadout_panel.font = xml:ReadAttrib("loadout_panel", "font", def_font)
	-- tmp_tbl = split_string(xml:ReadAttrib("loadout_panel", "text_color", def_color), ",")
	-- self.loadout_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	-- tmp_tbl = split_string(xml:ReadAttrib("loadout_panel", "text_offset", "0,0"), ",")
	-- self.loadout_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	-- self.loadout_panel.align_center = xml:ReadAttribInt("loadout_panel", "center", 0) > 0 and true or false
	--// booster panel
	self.booster_panel = xml:InitStatic("booster_panel", self)
	self.booster_panel.scale = xml:ReadAttribFlt("booster_panel", "scale", 1)
	self.booster_panel.indent = xml:ReadAttribFlt("booster_panel", "indent", 0)
	self.booster_panel.vertical = xml:ReadAttribInt("booster_panel", "vertical", 0) > 0 and true or false
	self.booster_panel.font = xml:ReadAttrib("booster_panel", "font", def_font)
	tmp_tbl = split_string(xml:ReadAttrib("booster_panel", "text_color", def_color), ",")
	self.booster_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	tmp_tbl = split_string(xml:ReadAttrib("booster_panel", "text_offset", "0,0"), ",")
	self.booster_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.booster_panel.align_center = xml:ReadAttribInt("booster_panel", "center", 0) > 0 and true or false
	self:UpdatePanelItems()
	
	--//active item info
	self.active_item = xml:InitStatic("active_item", self)
	self.active_item_icon = xml:InitStatic("active_item:icon", self.active_item)
	self.active_item_icon.scale = xml:ReadAttribFlt("active_item:icon", "scale", 1)
	self.ammo_counter = xml:InitStatic("active_item:ammo_counter", self.active_item)
	self.zoom_counter = xml:InitStatic("active_item:zoom_counter", self.active_item)
	self.zoom_progress = xml:InitProgressBar("active_item:zoom_counter:progress_bar", self.zoom_counter)
	self.zoom_progress_icon = xml:InitStatic("active_item:zoom_counter:progress_bar:icon", self.zoom_counter)
	
	--//missile throw progressshape
	self.missile_throw = xml:InitProgressShape("throw_progress", self)
	self.missile_text = xml:InitStatic("throw_text", self)
	self.throw_force = 0
	
	--//pickup item icon
	self.pickup_item_icon = xml:InitStatic("pick_up_item", self)
	self.pickup_item_icon.size = vector2():set(self.pickup_item_icon:GetWidth(), self.pickup_item_icon:GetHeight())
	self.pickup_item_icon.offset = vector2():set(xml:ReadAttribInt("pick_up_item", "x", 0), xml:ReadAttribInt("pick_up_item", "y", 0))
	
	self.warning_icons_back = xml:InitStatic("icons_back", self)
	self.warning_icons_horz = (xml:ReadAttribInt("icons_back", "horz", 0) > 0) and true or false
	self.warning_icons = {
		{ name = "armor", 		val = function() return actor_get_outfit() and 1 - actor_get_outfit():condition() or 0 end },
		{ name = "weapon", 		val = function() return actor:active_item() and 1 - actor:active_item():condition() or 0 end },
		{ name = "radiation", 	val = function() return dosimeter.can_detect_radiation() and actor.radiation or 0 end },
		{ name = "bleeding", 	val = function() return actor:get_bleeding() end },
		{ name = "starvation", 	val = function() return 1 - actor.satiety end },
		{ name = "psy_health", 	val = function() return 1 - actor.psy_health end },
		{ name = "overweight", 	val = function() return inventory.get_overweight() end },
		{ name = "somnolence", 	val = function() return somnolence.get_val() end },		
		{ name = "godmode", 	val = function() return get_console():get_bool("g_god") end },
		{ name = "safehouse", 	val = function() return actor:has_info("safehouse") end },
		{ name = "limbs_injure", val = function() return body_health.get_injured_limb() end },
	}
	for k,v in ipairs(self.warning_icons) do
		v.icon = xml:InitStatic("icons_back:"..v.name, self.warning_icons_back)
		v.icon:Show(false)
		v.threshold = split_string(xml:ReadAttrib("icons_back:"..v.name, "threshold", nil), ",", true)
	end
	
	self.minimap = self.owner:GetStatic("minimap")
	self.minimap_back = self.owner:GetStatic("minimap:background")
	self.compass = xml:InitStatic("compass", self.minimap_back)
	self.compass_arrow = xml:InitStatic("compass:arrow", self.compass)
	self.dist_text = xml:InitStatic("compass:dist_text", self.compass)
	self.time_text = xml:InitStatic("compass:time_text", self.compass)
	
	--//active task
	self.active_task = xml:InitStatic("active_task", self)
	self.active_task:Show(false)
	self.active_task_show_time = xml:ReadAttribInt("active_task", "show_time", 5)
	self.task_icon = xml:InitStatic("active_task:task_icon", self.active_task)
	self.task_header = xml:InitStatic("active_task:task_header", self.active_task)
	self.objective_header = xml:InitStatic("active_task:objective_header", self.active_task)
	
	--//slot selector
	self.slot_selector = ui_slot_selector.SlotSelectorOverlay(self)
end

function MainIngameOverlay:UpdateConditions()
	for k,v in pairs(self.conditions) do
		v.bar:SetProgressPos(v.condition())
		v.back:Show(v.condition() <= v.show_val or not DYNAMIC_SHOW)
		--log3("cond %s val %s", k, v.condition())
	end
	
	for k,v in pairs(self.conditions_circles) do
		v.progress_shape:SetPos(v.condition())
		v.progress_shape:Show(v.condition() <= v.show_val or not DYNAMIC_SHOW)
	end
	
	
	self.blood_overlay:SetColor(GetARGB(255 * (1 - actor.health), 255, 255, 255))
end

function MainIngameOverlay:UpdateMotionIcon()
	self.motion_icon:Show(not actor:get_holder())
	local state = "normal"
	if actor_obj:is_actor_climb() or actor_obj:is_actor_climbing() then
		state = "climb"
	elseif actor_obj:is_actor_crouch() or actor_obj:is_actor_crouching() then
		state = "crouch"
	elseif actor_obj:is_actor_creep() or actor_obj:is_actor_creeping() then
		state = "creep"
	elseif actor_obj:is_actor_sprinting() then
		state = "sprint"		
	elseif (actor_obj:is_actor_moving() and not actor_obj:is_actor_running()) or actor_obj:is_zoom_aiming_mode() then
		state = "run"
	end
	local texture = MOTION_TEXTURE_PREFIX..state
	if self.current_motion_texture ~= texture then
		self.motion_icon:InitTexture(texture)
		self.current_motion_texture = texture
		--log3("~current state %s", state)
	end
end

function MainIngameOverlay:UpdateWarningIcons()
	local color, val, _v, _min, _max, size
	local pos = vector2():set(0,0)
	for k,v in ipairs(self.warning_icons) do
		if DEBUG_WARNING_SHOW then
			v.icon:Show(true)
		elseif not v.threshold then
			if v.name == "limbs_injure" then
				v.icon:Show(v.val() ~= "none")
				if v.icon:IsShown() then
					local actual_icon = "ui_hud_trauma_"..v.val()
					if self.limbs_injure_icon ~= actual_icon then
						v.icon:InitTexture(actual_icon)
						self.limbs_injure_icon = actual_icon
					end
					color = GetARGB(100, 238, 153, 26)
					local pain_eff = body_health.get_pain_effect()
					if pain_eff > 0 then
						color = GetARGB(100, 255, 0, 0)
					elseif pain_eff < 0 then
						color = GetARGB(100, 0, 255, 0)
					end
					v.icon:SetColor(color)
				end
			else
				v.icon:Show(v.val())
			end
		else
			size = table.size(v.threshold)
			_min = v.threshold[1]
			if size > 1 then
				val = v.val()
				if val < _min then
					v.icon:Show(false)
				else
					_max = v.threshold[size]
					for i=1, size do
						if (val >= v.threshold[i]) and (not v.threshold[i+1] or val < v.threshold[i+1]) then
							val = v.threshold[i]
							break
						end
					end
					_v = (val - _min) / (_max - _min) * 2
					color = GetARGB(255, math.clamp(255 * _v, 0, 255), math.clamp(255 * (2 - _v), 0, 255), 0)
					v.icon:SetColor(color)
					v.icon:Show(true)
				end
			else
				val = 1 - v.val();
				local threshold = 1 - _min
				threshold = math.clamp(threshold, 0.01, 1)
				if val <= threshold then
					_v = val / threshold
					_v = math.clamp(_v, 0, 1)
					color = GetARGB(255, 255, 255 * _v, 0)
					v.icon:SetColor(color)
					v.icon:Show(true)
				else
					v.icon:Show(false)
				end
			end
		end
		
		if v.icon:IsShown() then
			v.icon:SetWndPos(pos.x, pos.y)
			if self.warning_icons_horz then
				pos.x = pos.x + v.icon:GetWidth()
			else
				pos.y = pos.y + v.icon:GetHeight()
			end
		end
	end
end

function MainIngameOverlay:UpdateQuickSlotsAndPanels()
	self:UpdateQuickSlots()
	self:UpdatePanelItems()
end

function MainIngameOverlay:DrawSlotIcon(slot_num)
	local s = self.slots[slot_num]
	local sect = quick_slots.get_item_sect(slot_num)
	local show_icon = sect ~= ""
	s.icon:Show(show_icon)
	if show_icon then
		CIconParams(sect):set_shader(s.icon)
	end	
	
	local count = quick_slots.get_item_count(slot_num)
	local count_text = string.format("x%s", count)
	s.count:SetText(count_text)
	s.count:Show(count > 0)

	s.icon:SetColor(count > 0 and self.quick_color_has_item or self.quick_color_no_item)
end

function MainIngameOverlay:UpdateQuickSlots()
	for i=0,3 do
		self:DrawSlotIcon(i)
	end
end

function MainIngameOverlay:UpdatePanelItems()
	if level.is_removing_objects() then
	return end
	
	local item, params, item_st, text
	local pos = vector2():set(0,0)
	--// slots
	self.slot_panel:DetachAll()
	for _,i in ipairs(self.slot_panel.slots) do
		item = actor:item_in_slot(i)
		if item and (tonumber(i) ~= BACKPACK_SLOT or read_if_exists(sys_ini, "r_bool", item:section(), "quick_drop", false)) then
			params = CIconParams(item:section())
			item_st = CUIStatic()
			params:set_shader(item_st)
			item_st:SetWidth(params.grid_width * CELL_W * self.slot_panel.scale * get_current_kx())
			item_st:SetHeight(params.grid_height * CELL_H * self.slot_panel.scale)
			ui_inv_utils.AttachPanelIcons(item, item_st)
			item_st:SetWndPos(pos.x, pos.y)
			text = "ui_use_slot_"..i
			if tonumber(i) == TORCH_SLOT then
				local torch = torch.get_light_sect(item)
				local nvd = nvd.get_nvd_params(item:section())
				if not (torch and nvd) then
					if torch then
						text = "ui_switch_torch"
					elseif nvd then
						text = "ui_switch_night_vision"
					end
				end
			end
			item_st:SetText(game.translate_string(text))
			item_st:SetFont(GetFontCustom(self.slot_panel.font))
			item_st:SetTextColor(self.slot_panel.text_color)
			item_st:SetTextPos(self.slot_panel.text_offset.x, self.slot_panel.text_offset.y)
			if self.slot_panel.vertical then
				pos.y = pos.y + item_st:GetHeight() + self.slot_panel.indent
			else
				pos.x = pos.x + item_st:GetWidth() + self.slot_panel.indent
			end
			self.slot_panel:AttachChild(item_st)
		end
	end
	if self.slot_panel.align_center then
		local orig_pos = self.slot_panel:GetWndPos()
		if self.slot_panel.vertical then
			self.slot_panel:SetHeight(pos.y)
			self.slot_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.slot_panel:GetHeight() / 2)
		else
			self.slot_panel:SetWidth(pos.x)
			self.slot_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.slot_panel:GetWidth() / 2, orig_pos.y)
		end
	end
	--// belt
	self.belt_panel:DetachAll()
	local items = {}
	pos = vector2():set(0,0)
	for i = 0, actor:belt_count() - 1 do
		item = actor:item_on_belt(i)
		if item then
			self:TryAddToList(item, items, self.belt_panel.group_similar)
		end
	end
	for k,v in pairs(loadout.get_loaded_items()) do
		item = level.object_by_id(k)
		if item and (not self.belt_panel.hide_in_quick_slot or not quick_slots.is_in_quick_slot(item)) then
			self:TryAddToList(item, items, self.belt_panel.group_similar)
		end
	end	
	--table.sort(items,ui_inv_utils.sort_by_size_type)
	table.sort(items,ui_inv_utils.sort_by_quick_slot_num)
	for k, v in pairs(items) do
		params = CIconParams(v.item:section())
		item_st = CUIStatic()
		params:set_shader(item_st)
		item_st:SetWidth(params.grid_width * CELL_W * self.belt_panel.scale * get_current_kx())
		item_st:SetHeight(params.grid_height * CELL_H * self.belt_panel.scale)
		ui_inv_utils.AttachPanelIcons(v.item, item_st, v.count)
		item_st:SetWndPos(pos.x, pos.y)
		
		if self.belt_panel.vertical then
			pos.y = pos.y + item_st:GetHeight() + self.belt_panel.indent
		else
			pos.x = pos.x + item_st:GetWidth() + self.belt_panel.indent
		end
		self.belt_panel:AttachChild(item_st)
	end
	if self.belt_panel.align_center then
		local orig_pos = self.belt_panel:GetWndPos()
		if self.belt_panel.vertical then
			self.belt_panel:SetHeight(pos.y)
			self.belt_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.belt_panel:GetHeight() / 2)
		else
			self.belt_panel:SetWidth(pos.x)
			self.belt_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.belt_panel:GetWidth() / 2, orig_pos.y)
		end
	end		
end

function MainIngameOverlay:UpdatePanelBoosters()
	local item, params, item_st, text
	--// boosters
	self.booster_panel:DetachAll()
	local pos = vector2():set(0,0)
	for b_sect,b_time in pairs(boosters.get_all()) do
		params = CIconParams(b_sect)
		item_st = CUIStatic()
		params:set_shader(item_st)
		item_st:SetWidth(params.grid_width * CELL_W * self.booster_panel.scale * get_current_kx())
		item_st:SetHeight(params.grid_height * CELL_H * self.booster_panel.scale)
		--ui_inv_utils.AttachPanelIcons(item, item_st)
		item_st:SetWndPos(pos.x, pos.y)
		text = string.format("%.f %s", b_time, game.translate_string("st_time_minute"))
		item_st:SetText(game.translate_string(text))
		item_st:SetFont(GetFontCustom(self.booster_panel.font))
		item_st:SetTextColor(self.booster_panel.text_color)
		item_st:SetTextPos(self.booster_panel.text_offset.x, self.booster_panel.text_offset.y)
		if self.booster_panel.vertical then
			pos.y = pos.y + item_st:GetHeight() + self.booster_panel.indent
		else
			pos.x = pos.x + item_st:GetWidth() + self.booster_panel.indent
		end
		self.booster_panel:AttachChild(item_st)
	end
	if self.booster_panel.align_center then
		local orig_pos = self.booster_panel:GetWndPos()
		if self.booster_panel.vertical then
			self.booster_panel:SetHeight(pos.y)
			self.booster_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.booster_panel:GetHeight() / 2)
		else
			self.booster_panel:SetWidth(pos.x)
			self.booster_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.booster_panel:GetWidth() / 2, orig_pos.y)
		end
	end	
end

function MainIngameOverlay:TryAddToList(item, tbl, group_similar)
	local ammo = item:get_weapon_ammo()
	local item_count = (not ammo or ammo:is_magazine()) and 1 or ammo.box_curr
	if not group_similar then
		table.insert(tbl, {item = item, count = item_count})
	return end
	for k, v in pairs(tbl) do
		if ui_inv_utils.similar_item(v.item, item) then
			v.count = v.count + item_count
		return end
	end
	table.insert(tbl, {item = item, count = item_count})
end

function MainIngameOverlay:UpdateActiveItem()
	local act_item = actor:active_item()
	self.active_item:Show(act_item and (SHOW_ACTIVE_ITEM_INFO or SHOW_GEAR_INFO))

	if not self.active_item:IsShown() then
	return end
		
	local params
	local sect = act_item:section()
	local scale = self.active_item_icon.scale
	
	local wpn = act_item:get_weapon_m()
	self.active_item_icon:Show(true)
	
	local text, val = "", ""
	
	if wpn and get_clsid(act_item) ~= clsid.wpn_binocular_s then
		self.active_item_icon:Show(
			(SHOW_ACTIVE_ITEM_INFO and act_item:get_ammo_in_magazine() > 0) or 
			(SHOW_GEAR_INFO and (not wpn:addon_attachable(addon.magazine) or wpn:is_addon_attached(addon.magazine)))
		)
		local show_sect = get_cur_ammo_sect(act_item)
		if SHOW_GEAR_INFO and wpn:addon_attachable(addon.magazine) and wpn:is_addon_attached(addon.magazine) then
			show_sect = wpn:get_addon_name(addon.magazine)
		end
		params = CIconParams(show_sect)
		val = game.translate_string(read_if_exists(sys_ini, "r_string", show_sect, "inv_name_short", get_inv_name(show_sect)))
		if (SHOW_ACTIVE_ITEM_INFO and act_item:get_ammo_in_magazine() == 0) or
			(SHOW_GEAR_INFO and wpn:addon_attachable(addon.magazine) and not wpn:is_addon_attached(addon.magazine)) then
			val = game.translate_string("st_not_loaded")
		end
		text = string.format("%s", val)
		if has_fire_modes(act_item) or act_item:get_gl_mode() then
			text = string.format("%s %s", val, get_fire_mode_str(act_item))
		end
		self.active_item:SetText(text)
		
		val = act_item:get_ammo_in_magazine()
		text = string.format("[%s]", val)
		if SHOW_GEAR_INFO then
			local mag_weapon = wpn:addon_attachable(addon.magazine)
			local ammos = split_string(sys_ini:r_string(sect, mag_weapon and "magazine_class" or "ammo_class"), ",")
			local ammo_count = 0
			local inc
			function perform_action(dummy, item)
				for k,v in pairs(ammos) do
					if v == item:section() and item:get_weapon_ammo().box_curr > 0 and loadout.can_remove(item) then
						inc = mag_weapon and 1 or item:get_weapon_ammo().box_curr
						ammo_count = ammo_count + inc
					end
				end
			end	
			actor:iterate_ruck(perform_action, nil)			
			val = ammo_count
			text = string.format("%s", val)
		end
		self.ammo_counter:SetText(text)
	else
		self.active_item_icon:Show(true)
		
		if act_item:is_grenade() then
			local grenade_count = 0
			function perform_action(dummy, item)
				if item:is_grenade() and loadout.can_remove(item) then
					grenade_count = grenade_count + 1
				end
			end	
			actor:iterate_ruck(perform_action, nil)
			if grenade_count > 0 then
				val = grenade_count
				text = string.format("%s", val)
			end
		end
		
		if get_clsid(act_item) == clsid.obj_bolt and read_if_exists(sys_ini, "r_bool", "features", "limited_bolts", false) then
			local bolt_count = 0
			function perform_action(dummy, item)
				if get_clsid(item) == clsid.obj_bolt then
					bolt_count = bolt_count + 1
				end
			end	
			actor:iterate_ruck(perform_action, nil)
			if bolt_count > 0 then
				val = bolt_count
				text = string.format("%s", val)
			end
		end		
		
		self.ammo_counter:SetText(text)
		params = CIconParams(sect)
		self.active_item:SetText(game.translate_string(read_if_exists(sys_ini, "r_string", sect, "inv_name_short", get_inv_name(sect))))
	end
	params:set_shader(self.active_item_icon)
	if params.grid_height > 1 or params.grid_width > 2 then
		scale = scale * 0.75
	end
	self.active_item_icon:SetWidth(params.grid_width * scale * CELL_W * get_current_kx())
	self.active_item_icon:SetHeight(params.grid_height * scale * CELL_H)
	self.ammo_counter:SetWndPos(self.active_item_icon:GetWidth() + 5,self.ammo_counter:GetWndPos().y)
	
	self.zoom_counter:Show(wpn and wpn:is_addon_attached(addon.scope) and wpn.zoom_mode and wpn.zoom_rotation_factor == 1)
	if self.zoom_counter:IsShown() then
		local fov = get_console():get_float("fov")
		local cur_fov = device().fov
		local zoom = fov / cur_fov
		-- if zoom > 2 then
			-- zoom = math.floor(zoom+0.1)
		-- end
		self.zoom_counter:Show(zoom > 1)
		text = string.format("%s %.1fx", game.translate_string("st_zoom"), zoom)--string.format(zoom > 2 and "%s %.0fx" or "%s %.1fx", game.translate_string("st_zoom"), zoom)
		self.zoom_counter:SetText(text)
		local zoom_params = get_wpn_scope_zoom_params(act_item)
		self.zoom_progress:Show(zoom_params and #zoom_params>1)
		self.zoom_progress_icon:Show(self.zoom_progress:IsShown())
		if self.zoom_progress:IsShown() then
			local range = zoom_params[2] - zoom_params[1]
			zoom = zoom - zoom_params[1]
			zoom = zoom/range
			self.zoom_progress:SetProgressPos(zoom)		
		end	
	end
end

function MainIngameOverlay:UpdateCarPanel()
	local car = actor:get_holder() and actor:get_holder():get_car()
	self.car:Show(car)
	if car then
		self.car_bar:SetProgressPos(car:GetfHealth())
		self.car_static:SetColor(car:IsEngineOn() and self.car_color_engine_on or self.car_color_def)
	end
end

function MainIngameOverlay:UpdateMountedWpnPanel()
	local mgun = nil
	if actor:get_holder() and (get_clsid(actor:get_holder()) == clsid.wpn_mounted or get_clsid(actor:get_holder()) == clsid.wpn_stat_mgun) then
		mgun = actor:get_holder()
	end
	local binded_mgun = mgun and mgun:binded_object() or nil
	self.mgun:Show(binded_mgun)
	if binded_mgun then
		self.mgun_overheat_bar:SetProgressPos(binded_mgun:get_overheat())
	end
end

function MainIngameOverlay:UpdateMissileThrow()
	local val = 0
	local act_item = actor:active_item()
	if act_item and act_item:is_missile() and act_item:get_hud_item_state() == global_flags.eReady then
		local min_force = sys_ini:r_float(act_item:section(), "force_min")
		local max_force = sys_ini:r_float(act_item:section(), "force_max")
		self.throw_force = self.throw_force + device().f_time_delta * get_console():get_float("missile_force_grow_speed")
		self.throw_force = math.clamp(self.throw_force, min_force, max_force)
		
		val = (self.throw_force - min_force) / (max_force - min_force)
	else
		self.throw_force = 0
		val = 0
	end
	self.missile_throw:Show(val>0)
	self.missile_throw:SetPos(val)
	self.missile_text:Show(val>0)
	self.missile_text:SetText(string.format("[%.0f%s]", val*100, "%"))
end

local update_states = {
	[global_flags.eFire] = true,
	[global_flags.eReload] = true,
}
function MainIngameOverlay:OnHudStateSwitch(item, state, old_state)
	if update_states[old_state] then
		self:UpdatePanelItems()
	end
end

function MainIngameOverlay:OnPickUpItemSet(item)
	if not item or not self.pickup_item or item:id() ~= self.pickup_item:id() then
		self.pickup_item = item
		self.pickup_item_icon:Show(false)
		self.pickup_item_icon:DetachAll()
	end
end

function MainIngameOverlay:UpdatePickupItem()
	if not self.pickup_item or level.main_input_receiver() then
		if self.pickup_item_icon:IsShown() then
			self.pickup_item_icon:Show(false)
		end
		return
	end
	if self.pickup_item_icon:IsShown() then
	return end
	
	local params = CIconParams(self.pickup_item:section())
	params:set_shader(self.pickup_item_icon)
	local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)
	local static_size = self.pickup_item_icon.size
	
	local scale_x = static_size.x / icon_size.x
	scale_x = scale_x > 1 and 1 or scale_x
	local scale_y = static_size.y / icon_size.y
	scale_y = scale_y > 1 and 1 or scale_y
	local scale = math.min(scale_x, scale_y)
	self.pickup_item_icon:SetWidth(icon_size.x * scale)
	self.pickup_item_icon:SetHeight(icon_size.y * scale)
	local offset = ui_inv_utils.GetOffset("center", self.pickup_item_icon, self.owner)
	local icon_offset = self.pickup_item_icon.offset
	self.pickup_item_icon:SetWndPos(offset.x + icon_offset.x, offset.y + icon_offset.y)
	ogse_signals.get_mgr():call("on_pickup_item_showing", self.pickup_item, self.pickup_item_icon)
	self.pickup_item_icon:Show(true)
end

function MainIngameOverlay:UpdateMinimap()
	local h = device().cam_dir:getH()
	self.compass_arrow:SetHeading(-h)
	local dist = self.minimap:GetActivePointDist()
	local text = ""
	if dist >= 0.5 then
		text = string.format("%.f %s", dist, game.translate_string("st_m"))
	end
	self.dist_text:SetText(text)

	local _time = game.get_game_time():timeToString(game.CTime.TimeToMinutes)
	local text = string.format("%s", _time)
	self.time_text:SetText(text)	
end

function MainIngameOverlay:OnKeyPress(key, game_action)
	if game_action == key_bindings.kSCORES then
	
		self.slot_selector:ShowHideSelector()
	
		local task = actor:get_active_task()
		self.active_task:Show(task)
		if self.active_task:IsShown() then
		
			local text = game.translate_string(task:get_title() or "NO_TASK_TITLE")
			self.task_header:SetText(text)
		
			local objective = actor:get_active_objective()
			text = string.format("%s %s", game.translate_string("st_list_mark"), game.translate_string(objective:get_description() or "NO_OBJECTIVE_DESCRIPTION"))
			self.objective_header:SetText(text)
		
			local task_icon = task:get_objective(0):get_icon_name()
			self.task_icon:Show(task_icon)
			--log3("~task_icon %s", task_icon)
			if self.task_icon:IsShown() then
				self.task_icon:InitTexture(task_icon)
				local r = task:get_objective(0):get_icon_rect()
				self.task_icon:SetOriginalRect(r.x1, r.y1, r.x2, r.y2)
			end
		end
	end
	
	-- if game_action == key_bindings.kCHECKGEAR then
		-- if not level.main_input_receiver() or self.slot_selector:IsShown() then
			-- level.start_stop_menu(self.slot_selector,false)
			-- local console = get_console()
			-- if self.slot_selector:IsShown() then
				-- self.slot_selector:UpdateSlots()
				-- console:execute("time_factor 0.25")
			-- else
				-- console:execute("time_factor 1")
			-- end
		-- end
	-- end
end

function MainIngameOverlay:OnKeyRelease(key, game_action)
	if game_action == key_bindings.kSCORES or key == DIK_keys.DIK_ESCAPE then
		if self.active_task:IsShown() then
			self.active_task:Show(false)
		end
	end
end

function MainIngameOverlay:Update()
	CUIScriptWnd.Update(self)
	local alive = actor:alive()
	if not alive then
		self:Show(false)
	return end
	self:UpdateConditions()
	self:UpdateMotionIcon()
	self:UpdateCarPanel()
	self:UpdateMountedWpnPanel()
	self.slot_panel:Show(false)--(SHOW_GEAR_INFO)
	self.belt_panel:Show(SHOW_GEAR_INFO)
	--self.loadout_panel:Show(SHOW_GEAR_INFO)
	self.quick_slots:Show(false)--(not self.quick_slots.show_on_gear or SHOW_GEAR_INFO)
	self:UpdatePanelBoosters()
	self:UpdateActiveItem()
	self:UpdateMissileThrow()
	self:UpdateWarningIcons()
	self:UpdatePickupItem()
	self:UpdateMinimap()
	
	self.slot_selector:TrySignalHide()
end