-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\mainingame_overlay.xml"
local subscribed = false
local DYNAMIC_SHOW = true
local DEBUG_WARNING_SHOW = false
local USE_LUMINOCITY = false --read_if_exists(sys_ini, "bool", "features", "use_luminicity")

local MOTION_TEXTURE_PREFIX = "ui_hud_soldier_"
local MOTION_TEXTURE_POSTFIX = "_warning"

local relation_color = {
	[0] = GetARGB(255, 50, 255, 0),
	[1] = GetARGB(255, 255, 200, 0),
	[2] = GetARGB(255, 255, 0, 0),
}
local dead_color = GetARGB(255, 168, 168, 168)

_G.main_window = nil

function get_target_tip_point(tgt)
	if not tgt then
	return nil end
	local bone_name = "none"
	if tgt:is_trader() then
		bone_name = "bip01_neck"
	end
	if tgt:is_monster() then
		bone_name = get_species(tgt) == "zombie" and "bip01_spine1" or "bip01_spine2"
	end
	if tgt:is_stalker() then
		bone_name = tgt:alive() and "bip01_neck" or "bip01_spine1"
	end
	return tgt:get_bone_id(bone_name) ~= MAX_U16 and tgt:bone_position(bone_name) or tgt:center()
end

function visibility()
	return USE_LUMINOCITY and actor:get_luminocity() or actor_obj:get_visibility()
end

function attach(sm)
	sm:subscribe({signal = "on_spawn",   			fun = this.create_window})
	sm:subscribe({signal = "on_destroy",   			fun = this.destroy_window})
end

function create_window()
	if not main_window then
		_G.main_window = MainIngameOverlay(get_main_window())
	end
end

function destroy_window()
	if main_window then
		main_window:DetachWnd()
		_G.main_window = nil
	end
end

class "MainIngameOverlay" (CUIScriptWnd)

function MainIngameOverlay:__init(owner) super()
	self.owner = owner
	self:InitControls()
	self:Subscribe()
	self.pickup_item = nil
end

function MainIngameOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_quick_item_set", self = self, fun = self.SetPanelItemsNeedUpdate},
			--{signal = "on_quick_item_use", self = self, fun = self.UpdatePanelItems},
			{signal = "on_drop", self = self, fun = self.TryUpdatePanelItems},
			--{signal = "on_use", self = self, fun = self.UpdateQuickSlotsAndPanels},
			--{signal = "on_item_to_loadout", self = self, fun = self.UpdatePanelItems},
			--{signal = "on_item_from_loadout", self = self, fun = self.UpdatePanelItems},
			--{signal = "on_slot", self = self, fun = self.UpdatePanelItems},
			{signal = "on_ruck", self = self, fun = self.TryUpdatePanelItems},
			{signal = "on_belt", self = self, fun = self.SetPanelItemsNeedUpdate},
			{signal = "on_loadout_update_count", self = self, fun = self.SetPanelItemsNeedUpdate},
			{signal = "on_actor_menu_hide", self = self, fun = self.SetPanelItemsNeedUpdate},			
			{signal = "on_hud_state_switch", self = self, fun = self.OnHudStateSwitch},
			{signal = "on_pickup_item_set", self = self, fun = self.OnPickUpItemSet},
			{signal = "on_key_press", self = self, fun = self.OnKeyPress},
			{signal = "on_key_release", self = self, fun = self.OnKeyRelease},
			--//
			{signal = "on_article", self = self, fun = self.ShowFlashingIcon},
			{signal = "on_task", self = self, fun = self.ShowFlashingIcon},
			{signal = "on_pda_show", self = self, fun = self.HideFlashingIcon},
			
			{signal = "on_task_stage", self = self, fun = self.OnTaskUpdate},
			
			{signal = "on_slot_selector_show", self = self, fun = self.ShowActiveTask},
			{signal = "on_slot_selector_hide", self = self, fun = self.HideActiveTask},
			
			{signal = "on_custom_options_save", self = self, fun = self.OnCustomOptionsSave},
		}
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function MainIngameOverlay:Unsubscribe()
	if self.subscribed then
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function MainIngameOverlay:DetachWnd()
	self.minimap_back:DetachChild(self.compass)
	self:Unsubscribe()
	self:ClearCallbacks()
	self.owner:DetachChild(self)
end

function MainIngameOverlay:InitControls()
	self.owner:AttachChild(self)
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self:Show(true)
	
	self.screen_debug = CUIStatic()
	self.screen_debug:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self:AttachChild(self.screen_debug)
	-- self.screen_debug:InitTexture("ui\\circle_debug")
	-- self.screen_debug:SetStretchTexture(true)	
	-- local dbg_size = 35
	-- self.screen_debug:SetWidth(dbg_size * get_current_kx())
	-- self.screen_debug:SetHeight(dbg_size)
	-- self.screen_debug:SetWndPos(UI_BASE_WIDTH / 2 - self.screen_debug:GetWidth() / 2, UI_BASE_HEIGHT / 2 - self.screen_debug:GetHeight() / 2)
	
	-- self.blood_overlay = CUIStatic()
	-- self.blood_overlay:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	-- self.blood_overlay:InitTexture("ui_blood_overlay")
	-- self.blood_overlay:SetStretchTexture(true)
	-- self:AttachChild(self.blood_overlay)	
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	self.fps_counter = xml:InitStatic("fps_counter", self)
	
	self.blood_overlay = xml:InitStatic("blood_overlay", self)
	self.blood_overlay.fade_time = xml:ReadAttribFlt("blood_overlay", "fade_time", 0)
	
	self.actor_params = xml:InitStatic("actor_params", self)
	self.conditions = {
		["health"] 		= { condition = function() return actor.health end },
		["power"] 		= { condition = function() return actor.power end },
		["stamina"] 	= { condition = function() return stamina.get_val() end },
		["visibility"] 	= { condition = function() return visibility() end },
		["noise"] 		= { condition = function() return actor_obj.sound_noise end },
	}
	for k,v in pairs(self.conditions) do
		v.back = xml:InitStatic("actor_params:"..k, self.actor_params)
		v.static = xml:InitStatic("actor_params:"..k..":static", v.back)
		v.bar = xml:InitProgressBar("actor_params:"..k..":progress_bar", v.back)
		v.show_val = xml:ReadAttribFlt("actor_params:"..k, "show_val", 0)
	end
	
	self.conditions_circles = {
		["health_circle"] 		= { condition = function() return actor.health end},
		["power_circle"] 		= { condition = function() return actor.power end},
		["stamina_circle"] 		= { condition = function() return stamina.get_val() end},
	}
	for k,v in pairs(self.conditions_circles) do
		v.back = xml:InitStatic("actor_params:"..k, self.actor_params)
		v.icon = xml:InitStatic("actor_params:"..k..":icon", v.back)
		v.progress_shape = xml:InitProgressShape("actor_params:"..k..":progress_shape", v.back)
		v.show_val = xml:ReadAttribFlt("actor_params:"..k, "show_val", 1)
	end
	
	--//car condition bar
	self.car = xml:InitStatic("actor_params:car", self.actor_params)
	self.car_static = xml:InitStatic("actor_params:car:static", self.car)
	self.car_bar = xml:InitProgressBar("actor_params:car:progress_bar", self.car)
	self.car_color_def = self.car_static:GetColor()
	self.car_color_engine_on = GetARGB(255, 0, 255, 0)
	
	--//stationary machinegun overheat bar
	self.mgun = xml:InitStatic("actor_params:mgun", self.actor_params)
	self.mgun_static = xml:InitStatic("actor_params:mgun:static", self.mgun)
	self.mgun_overheat_bar = xml:InitProgressBar("actor_params:mgun:progress_bar", self.mgun)
	
	--//motion icon
	self.motion_icon = xml:InitStatic("motion_icon", self)
	self.current_motion_texture = false

	--// quick slots
	self.quick_slots = xml:InitStatic("quick_slots", self)
	self.quick_slots.show_on_gear = (xml:ReadAttribInt("quick_slots", "show_on_gear", 0) > 0) and true or false

	--//slot colors
	self.quick_color_has_item 	= GetARGB(255, 255, 255, 255)
	self.quick_color_no_item 	= GetARGB(120, 255, 255, 255)

	local pos_x = xml:ReadAttribFlt("quick_slots:slot", "x", 0)
	local pos_y = xml:ReadAttribFlt("quick_slots:slot", "y", 0)	
	local horz = (xml:ReadAttribInt("quick_slots", "horz", 1) > 0) and true or false
	local indent = xml:ReadAttribFlt("quick_slots", "indent", 0)

	self.slots = {}
	for i=0,3 do
		local s = xml:InitStatic("quick_slots:slot", self.quick_slots)
		self.slots[i] = s
		s:SetText(game.translate_string("ui_quick_slot_"..i))
		s:SetWndPos(pos_x, pos_y)
		if horz then
			pos_x = pos_x + s:GetWidth() + indent
		else
			pos_y = pos_y + s:GetHeight() + indent
		end
		s.icon = xml:InitStatic("quick_slots:slot:icon", s)
		s.count = xml:InitStatic("quick_slots:slot:count", s)
		self:DrawSlotIcon(i)
	end
	
	local tmp_tbl, def_font, def_color = nil, "letterica16", "255, 255, 255, 255"
	--// slot panel
	-- self.slot_panel = xml:InitStatic("slot_panel", self)
	-- self.slot_panel.scale = xml:ReadAttribFlt("slot_panel", "scale", 1)
	-- self.slot_panel.indent = xml:ReadAttribFlt("slot_panel", "indent", 0)
	-- self.slot_panel.vertical = xml:ReadAttribInt("slot_panel", "vertical", 0) > 0 and true or false
	-- self.slot_panel.font = xml:ReadAttrib("slot_panel", "font", def_font)
	-- tmp_tbl = split_string(xml:ReadAttrib("slot_panel", "text_color", def_color), ",")
	-- self.slot_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	-- tmp_tbl = split_string(xml:ReadAttrib("slot_panel", "text_offset", "0,0"), ",")
	-- self.slot_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	-- self.slot_panel.slots = split_string(xml:ReadAttrib("slot_panel", "slots", ""), ",")
	-- self.slot_panel.align_center = xml:ReadAttribInt("slot_panel", "center", 0) > 0 and true or false
	--// belt panel
	self.belt_panel = xml:InitStatic("belt_panel", self)
	self.belt_panel.scale = xml:ReadAttribFlt("belt_panel", "scale", 1)
	self.belt_panel.indent = xml:ReadAttribFlt("belt_panel", "indent", 0)
	self.belt_panel.vertical = xml:ReadAttribInt("belt_panel", "vertical", 0) > 0 and true or false
	self.belt_panel.group_similar = xml:ReadAttribInt("belt_panel", "group_similar", 0) > 0 and true or false
	self.belt_panel.font = xml:ReadAttrib("belt_panel", "font", def_font)
	tmp_tbl = split_string(xml:ReadAttrib("belt_panel", "text_color", def_color), ",")
	self.belt_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	tmp_tbl = split_string(xml:ReadAttrib("belt_panel", "text_offset", "0,0"), ",")
	self.belt_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.belt_panel.align_center = xml:ReadAttribInt("belt_panel", "center", 0) > 0 and true or false
	self.belt_panel.hide_in_quick_slot = xml:ReadAttribInt("belt_panel", "hide_in_quick_slot", 0) > 0 and true or false
	self.belt_panel.hide_modules = xml:ReadAttribInt("belt_panel", "hide_modules", 0) > 0 and true or false
	--// loadout panel
	-- self.loadout_panel = xml:InitStatic("loadout_panel", self)
	-- self.loadout_panel.scale = xml:ReadAttribFlt("loadout_panel", "scale", 1)
	-- self.loadout_panel.indent = xml:ReadAttribFlt("loadout_panel", "indent", 0)
	-- self.loadout_panel.vertical = xml:ReadAttribInt("loadout_panel", "vertical", 0) > 0 and true or false
	-- self.loadout_panel.group_similar = xml:ReadAttribInt("loadout_panel", "group_similar", 0) > 0 and true or false
	-- self.loadout_panel.font = xml:ReadAttrib("loadout_panel", "font", def_font)
	-- tmp_tbl = split_string(xml:ReadAttrib("loadout_panel", "text_color", def_color), ",")
	-- self.loadout_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	-- tmp_tbl = split_string(xml:ReadAttrib("loadout_panel", "text_offset", "0,0"), ",")
	-- self.loadout_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	-- self.loadout_panel.align_center = xml:ReadAttribInt("loadout_panel", "center", 0) > 0 and true or false
	--// booster panel
	self.booster_panel = xml:InitStatic("booster_panel", self)
	self.booster_panel.scale = xml:ReadAttribFlt("booster_panel", "scale", 1)
	self.booster_panel.indent = xml:ReadAttribFlt("booster_panel", "indent", 0)
	self.booster_panel.vertical = xml:ReadAttribInt("booster_panel", "vertical", 0) > 0 and true or false
	self.booster_panel.font = xml:ReadAttrib("booster_panel", "font", def_font)
	tmp_tbl = split_string(xml:ReadAttrib("booster_panel", "text_color", def_color), ",")
	self.booster_panel.text_color = GetARGB(tmp_tbl[1], tmp_tbl[2], tmp_tbl[3], tmp_tbl[4])
	tmp_tbl = split_string(xml:ReadAttrib("booster_panel", "text_offset", "0,0"), ",")
	self.booster_panel.text_offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.booster_panel.align_center = xml:ReadAttribInt("booster_panel", "center", 0) > 0 and true or false
	self:UpdatePanelItems()
	
	--//active item info
	self.active_item = xml:InitStatic("active_item", self)
	self.active_item_icon = xml:InitStatic("active_item:icon", self.active_item)
	self.active_item_icon.scale = xml:ReadAttribFlt("active_item:icon", "scale", 1)
	self.active_item_icon.indent = xml:ReadAttribFlt("active_item:icon", "indent", 5)
	self.active_item_icon_2 = xml:InitStatic("active_item:icon", self.active_item)
	self.active_item_icon_3 = xml:InitStatic("active_item:icon", self.active_item)
	self.ammo_counter = xml:InitStatic("active_item:ammo_counter", self.active_item)
	self.zoom_counter = xml:InitStatic("active_item:zoom_counter", self.active_item)
	self.zoom_progress = xml:InitProgressBar("active_item:zoom_counter:progress_bar", self.zoom_counter)
	self.zoom_progress_icon = xml:InitStatic("active_item:zoom_counter:progress_bar:icon", self.zoom_counter)
	
	--//missile throw progressshape
	self.missile_throw = xml:InitProgressShape("throw_progress", self)
	local offset = ui_inv_utils.GetOffset("center", self.missile_throw, self.owner)
	self.missile_throw:SetWndPos(offset.x, offset.y)
	self.missile_text = xml:InitStatic("throw_text", self)
	local offset = ui_inv_utils.GetOffset("center", self.missile_text, self.owner)
	self.missile_text:SetWndPos(offset.x, offset.y)
	
	--//pickup item icon
	self.pickup_item_icon = xml:InitStatic("pick_up_item", self)
	self.pickup_item_icon.size = vector2():set(self.pickup_item_icon:GetWidth(), self.pickup_item_icon:GetHeight())
	self.pickup_item_icon.offset = vector2():set(xml:ReadAttribInt("pick_up_item", "x", 0), xml:ReadAttribInt("pick_up_item", "y", 0))
	
	--//warning icons
	self.warning_icons = ui_warning_icons.WarningIcons(xml, self)
	
	--//classic top view compass
	self.minimap = self.owner:GetStatic("minimap")
	self.minimap_back = self.owner:GetStatic("minimap:background")
	self.compass = xml:InitStatic("compass_top_view", self.minimap_back)
	self.compass_arrow = xml:InitStatic("compass_top_view:arrow", self.compass)
	self.dist_text = xml:InitStatic("compass_top_view:dist_text", self.compass)
	self.time_text = xml:InitStatic("compass_top_view:time_text", self.compass)
	
	--//modern front view compass
	self.compass_modern = xml:InitStatic("compass_front_view", self)
	local compass_params = {}
	compass_params.marker_size = split_string(xml:ReadAttrib("compass_front_view", "mark_size", "8,10"), ",", true)
	compass_params.selected_marker_size = split_string(xml:ReadAttrib("compass_front_view", "selected_mark_size", "8,10"), ",", true)
	compass_params.other_marker_size = split_string(xml:ReadAttrib("compass_front_view", "other_mark_size", "8,10"), ",", true)
	compass_params.scale_texture_w = xml:ReadAttribInt("compass_front_view", "scale_texture_w", 2400)
	compass_params.scale_texture_h = xml:ReadAttribInt("compass_front_view", "scale_texture_h", 100)
	compass_params.x_to_angle_k = xml:ReadAttribInt("compass_front_view", "x_to_angle_k", 10)
	compass_params.vertical_mark_add = xml:ReadAttribInt("compass_front_view", "vertical_mark_add", 16)
	compass_params.hide_point_off_bound = xml:ReadAttribInt("compass_front_view", "hide_point_off_bound", 1) > 0 and true or false
	compass_params.hide_quest_point_off_bound = xml:ReadAttribInt("compass_front_view", "hide_quest_point_off_bound", 1) > 0 and true or false
	compass_params.distance_mark_scale = xml:ReadAttribInt("compass_front_view", "distance_mark_scale", 0) > 0 and true or false
	self.compass_modern.params = compass_params
    self.compass_modern_scale = xml:InitStatic("compass_front_view:scale", self.compass_modern)
    self.compass_modern_line = xml:InitStatic("compass_front_view:line", self.compass_modern)
	self.compass_modern_line_2 = xml:InitStatic("compass_front_view:line_2", self.compass_modern)
	
	--//active task
	self.active_task = xml:InitStatic("active_task", self)
	self.active_task:Show(false)
	self.active_task_show_time = xml:ReadAttribInt("active_task", "show_time", 5)
	self.task_icon = xml:InitStatic("active_task:task_icon", self.active_task)
	self.task_header = xml:InitStatic("active_task:task_header", self.active_task)
	self.task_header.base_color = self.task_header:GetTextColor()
	self.objective_header = xml:InitStatic("active_task:objective_header", self.active_task)
	self.objective_header.base_color = self.objective_header:GetTextColor()
	self.task_state_icon = xml:InitStatic("active_task:task_state_icon", self.active_task)
	self.task_remaining_time = xml:InitStatic("active_task:task_remaining_time", self.active_task)
	self.task_remaining_time_progress = xml:InitProgressBar("active_task:task_remaining_time_progress", self.active_task)
	
	--//slot selector
	self.slot_selector = ui_slot_selector.SlotSelectorOverlay()
	
	--//quick addon
	self.quick_addon = ui_quick_addon.QuickAddonOverlay()	
	
	--//target tip
	self.target_tip = xml:InitStatic("target_tip", self)
	self.target_tip.offset = xml:ReadAttrib("target_tip", "offset", "center")
	self.target_tip.offset_shift = split_string(xml:ReadAttrib("target_tip", "offset_shift", "0,0"), ",", true)
	self.target_tip.show_on_object = xml:ReadAttribInt("target_tip", "show_on_object", 0) > 0 and true or false
	self.target_tip.border = xml:ReadAttribInt("target_tip", "border", 0)
	self.tip_cursor = xml:InitStatic("tip_cursor", self)
	local size = xml:ReadAttribInt("tip_cursor", "size", 30)
	self.tip_cursor:SetWidth(size * get_current_kx())
	self.tip_cursor:SetHeight(size)
	local offset = ui_inv_utils.GetOffset("center", self.tip_cursor, self.owner)
	self.tip_cursor:SetWndPos(offset.x, offset.y)
	
	self.flashing_icon = xml:InitStatic("flashing_icon", self)
	self.flashing_icon:Show(false)
	
	--//NVD info
	self.nvd_info = xml:InitStatic("nvd_info", self)
	self.nvd_info.default_offset = {xml:ReadAttribInt("nvd_info", "x", 0), xml:ReadAttribInt("nvd_info", "y", 0)}
	self.nvd_info:Show(false)
	
	self.ammo_switch_info = xml:InitStatic("ammo_switch_info", self)
	self.ammo_switch_info.icon = xml:InitStatic("ammo_switch_info:icon", self.ammo_switch_info)
	self.ammo_switch_info.show_time = xml:ReadAttribFlt("ammo_switch_info:icon", "show_time", 2)
	self.ammo_switch_info:Show(false)
	
	--//crosshair
	self.crosshair = xml:InitStatic("crosshair", self)
	self.crosshair_parts = {
		["left"] 		= { static = CUIStatic(), offset_type = "left_center_out"},
		["right"] 		= { static = CUIStatic(), offset_type = "right_center_out"},
		["top"] 		= { static = CUIStatic(), offset_type = "center_top_out"},
		["down"] 		= { static = CUIStatic(), offset_type = "center_down_out"},
		["left_top"] 	= { static = CUIStatic(), offset_type = "left_top_out"},
		["right_top"] 	= { static = CUIStatic(), offset_type = "right_top_out"},
		["left_down"] 	= { static = CUIStatic(), offset_type = "left_down_out"},
		["right_down"] 	= { static = CUIStatic(), offset_type = "right_down_out"},	
	}
	for k,v in pairs(self.crosshair_parts) do
		v.static:SetStretchTexture(true)
		self.crosshair:AttachChild(v.static)
	end
	self.crosshair.min_size = xml:ReadAttribInt("crosshair", "min_size", 10)
	self.crosshair.max_size = xml:ReadAttribInt("crosshair", "max_size", 600)
	self.crosshair.scale_time = xml:ReadAttribFlt("crosshair", "scale_time", 2)
	self.crosshair:SetWidth(self.crosshair.min_size * get_current_kx())
	self.crosshair:SetHeight(self.crosshair.min_size)
	
	self:SetCrosshair()
	self:SetCrosshairColor()
end

function MainIngameOverlay:UpdateConditions()
	for k,v in pairs(self.conditions) do
		v.bar:SetProgressPos(v.condition())
		v.back:Show(v.condition() <= v.show_val or not DYNAMIC_SHOW)
		--log3("cond %s val %s", k, v.condition())
	end
	
	for k,v in pairs(self.conditions_circles) do
		v.progress_shape:SetPos(v.condition())
		v.progress_shape:Show(v.condition() <= v.show_val or not DYNAMIC_SHOW)
	end
	
	self:UpdateBloodOverlay()
end

function MainIngameOverlay:UpdateBloodOverlay()
	local max_alpha = 1 - actor.health
	local target_val = max_alpha
	if self.blood_overlay.fade_time > 0 then
		if self.blood_cur_alpha == nil then
			self.blood_cur_alpha = 0
		end	
		local change_part = target_val / self.blood_overlay.fade_time * level.get_time_factor()
		local conds = actor_obj.condition
		local f_dt = conds:fdelta_time() * 0.01
		--log3("~f_dt %s", f_dt)
		
		if self.dec_alpha then
			change_part = -change_part
		end
		
		--log3("~change_part %s", change_part)
		
		self.blood_cur_alpha = self.blood_cur_alpha + f_dt * change_part
		
		if self.blood_cur_alpha <= 0 then
			self.dec_alpha = false
		elseif self.blood_cur_alpha >= target_val then
			self.dec_alpha = true
		end
		self.blood_cur_alpha = math.clamp(self.blood_cur_alpha, 0, target_val)
	else
		self.blood_cur_alpha = max_alpha
	end
	--log3("~alpha %s", self.blood_cur_alpha)
	self.blood_overlay:SetColor(GetARGB(255 * self.blood_cur_alpha, 255, 255, 255))
end

function MainIngameOverlay:UpdateMotionIcon()
	self.motion_icon:Show(not actor:get_holder())
	local state = "normal"
	if actor_obj:is_actor_climb() or actor_obj:is_actor_climbing() then
		state = "climb"
	elseif actor_obj:is_actor_crouch() or actor_obj:is_actor_crouching() then
		state = "crouch"
	elseif actor_obj:is_actor_creep() or actor_obj:is_actor_creeping() then
		state = "creep"
	elseif actor_obj:is_actor_sprinting() then
		state = "sprint"		
	elseif (actor_obj:is_actor_moving() and not actor_obj:is_actor_running()) or actor_obj:is_zoom_aiming_mode() then
		state = "run"
	end
	local texture = MOTION_TEXTURE_PREFIX..state
	if self.current_motion_texture ~= texture then
		self.motion_icon:InitTexture(texture)
		self.current_motion_texture = texture
		--log3("~current state %s", state)
	end
end

function MainIngameOverlay:TryUpdatePanelItems(item, prev_place)
	if prev_place == item_place.belt or quick_slots.is_in_quick_slot(item) then 
		self:SetPanelItemsNeedUpdate()
	end
end

function MainIngameOverlay:DrawSlotIcon(slot_num)
	local s = self.slots[slot_num]
	local sect = quick_slots.get_item_sect(slot_num)
	local show_icon = sect ~= ""
	s.icon:Show(show_icon)
	if show_icon then
		--CIconParams(sect):set_shader(s.icon)
		SetCellIcon(s.icon, CIconParams(sect))
	end	
	
	local count = quick_slots.get_item_count(slot_num)
	local count_text = string.format("x%s", count)
	s.count:SetText(count_text)
	s.count:Show(count > 0)

	s.icon:SetColor(count > 0 and self.quick_color_has_item or self.quick_color_no_item)
end

function MainIngameOverlay:UpdateQuickSlots()
	for i=0,3 do
		self:DrawSlotIcon(i)
	end
end

function MainIngameOverlay:SetPanelItemsNeedUpdate()
	self.update_panel_items = true
end

function MainIngameOverlay:UpdatePanelItems()
	if level.is_removing_objects() then
	return end
	
	if not self.update_panel_items then
	return end
	self.update_panel_items = false

	local item, params, item_st, text
	local pos = vector2():set(0,0)
	--// slots
	-- self.slot_panel:DetachAll()
	-- for _,i in ipairs(self.slot_panel.slots) do
		-- item = actor:item_in_slot(i)
		-- if item and (tonumber(i) ~= BACKPACK_SLOT or read_if_exists(sys_ini, "bool", item:section(), "quick_drop", false)) then
			-- params = CIconParams(item:section())
			-- item_st = CUIStatic()
			-- params:set_shader(item_st)
			-- item_st:SetWidth(params.grid_width * CELL_W * self.slot_panel.scale * get_current_kx())
			-- item_st:SetHeight(params.grid_height * CELL_H * self.slot_panel.scale)
			-- ui_inv_utils.AttachPanelIcons(item, item_st)
			-- item_st:SetWndPos(pos.x, pos.y)
			-- text = "ui_use_slot_"..i
			-- if tonumber(i) == TORCH_SLOT then
				-- local torch = torch.get_light_sect(item)
				-- local nvd = nvd.get_nvd_params(item:section())
				-- if not (torch and nvd) then
					-- if torch then
						-- text = "ui_switch_torch"
					-- elseif nvd then
						-- text = "ui_switch_night_vision"
					-- end
				-- end
			-- end
			-- item_st:SetText(game.translate_string(text))
			-- item_st:SetFont(GetFontCustom(self.slot_panel.font))
			-- item_st:SetTextColor(self.slot_panel.text_color)
			-- item_st:SetTextPos(self.slot_panel.text_offset.x, self.slot_panel.text_offset.y)
			-- if self.slot_panel.vertical then
				-- pos.y = pos.y + item_st:GetHeight() + self.slot_panel.indent
			-- else
				-- pos.x = pos.x + item_st:GetWidth() + self.slot_panel.indent
			-- end
			-- self.slot_panel:AttachChild(item_st)
		-- end
	-- end
	-- if self.slot_panel.align_center then
		-- local orig_pos = self.slot_panel:GetWndPos()
		-- if self.slot_panel.vertical then
			-- self.slot_panel:SetHeight(pos.y)
			-- self.slot_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.slot_panel:GetHeight() / 2)
		-- else
			-- self.slot_panel:SetWidth(pos.x)
			-- self.slot_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.slot_panel:GetWidth() / 2, orig_pos.y)
		-- end
	-- end
	--// belt
	self.belt_panel:DetachAll()
	local items = {}
	pos = vector2():set(0,0)
	for i = 0, actor:belt_count() - 1 do
		item = actor:item_on_belt(i)
		if item and (not self.belt_panel.hide_modules or not loadout.is_module(item)) then
			ui_inv_utils.try_add_to_list(item, items, self.belt_panel.group_similar)
		end
	end
	for k,v in pairs(loadout.get_loaded_items()) do
		item = level.object_by_id(k)
		if item and (not self.belt_panel.hide_in_quick_slot or not quick_slots.is_in_quick_slot(item)) then
			ui_inv_utils.try_add_to_list(item, items, self.belt_panel.group_similar)
		end
	end	
	--table.sort(items,ui_inv_utils.sort_by_size_type)
	table.sort(items,ui_inv_utils.sort_by_quick_slot_num)
	for k, v in pairs(items) do
		params = CIconParams(v.item:section())
		item_st = CUIStatic()
		--params:set_shader(item_st)
		SetCellIcon(item_st, params)
		item_st:SetWidth(params.grid_width * CELL_W * self.belt_panel.scale * get_current_kx())
		item_st:SetHeight(params.grid_height * CELL_H * self.belt_panel.scale)
		ui_inv_utils.AttachPanelIcons(v.item, item_st, v.count)
		item_st:SetWndPos(pos.x, pos.y)
		
		if self.belt_panel.vertical then
			pos.y = pos.y + item_st:GetHeight() + self.belt_panel.indent
		else
			pos.x = pos.x + item_st:GetWidth() + self.belt_panel.indent
		end
		self.belt_panel:AttachChild(item_st)
	end
	if self.belt_panel.align_center then
		local orig_pos = self.belt_panel:GetWndPos()
		if self.belt_panel.vertical then
			self.belt_panel:SetHeight(pos.y)
			self.belt_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.belt_panel:GetHeight() / 2)
		else
			self.belt_panel:SetWidth(pos.x)
			self.belt_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.belt_panel:GetWidth() / 2, orig_pos.y)
		end
	end		
end

function MainIngameOverlay:UpdatePanelBoosters()
	local item, params, item_st, text
	--// boosters
	self.booster_panel:DetachAll()
	local pos = vector2():set(0,0)
	for b_sect,b_time in pairs(boosters.get_booster_sections()) do
		params = CIconParams(b_sect)
		item_st = CUIStatic()
		--params:set_shader(item_st)
		SetCellIcon(item_st, params)
		item_st:SetWidth(params.grid_width * CELL_W * self.booster_panel.scale * get_current_kx())
		item_st:SetHeight(params.grid_height * CELL_H * self.booster_panel.scale)
		--ui_inv_utils.AttachPanelIcons(item, item_st)
		item_st:SetWndPos(pos.x, pos.y)
		text = string.format("%.f %s", b_time, game.translate_string("st_time_minute"))
		item_st:SetText(game.translate_string(text))
		item_st:SetFont(GetFontCustom(self.booster_panel.font))
		item_st:SetTextColor(self.booster_panel.text_color)
		item_st:SetTextPos(self.booster_panel.text_offset.x, self.booster_panel.text_offset.y)
		if self.booster_panel.vertical then
			pos.y = pos.y + item_st:GetHeight() + self.booster_panel.indent
		else
			pos.x = pos.x + item_st:GetWidth() + self.booster_panel.indent
		end
		self.booster_panel:AttachChild(item_st)
	end
	if self.booster_panel.align_center then
		local orig_pos = self.booster_panel:GetWndPos()
		if self.booster_panel.vertical then
			self.booster_panel:SetHeight(pos.y)
			self.booster_panel:SetWndPos(orig_pos.x, UI_BASE_HEIGHT / 2 - self.booster_panel:GetHeight() / 2)
		else
			self.booster_panel:SetWidth(pos.x)
			self.booster_panel:SetWndPos(UI_BASE_WIDTH / 2 - self.booster_panel:GetWidth() / 2, orig_pos.y)
		end
	end	
end

function MainIngameOverlay:UpdateActiveItem()
	local act_item = actor:active_item()
	local act_device = actor:active_device()
	self.active_item:Show((act_item or act_device) and SHOW_ACTIVE_ITEM_INFO)

	if not self.active_item:IsShown() then
	return end
		
	local params, params_2, params_3
	local show_sect, show_sect_2, show_sect_3
	local scale = self.active_item_icon.scale
	local scale_2 = self.active_item_icon.scale
	local scale_3 = self.active_item_icon.scale
	local indent = self.active_item_icon.indent
	
	local wpn = act_item and act_item:get_weapon_m()
	self.active_item_icon:Show(false)
	self.active_item_icon_2:Show(false)
	self.active_item_icon_3:Show(false)
	
	self.active_item:SetText("")
	self.ammo_counter:SetText("")
	self.active_item_icon:SetText("")
	
	local text, val = "", ""
	
	if wpn and get_clsid(act_item) ~= clsid.wpn_binocular_s then
		self.active_item_icon:Show(act_item:get_ammo_in_magazine() > 0)
		self.active_item_icon_2:Show(wpn:is_addon_attached(addon.magazine))
		
		show_sect = get_cur_ammo_sect(act_item)
		show_sect_2 = wpn:is_addon_attached(addon.magazine) and wpn:get_addon_name(addon.magazine) or nil
		
		params = CIconParams(show_sect)
		
		if show_sect_2 and self.active_item_icon_2:IsShown() then
			params_2 = CIconParams(show_sect_2)
		end
		
		val = game.translate_string(read_if_exists(sys_ini, "string", show_sect, "inv_name_short", get_inv_name(show_sect)))
		if act_item:get_ammo_in_magazine() == 0 then
			val = game.translate_string("st_not_loaded")
		end
		text = string.format("%s", val)
		if has_fire_modes(act_item) or act_item:get_gl_mode() then
			text = string.format("%s %s", val, get_fire_mode_str(act_item))
		end
		self.active_item:SetText(text)
		
		val = act_item:get_ammo_in_magazine()
		text = string.format("[%s]", val)
		self.ammo_counter:SetText(text)
	elseif act_item then
		self.active_item_icon:Show(true)
		show_sect = act_item:section()
		
		if act_item:is_grenade() then
			local grenade_count = 0
			function perform_action(dummy, item)
				if item:is_grenade() and loadout.can_remove(item) then
					grenade_count = grenade_count + 1
				end
			end	
			actor:iterate_ruck(perform_action, nil)
			if grenade_count > 0 then
				val = grenade_count
				text = string.format("%s", val)
			end
		end
		
		if get_clsid(act_item) == clsid.obj_bolt and LIMITED_BOLTS then
			local bolt_count = 0
			function perform_action(dummy, item)
				if get_clsid(item) == clsid.obj_bolt then
					bolt_count = bolt_count + 1
				end
			end	
			actor:iterate_ruck(perform_action, nil)
			if bolt_count > 0 then
				val = bolt_count
				text = string.format("%s", val)
			end
		end
		
		if act_item:get_pda() and is_power_device(act_item) then
			self.active_item_icon:SetText(string.format("%.f%s", act_item:binded_object():get_power_level() * 100, "%"))
		end
		
		self.ammo_counter:SetText(text)
		params = CIconParams(show_sect)
		self.active_item:SetText(get_inv_name_short(show_sect))
	end
	
	if self.active_item_icon:IsShown() then
		--params:set_shader(self.active_item_icon)
		SetCellIcon(self.active_item_icon, params)
		if params.grid_height > 1 or params.grid_width > 2 then
			scale = scale * 0.75
		end
		self.active_item_icon:SetWidth(params.grid_width * scale * CELL_W * get_current_kx())
		self.active_item_icon:SetHeight(params.grid_height * scale * CELL_H)
		
		self.active_item_icon:DetachAll()
		ui_inv_utils.UpdateLayerIcons(show_sect, self.active_item_icon)
	end
	self.ammo_counter:SetWndPos(self.active_item_icon:GetWidth() + indent, self.ammo_counter:GetWndPos().y)
	
	if self.active_item_icon_2:IsShown() then
		--params_2:set_shader(self.active_item_icon_2)
		SetCellIcon(self.active_item_icon_2, params_2)
		if params_2.grid_height > 1 or params_2.grid_width > 2 then
			scale_2 = scale_2 * 0.75
		end
		self.active_item_icon_2:SetWidth(params_2.grid_width * scale_2 * CELL_W * get_current_kx())
		self.active_item_icon_2:SetHeight(params_2.grid_height * scale_2 * CELL_H)
		local pos = self.ammo_counter:GetWndPos()
		if self.active_item_icon:IsShown() then
			pos = self.active_item_icon:GetWndPos()
		end
		pos.x = pos.x - self.active_item_icon_2:GetWidth() - indent
		self.active_item_icon_2:SetWndPos(pos.x, pos.y)
		
		self.active_item_icon_2:DetachAll()
		ui_inv_utils.UpdateLayerIcons(show_sect_2, self.active_item_icon_2)
	end
	
	self.active_item_icon_3:Show(act_device)
	if self.active_item_icon_3:IsShown() then
		show_sect_3 = act_device:section()
		params_3 = CIconParams(show_sect_3)
		--params_3:set_shader(self.active_item_icon_3)
		SetCellIcon(self.active_item_icon_3, params_3)
		if params_3.grid_height > 1 or params_3.grid_width > 2 then
			scale_3 = scale * 0.75
		end		
		self.active_item_icon_3:SetWidth(params_3.grid_width * scale_3 * CELL_W * get_current_kx())
		self.active_item_icon_3:SetHeight(params_3.grid_height * scale_3 * CELL_H)
		local pos = self.ammo_counter:GetWndPos()
		if self.active_item_icon:IsShown() then
			pos = self.active_item_icon:GetWndPos()
		end
		if self.active_item_icon_2:IsShown() then
			pos = self.active_item_icon_2:GetWndPos()
		end
		pos.x = pos.x - self.active_item_icon_3:GetWidth() - indent
		self.active_item_icon_3:SetWndPos(pos.x, pos.y)
		local text = ""
		if is_power_device(act_device) then
			self.active_item_icon_3:SetText(string.format("%.f%s", act_device:binded_object():get_power_level() * 100, "%"))
		end
		if self.active_item:GetText() == "" then
			self.active_item:SetText(get_inv_name_short(show_sect_3))
		end
		
		self.active_item_icon_3:DetachAll()
		ui_inv_utils.UpdateLayerIcons(show_sect_3, self.active_item_icon_3)
	end
	
	self.zoom_counter:Show(wpn and wpn:is_addon_attached(addon.scope) and wpn.zoom_mode and wpn.zoom_rotation_factor == 1)
	if self.zoom_counter:IsShown() then
		local zoom = wpn.zoom_factor--wpn:second_vp_enabled() and wpn:second_vp_zoom() or wpn.zoom_factor
		-- if zoom > 2 then
			-- zoom = math.floor(zoom+0.1)
		-- end
		self.zoom_counter:Show(zoom > 1)
		text = string.format("%s %.1fx", game.translate_string("st_zoom"), zoom)--string.format(zoom > 2 and "%s %.0fx" or "%s %.1fx", game.translate_string("st_zoom"), zoom)
		self.zoom_counter:SetText(text)
		local zoom_params = get_wpn_scope_zoom_params(act_item)
		self.zoom_progress:Show(zoom_params and #zoom_params>1)
		self.zoom_progress_icon:Show(self.zoom_progress:IsShown())
		if self.zoom_progress:IsShown() then
			local range = zoom_params[2] - zoom_params[1]
			zoom = zoom - zoom_params[1]
			zoom = zoom/range
			self.zoom_progress:SetProgressPos(zoom)		
		end	
	end
end

function MainIngameOverlay:UpdateCarPanel()
	local car = actor:get_holder() and actor:get_holder():get_car()
	self.car:Show(car)
	if car then
		self.car_bar:SetProgressPos(car:GetfHealth())
		self.car_static:SetColor(car:IsEngineOn() and self.car_color_engine_on or self.car_color_def)
	end
end

function MainIngameOverlay:UpdateMountedWpnPanel()
	local mgun = nil
	if actor:get_holder() and (get_clsid(actor:get_holder()) == clsid.wpn_mounted or get_clsid(actor:get_holder()) == clsid.wpn_stat_mgun) then
		mgun = actor:get_holder()
	end
	local binded_mgun = mgun and mgun:binded_object() or nil
	self.mgun:Show(binded_mgun)
	if binded_mgun then
		self.mgun_overheat_bar:SetProgressPos(binded_mgun:get_overheat())
	end
end

function MainIngameOverlay:UpdateMissileThrow()
	local val = 0
	local act_item = actor:active_item()
	local missile = act_item and act_item:get_missile()
	if missile and act_item:get_hud_item_state() == global_flags.eReady then
		val = (missile.throw_force - missile.min_force) / (missile.max_force - missile.min_force)
	else
		val = 0
	end
	self.missile_throw:Show(val>0)
	self.missile_throw:SetPos(val)
	self.missile_text:Show(val>0)
	self.missile_text:SetText(string.format("[%.0f%s]", val*100, "%"))
end

local update_states = {
	[global_flags.eFire] = true,
	[global_flags.eReload] = true,
	[global_flags.eShutter] = true,
}
local crosshair_set_states = {
	[global_flags.eShowing] = true,
	-- [global_flags.eHidden] = true,
	-- [global_flags.eHiding] = true,	
}
function MainIngameOverlay:OnHudStateSwitch(item, state, old_state)
	if update_states[old_state] then
		self:SetPanelItemsNeedUpdate()
	end
	if crosshair_set_states[state] and not item:get_device() then
		self:SetCrosshair(read_if_exists(sys_ini, "string", item:section(), "crosshair", nil))
		self:UpdateCrosshair(true)
	end
end

function MainIngameOverlay:OnPickUpItemSet(item)
	if not item or not self.pickup_item or item:id() ~= self.pickup_item:id() then
		self.pickup_item = item
		self.pickup_item_icon:Show(false)
		self.pickup_item_icon:DetachAll()
	end
end

function MainIngameOverlay:UpdatePickupItem()
	if not self.pickup_item or level.main_input_receiver() then
		if self.pickup_item_icon:IsShown() then
			self.pickup_item_icon:Show(false)
		end
		return
	end
	if self.pickup_item_icon:IsShown() then
	return end
	
	local params = CIconParams(self.pickup_item:section())
	--params:set_shader(self.pickup_item_icon)
	SetCellIcon(self.pickup_item_icon, params)
	
	ui_inv_utils.CellItemFitToSize(params, self.pickup_item_icon, nil, self.pickup_item_icon.size)
	
	local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)

	local offset = ui_inv_utils.GetOffset("center", self.pickup_item_icon, self.owner)
	local icon_offset = self.pickup_item_icon.offset
	self.pickup_item_icon:SetWndPos(offset.x + icon_offset.x, offset.y + icon_offset.y)
	ogse_signals.get_mgr():call("on_pickup_item_showing", self.pickup_item, self.pickup_item_icon)
	self.pickup_item_icon:Show(true)
end

function MainIngameOverlay:UpdateCompass()
	local pda = actor_get_pda()
	local pda_workable = pda and pda:is_power_on() and pda:condition() > 0
	
	-- local show_compass = get_script_option_value("front_view_compass")
	-- local show_on_demand = get_script_option_value("compass_on_demand")
	
	self.owner.show_zone_map = pda_workable and SHOW_GEAR_INFO--not show_compass and (not show_on_demand or SHOW_GEAR_INFO)
	
	local dist = self.minimap:GetActivePointDist()
	local dist_show = dist >= 0.5
	
	self.dist_text:Show(dist_show)
	self.time_text:Show(pda_workable)
	
	local h = device().cam_dir:getH()
	
	--///top view compass
	self.compass_arrow:SetHeading(-h)
	local target_dist_text = ""
	if dist_show then
		target_dist_text = string.format("%.f %s", dist, game.translate_string("st_m"))
	end
	self.dist_text:SetText(target_dist_text)
	local _time = game.get_game_time():timeToString(game.CTime.TimeToMinutes)
	local text = string.format("%s", _time)
	self.time_text:SetText(text)
	
	--//front view compass
	local params = self.compass_modern.params
	--self.compass_modern:Show(show_compass and (not show_on_demand or SHOW_GEAR_INFO))
    local angle = math.deg(-h)
	angle = angle < 0 and angle + 360 or angle
    --self.compass_modern_line:SetText(math.floor(angle + 0.5))
	self.compass_modern_line:SetText(target_dist_text)
    local x = angle * params.x_to_angle_k 	--//Frect x1
    local y = 0 							--//Frect y1
    local width = params.scale_texture_w 	--//Frect x2
    local height = params.scale_texture_h 	--//Frect y2
    self.compass_modern_scale:SetOriginalRect(x, y, width, height)
	self:ShowFrontViewMarks()
end

local map_spot_to_texture = {
	["crlc_big"] = "ui_icons_newPDA_SmallBlue",
	["crlc_mdl"] = "ui_icons_newPDA_SmallBlue",
	["crlc_small"] = "ui_icons_newPDA_SmallBlue",
	["blue_location"] = "ui_icons_mapPDA_persBig_e",
	["green_location"] = "ui_icons_mapPDA_persBig_h",
	["red_location"] = "ui_icons_mapPDA_mark_t",	
	["quest_pointer"] = "ui_map_selected",
	["eliminate_lager_location"] = "ui_mapQuest_camp_destroy",
	["eliminate_lair_location"] = "ui_mapQuest_lair_destroy",
	["defend_lager_location"] = "ui_mapQuest_camp_defend",
	["artefact_location"] = "ui_mapQuest_artefact",
	["kill_stalker_location"] = "ui_mapQuest_stalker_destroy",
	["monster_part_location"] = "ui_mapQuest_monster_find",
	["find_item_location"] = "ui_mapQuest_item",
	["general_wounded_location"] = "exclamation_mark",
	["treasure"] = "ui_mapQuest_gold",
	["spot_trader_cop"] = "ui_inGame2_PDA_icon_Stalker_Trader",
	["spot_stalker_cop"] = "ui_inGame2_PDA_icon_Stalker_VIP",
	["spot_mechanic_cop"] = "ui_inGame2_PDA_icon_Stalker_machanik",
	["spot_medic_cop"] = "ui_inGame2_PDA_icon_Stalker_Medic",
	["spot_guide_cop"] = "ui_inGame2_PDA_icon_Stalker_guide",
	["spot_storebox_cop"] = "ui_inGame2_PDA_icon_Actor_Box",
	["spot_place_to_rest_cop"] = "ui_inGame2_PDA_icon_Place_to_rest",
	["spot_treasure_cop"] = "ui_inGame2_PDA_icon_secret",
	["spot_primary_cop"] = "ui_inGame2_PDA_icon_Primary_mission",
	["spot_secondary_cop"] = "ui_inGame2_PDA_icon_Secondary_mission",
}

function MainIngameOverlay:ShowFrontViewMarks()
	local compass_targets = {}
	self.compass_modern_scale:DetachAll()
	--self.screen_debug:DetachAll()
	if not self.compass_modern:IsShown() then
	return end
	local params = self.compass_modern.params
	local pda = actor_get_pda()
	local pda_radius = pda and read_if_exists(sys_ini, "float", pda:section(), "radius", 50) or 50
	local objective = actor:get_active_objective()
	local tgt_id = objective and objective:get_object_id() or nil
	--//nearest objects
	function perform_action(obj)
		if obj:is_stalker() or obj:is_trader() then
			local pos = point_on_screen.compass_ui_projection(obj:center(), self.compass_modern_scale:GetWidth(), self.compass_modern_scale:GetHeight() + params.vertical_mark_add, params.hide_point_off_bound)
			if pos then
				local marker_data = {
					pos = pos,
					dist = distance_between(actor, obj),
					color = relation_color[obj:relation(actor)],
				}
				if not obj:alive() then
					marker_data.color = dead_color
					--marker_data.texture = "ui_PDA_checker_t"
				end
				local hidden = (obj:is_relation_enemy(actor) and obj:alive() and not actor:see(obj)) or not alife():object(obj:id()):visible_for_map()
				if not hidden then
					table.insert(compass_targets, marker_data)
				end
			end
		end
		for spot, texture in pairs(map_spot_to_texture) do
			if level.map_has_object_spot(obj:id(), spot) ~= 0 and obj:id() ~= tgt_id then
				local pos = point_on_screen.compass_ui_projection(obj:center(), self.compass_modern_scale:GetWidth(), self.compass_modern_scale:GetHeight() + params.vertical_mark_add, params.hide_point_off_bound)
				if pos then
					local marker_data = {
						pos = pos,
						dist = distance_between(actor, obj),
						texture = texture,
						size = params.other_marker_size,
					}
					if spot == "general_wounded_location" then
						marker_data.color = relation_color[2]
					end
					table.insert(compass_targets, marker_data)
				end
			end
		end
	end		
	level.iterate_nearest(actor:position(), pda_radius, perform_action)
	--//selected quest target
	if objective then
		local dist = self.minimap:GetActivePointDist()
		local sim = alife()
		local sobj = sim:object(tgt_id)
		local obj_pos = nil
		if sobj then
			if sobj.level_id == sim:level_id() then
				local cobj = level.object_by_id(tgt_id)
				obj_pos = cobj and cobj:center() or sobj.position
			else
				for id, _ in pairs(db.level_changers) do
					local lc = level.object_by_id(id)
					if lc then
						local dist_to_lc = distance_between(actor, lc)
						if dist and math.fsimilar(dist, dist_to_lc, 1) then
							obj_pos = lc:center()
							break
						end
					end
				end				
			end
			local pos = point_on_screen.compass_ui_projection(obj_pos, self.compass_modern_scale:GetWidth(), self.compass_modern_scale:GetHeight() + params.vertical_mark_add, params.hide_quest_point_off_bound)
			if pos then
				--target map spot
				for spot, texture in pairs(map_spot_to_texture) do
					if level.map_has_object_spot(tgt_id, spot) ~= 0 then
						local size = table.copy(params.other_marker_size)
						local dist_k = params.distance_mark_scale and pda_radius / dist or 1
						dist_k = math.clamp(dist_k, 0.5, 1)
						size[1] = size[1] * dist_k
						size[2] = size[2] * dist_k
						local marker_data = {
							pos = pos,
							dist = dist,
							texture = texture,
							size = size
						}
						if spot == "general_wounded_location" then
							marker_data.color = relation_color[2]
						end
						table.insert(compass_targets, marker_data)
						break						
					end
				end
				--additional selected map spot			
				local size = table.copy(params.selected_marker_size)
				local dist_k = params.distance_mark_scale and pda_radius / dist or 1
				dist_k = math.clamp(dist_k, 0.5, 1)
				size[1] = size[1] * dist_k
				size[2] = size[2] * dist_k
				local marker_data = {
					pos = pos,
					dist = dist,
					texture = map_spot_to_texture["quest_pointer"],
					size = size
				}
				table.insert(compass_targets, marker_data)
			end
		end
	end
	table.sort( compass_targets, function(a,b) return a.dist > b.dist end )
	local marker_size = params.marker_size
	for k, v in ipairs(compass_targets) do
		local obj_point = CUIStatic()
		self.compass_modern_scale:AttachChild(obj_point)
		--self.screen_debug:AttachChild(obj_point)
		obj_point:SetStretchTexture(true)
		obj_point:InitTexture(v.texture or "ui_minimap_point")
		obj_point:SetWidth(v.size and v.size[1] or marker_size[1])
		obj_point:SetHeight(v.size and v.size[2] or marker_size[2])
		if v.color then
			obj_point:SetColor(v.color)
		end
		local offset = ui_inv_utils.GetOffset("center", obj_point, self.compass_modern_scale)
		obj_point:SetWndPos(v.pos.x - obj_point:GetWidth() / 2, v.pos.y - obj_point:GetHeight() / 2)
	end
end

function MainIngameOverlay:UpdateTargetTip()
	local tip = actor_obj:get_default_action_for_obj()
	if not tip and self.pickup_item then
		tip = "inventory_item_use"
	end
	self.target_tip:Show(tip and tip ~= "" and (actor_hands_free() or actor:ph_capture()))
	if self.target_tip:IsShown() then
		local tgt = level.get_target_obj() or self.pickup_item
			
		--//eat object
		if tgt and tgt:get_eatable_item() then
			tip = string.format("%s\\n%s", game.translate_string(tip), game.translate_string("eatable_item_use"))
		end
		
		--//drag object
		if tgt and tgt:actor_can_capture() then
			local can_drag = not tgt:get_inventory_item() and level.get_target_dist() <= PULL_DISTANCE
			if tip == "game_object_drag" or tip == game.translate_string("game_object_drag") then
				tip = can_drag and tip or ""
			elseif can_drag then
				tip = string.format("%s\\n%s", game.translate_string(tip), game.translate_string("game_object_drag"))
			end
		end
		
		local text = ""
		if get_script_option_value("hud_target_info") then
			if tgt and tgt:get_inventory_item() then
				text = get_inv_name(tgt:section())
			end
			if tgt and (tgt:is_stalker() or tgt:is_trader()) then
				text = string.format("%s%s%s", color_by_relation[tgt:relation(actor)], tgt:character_name(), "%c[default] ")
			end
			if tgt and tgt:is_monster() then
				local props, sect = xr_statistic.getNpcType(tgt)
				text = game.translate_string(sect)
			end
		end
		text = string.format("%s\\n%s", text, game.translate_string(tip))
		self.target_tip:SetText(text)
		self.target_tip:AdjustWidthToText()
		self.target_tip:AdjustHeightToText()		
		
		self.target_tip:SetWidth(self.target_tip:GetWidth() + self.target_tip.border)
		self.target_tip:SetHeight(self.target_tip:GetHeight() + self.target_tip.border)
		
		local offset = vector2()
		if self.target_tip.show_on_object then
			local point = get_target_tip_point(tgt)
			local pos = tgt and point_on_screen.point_projection(point) or nil
			if pos then
				offset.x = pos.x - self.target_tip:GetWidth() * 0.5
				offset.y = pos.y - self.target_tip:GetHeight() * 0.5
			end
		else
			ui_inv_utils.GetOffset(self.target_tip.offset, self.target_tip, self.owner)
		end
		offset.x = offset.x + self.target_tip.offset_shift[1]
		offset.y = offset.y + self.target_tip.offset_shift[2]
		self.target_tip:SetWndPos(offset.x, offset.y)
		--hud_add_info_message("quick_info", game.translate_string(tip))
	else
		self.target_tip:SetText("")
		--hud_remove_info_message("quick_info")
	end
	--self.tip_cursor:Show(tip and tip ~= "" and not get_console():get_bool("hud_crosshair"))
	local is_zoom = actor_obj:is_zoom_aiming_mode()
	local hud_target_mode = get_script_option_value("hud_target_mode")
	local show = false
	if hud_target_mode == 3 then
		show = true
	elseif hud_target_mode == 2 then
		show = not is_zoom and not self.crosshair:IsShown() and actor_hands_free()
	elseif hud_target_mode == 1 then
		show = not is_zoom and tip and tip ~= ""
	end
	self.tip_cursor:Show(show)
	local target_dist = ""
	--if get_console():get_bool("hud_crosshair_dist") then
	if get_script_option_value("hud_target_dist") then
		target_dist = string.format("%.1f", level.get_target_dist())
	end
	self.tip_cursor:SetText(target_dist)
end

function MainIngameOverlay:OnKeyPress(key, game_action)
	if game_action == key_bindings.kSCORES then
		self.slot_selector:ShowHide()
	end
	
	if game_action == key_bindings.kQUICK_ADDON then
		self.quick_addon:ShowHide()
	end
	
	if game_action == key_bindings.kDROP then
		local act_item = actor:active_item()
		local act_device = actor:active_device()
		local item_to_drop = key_state(bind_to_dik(key_bindings.kADDITIONAL_ACTION)) and act_device or act_item
		if item_to_drop then
			actor:drop_item(item_to_drop)
		end
	end
	
	local mir = level.main_input_receiver()
	
	if game_action == key_bindings.kCHECKACTIVEITEM and not SHOW_ACTIVE_ITEM_INFO and not mir then
		local act_item = actor:active_item()
		local act_device = actor:active_device()
		if (not act_item and not act_device) then 
			outfit_anim.play_outfit("inspect")
		end
		if act_item then
			ammo_check_anim.try_play_anim(act_item)
		end
		local ACTIVE_ITEM_INFO_TTL = get_script_option_value("active_item_info_ttl")
		if act_device and dosimeter.is_dosimeter(act_device) and act_device:is_power_on() then
			dosimeter.show_actor_radiation()
			local str = string.format("%s: %.2f %s ", game.translate_string("st_actor_radiation"), actor.radiation * 100, game.translate_string("st_percent"))--actor.radiation, game.translate_string("st_rad"))
			hud_add_info_message("item_usage", str, ACTIVE_ITEM_INFO_TTL)
		end
		_G.SHOW_ACTIVE_ITEM_INFO = true
		self.active_item_info_hide_time = time_global() + ACTIVE_ITEM_INFO_TTL * 1000
	end
	
	if game_action == key_bindings.kCHECKGEAR and not SHOW_GEAR_INFO and not mir then
		_G.SHOW_GEAR_INFO = true
		self.gear_info_hide_time = time_global() + get_script_option_value("gear_info_ttl") * 1000
	end
end

function MainIngameOverlay:OnKeyRelease(key, game_action)
	-- if game_action == key_bindings.kSCORES or key == DIK_keys.DIK_ESCAPE then
		-- self:ShowActiveTask(false)
	-- end
end

function MainIngameOverlay:UpdateActiveItemInfo()
	if SHOW_ACTIVE_ITEM_INFO then
		if self.active_item_info_hide_time and time_global() >= self.active_item_info_hide_time then
			_G.SHOW_ACTIVE_ITEM_INFO = false
			self.active_item_info_hide_time = nil
		end
	end
end

function MainIngameOverlay:UpdateGearInfo()
	if SHOW_GEAR_INFO then
		if self.gear_info_hide_time and time_global() >= self.gear_info_hide_time then
			_G.SHOW_GEAR_INFO = false
			self.gear_info_hide_time = nil
		end
	end
end

function MainIngameOverlay:ShowActiveTask()
	self:ShowTask(true)
end

function MainIngameOverlay:HideActiveTask()
	self:ShowTask(false)
end

local task_stage_color = {
	["new"] 		= GetARGB(255, 255, 255, 0),--GetARGB(255, 0, 255, 0),
	["update"] 		= GetARGB(255, 255, 255, 0),--GetARGB(255, 238, 153, 26),
	["complete"] 	= GetARGB(255, 0, 255, 0),
	["fail"] 		= GetARGB(255, 255, 0, 0),
}
function MainIngameOverlay:ShowTask(b_show, _task, _objective, _stage)
	if b_show then
		local task = _task or actor:get_active_task()
		self.active_task:Show(task)
		self.task_state_icon:Show(_task)
		self.task_header:SetTextColor(self.task_header.base_color)
		self.objective_header:SetTextColor(self.objective_header.base_color)
		if self.active_task:IsShown() then
			local text = game.translate_string(task:get_title() or "NO_TASK_TITLE")
			self.task_header:SetText(text)
			
			local objective_description = "NO_OBJECTIVE_DESCRIPTION"
			if _stage then
				if _stage == "new" or _stage == "update" then
					local idx = _objective:get_idx() + 1
					if _task:get_objectives_cnt() ~= idx then
						objective_description = _task:get_objective(idx):get_description()
					end
				else
					objective_description = "general_".._stage.."_task"
				end
				self.task_state_icon:SetColor(task_stage_color[_stage])
				self.task_state_icon:InitTexture(_stage.."_task_icon")
				
				self.task_header:SetTextColor(task_stage_color[_stage])
				self.objective_header:SetTextColor(task_stage_color[_stage])
			else
				objective_description = actor:get_active_objective():get_description()
			end
			text = string.format("%s %s", game.translate_string("st_list_mark"), game.translate_string(objective_description))
			self.objective_header:SetText(text)
		
			local task_icon = task:get_objective(0):get_icon_name()
			self.task_icon:Show(task_icon)
			--log3("~task_icon %s", task_icon)
			if self.task_icon:IsShown() then
				self.task_icon:InitTexture(task_icon)
				local r = task:get_objective(0):get_icon_rect()
				self.task_icon:SetOriginalRect(r.x1, r.y1, r.x2, r.y2)
			end
			
			self.task_remaining_time:Show(false)
			self.task_remaining_time_progress:Show(false)
			local random_task = task_manager.get_active_random_task(task:get_id())
			if random_task then
				local task_info = task_manager.get_random_task_info(random_task)
				if task_info and task_info.time then
					local c_time = game.CTime()
					c_time:setHMS(task_info.time, 0, 0)
					local current_time = game.get_game_time()
					local deadline_time = task_info.give_task_time + c_time
					local deadline_time_diff = deadline_time - current_time

					local curr_diff_sec = deadline_time:diffSec(current_time)
					local deadline_diff_sec = deadline_time:diffSec(task_info.give_task_time)
					
					self.task_remaining_time:SetText(string.format("%s%s %s%s", curr_diff_sec <= 3600 and "%c[red]" or "%c[default]", deadline_time_diff:timeToString(game.CTime.TimeToMinutes), "%c[default]", game.translate_string("st_task_remaining_time")))
					self.task_remaining_time:Show(true)

					self.task_remaining_time_progress:SetProgressPos(curr_diff_sec/deadline_diff_sec)
					self.task_remaining_time_progress:Show(true)
				end
			end
		end		
	else
		if self.active_task:IsShown() then
			self.active_task:Show(false)
		end		
	end
end

function MainIngameOverlay:ShowFlashingIcon()
	self.flashing_icon:Show(true)
end
function MainIngameOverlay:HideFlashingIcon()
	self.flashing_icon:Show(false)
end

function MainIngameOverlay:OnTaskUpdate(_task, _objective, _stage)
	self:ShowTask(true, _task, _objective, _stage)
	add_time_delayed_action(5, function() self:ShowTask(false) end)
end

function MainIngameOverlay:UpdateNVDInfo()
	self.nvd_info:Show(nvd.is_nvd_on())
	if not self.nvd_info:IsShown() then
	return end
	local item_nvd = nvd.get_current_nvd()
	local text = ""
	if is_power_device(item_nvd) then
		text = string.format("%s: %.1f\\n%s: %.f%s", game.translate_string("st_nvd_intensity"), nvd.get_current_intensity(), game.translate_string("st_nvd_power_level"), item_nvd:binded_object():get_power_level() * 100, "%")
	else
		text = string.format("%s: %.1f", game.translate_string("st_nvd_intensity"), nvd.get_current_intensity())
	end
	self.nvd_info:SetText(text)
	local params = nvd.get_nvd_params(item_nvd:section())
	self.nvd_info:SetTextColor(GetARGB(255, params.R * 255, params.G * 255, params.B * 255))
	local offset = params.HUD_INFO_OFFSET and split_string(params.HUD_INFO_OFFSET, ",", true) or self.nvd_info.default_offset
	self.nvd_info:SetWndPos(offset[1], offset[2])
end

local crosshair_hide_states = {
	[global_flags.eReload] = true,
	[global_flags.eHiding] = true,
	[global_flags.eHidden] = true,
}

function MainIngameOverlay:UpdateCrosshair(forced)
	self.crosshair:Show(not actor_obj:is_zoom_aiming_mode() and get_script_option_value("hud_crosshair"))
	if not self.crosshair:IsShown() then
	return end
	local act_item = actor:active_item()
	if not act_item or act_item:get_pda() then
		self.crosshair:Show(false)
	return end
	
	if act_item:is_hud_item() and crosshair_hide_states[act_item:get_hud_item_state()] then
		self.crosshair:Show(false)
	return end
	
	if actor_obj:is_actor_sprinting() then
		self.crosshair:Show(false)
	return end
	
	local act_wpn = act_item and act_item:get_weapon()
	if act_wpn then
		if act_wpn.zoom_rotation_factor > 0 then
			self.crosshair:Show(false)
		end
	end
	local dispertion = act_wpn and act_wpn:get_fire_dispertion(true) or 0
	self:DrawCrosshair(dispertion, forced)
end

function MainIngameOverlay:DrawCrosshair(dispertion, forced)
	local size = self.crosshair.min_size
	if self.crosshair.auto_scale and dispertion > 0 then
		--//     UI
		--log3("~dispertion %s", dispertion)
		--//       (  scr_h)    (FOV)
		local dev = device()
		local scr_h = dev.height
		local fov2 = math.rad(dev.fov * 0.5)
		local scr_dist = 0.5 * scr_h / math.tan(fov2)
		--//       (scr_dist)    (dispertion )
		size = 2 * scr_dist * math.tan(dispertion * 0.5)
	end
	
	size = size * self.crosshair.const_scale
	--log3("~size %s", size)
	if forced then
		self.crosshair:SetWidth(size * get_current_kx())
		self.crosshair:SetHeight(size)	
	else
		local current_size = self.crosshair:GetHeight()
		if not math.fsimilar(size, current_size, 1) then
			--log3("~calc size")
			local delta = device().f_time_delta / self.crosshair.scale_time * 1000
			delta = math.clamp(delta, 0, math.abs(size - current_size))
			--log3("~delta %s", delta)
			local dk = size < current_size and -1 or 1
			local set_size = current_size + delta * dk
			--log3("~set_size %s", set_size)
			set_size = math.clamp(set_size, self.crosshair.min_size, self.crosshair.max_size)
			self.crosshair:SetWidth(set_size * get_current_kx())
			self.crosshair:SetHeight(set_size)
		end
	end

	local ui_pos = level.get_crosshair_pos()
	--log3("~ui_pos %s %s", ui_pos.x, ui_pos.y)
	self.crosshair:SetWndPos(ui_pos.x - self.crosshair:GetWidth() / 2, ui_pos.y - self.crosshair:GetHeight() / 2)
	
	for k, v in pairs(self.crosshair_parts) do
		local offset = ui_inv_utils.GetOffset(v.offset_type, v.static, self.crosshair)
		v.static:SetWndPos(offset.x, offset.y)
	end
end

function MainIngameOverlay:SetCrosshair(section)
	if not section then
		section = "crosshair_default"
	end
	
	self.crosshair.auto_scale = read_if_exists(sys_ini, "bool", section, "auto_scale", true)
	self.crosshair.const_scale = read_if_exists(sys_ini, "float", section, "const_scale", 1)
	
	-- local color = split_string(read_if_exists(sys_ini, "string", section, "color", "255,255,255,255"), ",")
	-- self.crosshair.color = GetARGB(color[1],color[2],color[2],color[4])
	
	local center = read_if_exists(sys_ini, "string", section, "center", "none")
	self.crosshair:InitTexture(center)
	--self.crosshair:SetColor(self.crosshair.color)
	
	for part_name, v in pairs(self.crosshair_parts) do
		local params = read_if_exists(sys_ini, "string", section, part_name, nil)
		v.static:Show(params)
		if params then
			params = split_string(params, ",")
			v.static:InitTexture(params[1])
			v.static:SetWidth((params[2] or 1) * get_current_kx())
			v.static:SetHeight(params[3] or 1)
			-- v.static:SetColor(self.crosshair.color)
		end
	end
end

function MainIngameOverlay:SetCrosshairColor()
	self.crosshair.color = GetARGB(
		get_script_option_value("crosshair_color_a"),
		get_script_option_value("crosshair_color_r"),
		get_script_option_value("crosshair_color_g"),
		get_script_option_value("crosshair_color_b")
	)
	self.crosshair:SetColor(self.crosshair.color)
	for part_name, v in pairs(self.crosshair_parts) do
		v.static:SetColor(self.crosshair.color)
	end
end

function MainIngameOverlay:OnCustomOptionsSave()
	self:SetCrosshairColor()
end

function MainIngameOverlay:ShowAmmoSwitchInfo(ammo_sect)
	local params = CIconParams(ammo_sect)
	SetCellIcon(self.ammo_switch_info.icon, params)
	self.ammo_switch_info.icon:DetachAll()
	ui_inv_utils.UpdateLayerIcons(ammo_sect, self.ammo_switch_info.icon)
	local tip = string.format("%s:\\n%s", game.translate_string("st_next_ammo_type"), get_inv_name_short(ammo_sect))
	self.ammo_switch_info:SetText(tip)
	self.ammo_switch_info.hide_time = time_global() + self.ammo_switch_info.show_time * 1000
	self.ammo_switch_info:Show(true)
end

function MainIngameOverlay:UpdateAmmoSwitchInfo()
	if self.ammo_switch_info:IsShown() then
		if self.ammo_switch_info.hide_time and time_global() >= self.ammo_switch_info.hide_time then
			self.ammo_switch_info:Show(false)
			self.ammo_switch_info.hide_time = nil
		end		
	end
end

function MainIngameOverlay:Update()
	CUIScriptWnd.Update(self)
	local alive = actor:alive()
	if not alive then
		self:Show(false)
	return end
	self:UpdateConditions()
	self:UpdateMotionIcon()
	self:UpdateCarPanel()
	self:UpdateMountedWpnPanel()
	--self.slot_panel:Show(false)--(SHOW_GEAR_INFO)
	self.belt_panel:Show(SHOW_GEAR_INFO)
	--self.loadout_panel:Show(SHOW_GEAR_INFO)
	self.quick_slots:Show(false)--(not self.quick_slots.show_on_gear or SHOW_GEAR_INFO)
	self:UpdatePanelItems()
	self:UpdatePanelBoosters()
	self:UpdateActiveItem()
	self:UpdateMissileThrow()
	self:UpdatePickupItem()
	self:UpdateCompass()
	self:UpdateNVDInfo()
	self:UpdateCrosshair()
	
	self:UpdateTargetTip()
	
	self:UpdateActiveItemInfo()
	self:UpdateGearInfo()
	self:UpdateAmmoSwitchInfo()
end