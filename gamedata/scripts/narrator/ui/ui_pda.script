-- -*- mode: lua; coding: windows-1251-dos -*-
local overlay = nil
local OVERLAY_XML = "script_overlays\\pda_overlay.xml"

function attach(sm)
	sm:subscribe({signal = "on_spawn",   fun = this.create_window})
	sm:subscribe({signal = "on_destroy",   fun = this.destroy_window})
end

local subscribed = false

function create_window()
	if not overlay then
		overlay = PDAOverlay(level.get_pda_wnd())
	end
end

function destroy_window()
	if overlay then
		overlay:DetachWnd()
		overlay = nil
	end
end

function skip_time(h, m)
	level.add_pp_effector("blink.ppe", 999, false)
	change_game_time(0, h, m)
	xr_sound.get_safe_sound_object("device\\pda\\pda_alarm"):play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)
end

class "PDAOverlay" (CUIScriptWnd)

function PDAOverlay:__init(owner) super()
	self.owner = owner
	self:InitControls()
	--self:Subscribe()
	self.wait_h = 0
	self.wait_m = 0
	self:UpdateTimer()
end

-- function PDAOverlay:Subscribe()
	-- self.subscribed = false
	-- if not self.subscribed then
		-- self.subscribed = {
			-- {signal = "on_update", self = self, fun = self.Update},
		-- }
		-- local sm = ogse_signals.get_mgr()
		-- for _, s in ipairs( self.subscribed ) do
			-- sm:subscribe( s )
		-- end
	-- end
-- end

-- function PDAOverlay:Unsubscribe()
	-- if self.subscribed then
		-- local sm = ogse_signals.get_mgr()
		-- for _, s in ipairs( self.subscribed ) do
			-- sm:unsubscribe( s )
		-- end
		-- self.subscribed = false
	-- end
-- end

function PDAOverlay:DetachWnd()
	--self:Unsubscribe()
	self:ClearCallbacks()
	self.owner:DetachChild(self)
end

function PDAOverlay:InitControls()
	self.owner:AttachChild(self)
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self:Enable(true)
	self:Show(true)
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)

	--//date/time
	self.date_time = xml:InitFrameLine("time_frame_line", self)
	self.date = xml:InitStatic("date", self.date_time)
	self.time = xml:InitStatic("time", self.date_time)
	self:Register(self.date, "date")
	self:AddCallback("date", ui_events.WINDOW_LBUTTON_DOWN, self.ShowSkipTimer, self)
	self:Register(self.time, "date")
	self:AddCallback("time", ui_events.WINDOW_LBUTTON_DOWN, self.ShowSkipTimer, self)	
	
	--//power level
	self.power_static = xml:InitStatic("power_level", self.date_time)
	self.def_power_color = self.power_static:GetTextColor()
	self.power_icon = xml:InitStatic("power_level_icon", self.power_static)
	self.power_progress = xml:InitProgressBar("power_level_progress", self.power_static)
	
	self.money_static = xml:InitStatic("money", self.date_time)
	
	--// off button
	self.btn_off = xml:Init3tButton("off_button", self)
	self:Register(self.btn_off, "off_btn")
	self:AddCallback("off_btn", ui_events.BUTTON_CLICKED, self.HidePda, self)
	
	--//skip timer
	self.skip_time_frame = xml:InitFrame("timer_frame", self)
	self.skip_time_frame:Show(false)
	
	self.skip_time_header = xml:InitStatic("timer_header", self.skip_time_frame)
	self.hour_st = xml:InitStatic("hour_static", self.skip_time_frame)
	self.minute_st = xml:InitStatic("minute_static", self.skip_time_frame)
	self.hm_separator = xml:InitStatic("separator_static", self.skip_time_frame)
	
	self.minus_h = xml:Init3tButton("minus_button_h", self.hour_st)
	self:Register(self.minus_h, "minus_hour")
	self:AddCallback("minus_hour", ui_events.BUTTON_CLICKED, self.DecHour, self)
	
	self.plus_h = xml:Init3tButton("plus_button_h", self.hour_st)
	self:Register(self.plus_h, "plus_hour")
	self:AddCallback("plus_hour", ui_events.BUTTON_CLICKED, self.IncHour, self)
	
	self.minus_m = xml:Init3tButton("minus_button_m", self.minute_st)
	self:Register(self.minus_m, "minus_minute")
	self:AddCallback("minus_minute", ui_events.BUTTON_CLICKED, self.DecMinute, self)
	
	self.plus_m = xml:Init3tButton("plus_button_m", self.minute_st)
	self:Register(self.plus_m, "plus_minute")
	self:AddCallback("plus_minute", ui_events.BUTTON_CLICKED, self.IncMinute, self)
	
	self.skip_time = xml:Init3tButton("wait_button", self.skip_time_frame)
	self:Register(self.skip_time, "skip_time")
	self:AddCallback("skip_time", ui_events.BUTTON_CLICKED, self.SkipTime, self)
	
	self.clear_time = xml:Init3tButton("clear_button", self.skip_time_frame)
	self:Register(self.clear_time, "clear_time")
	self:AddCallback("clear_time", ui_events.BUTTON_CLICKED, self.ClearTime, self)
end

function PDAOverlay:Update()
	CUIScriptWnd.Update(self)
	local pda = actor_get_pda()
	
	local has_pda_power = pda and pda:is_power_on()
	self.btn_off:Show(has_pda_power)
	self.date_time:Show(has_pda_power)
	
	-- local show = has_pda_power and actor:has_info("ui_pda_actor_info")--self.owner:FindChild("detail_days_in_game")
	-- self.skip_time_frame:Show(show)

	local power = is_power_device(pda) and pda:binded_object():get_power_level() or 1
	local text = string.format("%.0f%s", power * 100, "%")	
	self.power_static:SetText(text)
	self.power_progress:SetProgressPos(power)
	if power <= 0.1 then
		self.power_static:SetTextColor(255, 255, 0, 0)
	elseif self.power_static:GetTextColor() ~= self.def_power_color then
		self.power_static:SetTextColor(self.def_power_color)
	end
	
	text = string.format("%.0f %s", actor:money(), game.translate_string("ui_st_money_regional"))	
	self.money_static:SetText(text)
	
	local _time = game.get_game_time()
	self.date:SetText(_time:dateToString(game.CTime.DateToDay))
	self.time:SetText(_time:timeToString(game.CTime.TimeToMinutes))
	
	self:UpdateRelationSpotText()
end

local spot_type = {
	neutral_location = true,
	friend_location = true,
	enemy_location = true,
	deadbody_location = true,
}

function PDAOverlay:UpdateRelationSpotText()
	function perform_action(obj)
		if not obj:is_actor() and (obj:is_stalker() or obj:is_trader()) then
			for spot, v in pairs(spot_type) do
				if level.map_has_object_spot(obj:id(), spot) then
					local hint_text = string.format("%s%s\\n%s[%s]", color_by_relation[obj:relation(actor)], obj:character_name(), "%c[white]", game.translate_string(obj:character_community()))
					level.map_change_spot_hint(obj:id(), spot, hint_text)
				end
			end			
		end
	end	
	local detect_radius = read_if_exists(sys_ini, "r_float", actor_get_pda():section(), "radius", 50)
	level.iterate_nearest(actor:position(), detect_radius, perform_action)
end

function PDAOverlay:UpdateTimer()
	self.hour_st:SetText(self.wait_h)
	self.minute_st:SetText(self.wait_m)
end

function PDAOverlay:DecHour()
	self.wait_h = self.wait_h - 1
	if self.wait_h < 0 then
		self.wait_h = 24
	end
	self:UpdateTimer()
end

function PDAOverlay:IncHour()
	self.wait_h = self.wait_h + 1
	if self.wait_h > 24 then
		self.wait_h = 0
	end
	self:UpdateTimer()
end

function PDAOverlay:DecMinute()
	self.wait_m = self.wait_m - 5
	if self.wait_m < 0 then
		self.wait_m = 55
	end
	self:UpdateTimer()
end

function PDAOverlay:IncMinute()
	self.wait_m = self.wait_m + 5
	if self.wait_m > 55 then
		self.wait_m = 0
	end
	self:UpdateTimer()
end

function PDAOverlay:SkipTime()
	if self.wait_h == 0 and self.wait_m == 0 then
	return end
	
	skip_time(self.wait_h, self.wait_m)
	self:ClearTime()
	self:ShowSkipTimer()
end

function PDAOverlay:ClearTime()
	self.wait_h = 0
	self.wait_m = 0
	self:UpdateTimer()
end

function PDAOverlay:ShowSkipTimer()
	local is_shown = self.skip_time_frame:IsShown()
	self.skip_time_frame:Show(not is_shown)
end

function PDAOverlay:HidePda()
	if is_3d_pda() then
		actor:activate_slot(NO_ACTIVE_SLOT)
	else
		level.start_stop_menu(level.main_input_receiver(), true)
	end
end