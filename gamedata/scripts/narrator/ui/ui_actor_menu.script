-- -*- mode: lua; coding: windows-1251-dos -*-
local overlay = nil
local OVERLAY_XML = "script_overlays\\actor_menu_overlay.xml"

function attach(sm)
	sm:subscribe({signal = "on_spawn",   			fun = this.create_window})
	sm:subscribe({signal = "on_destroy",   			fun = this.destroy_window})	
end

local subscribed = false

function get_current_owner()
	if level.get_inventory_wnd():IsShown() then
		--log3("~get_inventory_wnd")
		return level.get_inventory_wnd()
	end
	if level.get_car_body_wnd():IsShown() then
		--log3("~get_car_body_wnd")
		return level.get_car_body_wnd()
	end
	return level.get_trade_wnd()
end

function create_window()
	if overlay then
		destroy_window()
	end
	overlay = ActorMenuOverlay()
end

function destroy_window()
	if overlay then
		overlay:DetachWnd()
		overlay = nil
	end
end

class "ActorMenuOverlay" (CUIScriptWnd)

function ActorMenuOverlay:__init() super()
	self:InitControls()
	self:Subscribe()
end

function ActorMenuOverlay:GetMode()
	if level.get_inventory_wnd():IsShown() then
		return "inventory"
	end
	if level.get_car_body_wnd():IsShown() then
		return "carbody"
	end
	return "trade"
end

function ActorMenuOverlay:GetTarget()
	if self:GetMode() == "inventory" then
		return nil 
	end
	if self:GetMode() == "carbody" then
		return level.get_car_body_target()
	end
	return level.get_second_talker()
end

function ActorMenuOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_inventory_show", self = self, fun = self.OnShow},
			{signal = "on_inventory_hide", self = self, fun = self.OnHide},
			{signal = "on_carbody_show", self = self, fun = self.OnShow},
			{signal = "on_carbody_hide", self = self, fun = self.OnHide},
			{signal = "on_trade_show", self = self, fun = self.OnShow},
			{signal = "on_trade_hide", self = self, fun = self.OnHide},			
		
			{signal = "on_cell_item_focus", self = self, fun = self.OnCellItemFocus},
			{signal = "on_cell_item_focus_lost", self = self, fun = self.OnCellItemFocusLost},
			{signal = "on_cell_item_select", self = self, fun = self.OnCellItemSelect},
			{signal = "on_cell_item_mouse", self = self, fun = self.OnCellItemMouse},
			{signal = "on_quick_item_set", self = self, fun = self.UpdateSlots},
			{signal = "on_quick_item_use", self = self, fun = self.UpdateSlots},
			{signal = "on_ruck", self = self, fun = self.UpdateSlots},
			{signal = "on_drop", self = self, fun = self.UpdateSlots},
			{signal = "on_use", self = self, fun = self.UpdateSlots},
			{signal = "on_loadout_update_count", self = self, fun = self.UpdateSlots},
			{signal = "on_loadout_update_max_count", self = self, fun = self.UpdateSlots},
			{signal = "on_actor_icon_update", self = self, fun = self.OnActorIconUpdate},
		}
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function ActorMenuOverlay:Unsubscribe()
	if self.subscribed then
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function ActorMenuOverlay:DetachWnd()
	quick_slots.set_selected(nil)
	self:Unsubscribe()
	self:ClearCallbacks()
end

function ActorMenuOverlay:InitControls()
	self.owner = nil
	
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)

	self.conditions_background = xml:InitStatic("conditions_background", self)
	
	local name
	
	--// actor condition progressbars
	self.conditions = {
		["health_"] 	= { condition = function() return actor.health end },
		["psy_"] 		= { condition = function() return actor.psy_health end },
		["power_"] 		= { condition = function() return actor.power end },
		["satiety_"] 	= { condition = function() return actor.satiety end },
		["alcohol_"] 	= { condition = function() return actor.alcohol end },
		["radiation_"] 	= { condition = function() return dosimeter.can_detect_radiation() and actor.radiation or 0 end },
		["somnolence_"] = { condition = function() return somnolence.get_val() end },
		["bleeding_"] 	= { condition = function() return actor:get_bleeding() end },
		["injure_"] 	= { condition = function() return body_health.get_injured_limb() end },
	}
	local prefix = "conditions_background:"
	for k, v in pairs(self.conditions) do
		v.static = xml:InitStatic(prefix..k.."static", self.conditions_background)
		v.icon = xml:InitStatic(prefix..k.."icon", v.static)
		if k ~= "bleeding_" and k ~= "injure_" then
			v.progress = xml:InitProgressBar(prefix..k.."progress", v.static)
		end	
		v.percent = xml:InitStatic(prefix.."condition_percent", v.static)
		v.percent:Show(false)

		self:Register(v.static, k)
		self:AddCallback(k, ui_events.STATIC_FOCUS_RECEIVED, function() self:ConditionOnFocusReceived(k) end)
		self:AddCallback(k, ui_events.STATIC_FOCUS_LOST, function() self:ConditionOnFocusLost(k) end)
	end
	
	name = "effects_info"
	self.effects_info = xml:InitStatic(name, self)
	self.effects_info.scroll_view = xml:InitScrollView(name..":scroll_view", self.effects_info)
	self.effects_info.effects = {
		{param = "health_restore_speed", 		name = "ui_inv_health_boost"},
		{param = "power_restore_speed", 		name = "ui_inv_power"},
		{param = "max_power_restore_speed", 	name = "ui_inv_max_power"},
		{param = "satiety_restore_speed", 		name = "ui_inv_satiety"},
		{param = "radiation_restore_speed", 	name = "ui_inv_radiation"},
		{param = "psy_health_restore_speed", 	name = "ui_inv_psy_health"},
		{param = "alcohol_restore_speed", 		name = "ui_inv_alcohol"},
		{param = "wounds_heal_speed", 			name = "ui_inv_wounds_heal"},
		--//
		{param = "additional_sprint", 			name = "ui_inv_sprint"},
		{param = "additional_jump", 			name = "ui_inv_jump"},
		{param = "additional_weight", 			name = "ui_inv_weight"},
		--//
		{param = "burn_immunity", 				name = "ui_inv_burn_protection"},
		{param = "shock_immunity", 				name = "ui_inv_shock_protection"},
		{param = "strike_immunity", 			name = "ui_inv_strike_protection"},
		{param = "wound_immunity", 				name = "ui_inv_wound_protection"},
		{param = "radiation_immunity", 			name = "ui_inv_radiation_protection"},
		{param = "telepatic_immunity", 			name = "ui_inv_telepatic_protection"},
		{param = "chemical_burn_immunity", 		name = "ui_inv_chemical_burn_protection"},
		{param = "explosion_immunity", 			name = "ui_inv_explosion_protection"},
		{param = "fire_wound_immunity", 		name = "ui_inv_fire_wound_protection"},
		--//
		{param = "boost_somnolence", 			name = "ui_inv_somnolence"},
		{param = "boost_pain", 					name = "ui_inv_painkiller"},
		{param = "power_loss", 					name = "st_power_loss"},	
	}
	for k,v in pairs (self.effects_info.effects) do
		v.static = CUIStatic()
		v.static:SetTextComplexMode(true)
		v.static:SetWidth(self.effects_info.scroll_view:GetDesiredChildWidth())
	end
	
	--// quick slots
	self.quick_slots = xml:InitStatic("quick_slots", self)
	
	--//quick item icon colors
	self.quick_color_has_item 	= GetARGB(255, 255, 255, 255)
	self.quick_color_no_item 	= GetARGB(120, 255, 255, 255)
	
	local pos_x = xml:ReadAttribFlt("quick_slots:slot", "x", 0)
	local pos_y = xml:ReadAttribFlt("quick_slots:slot", "y", 0)
	local horz = (xml:ReadAttribInt("quick_slots", "horz", 1) > 0) and true or false
	local indent = xml:ReadAttribFlt("quick_slots", "indent", 0)
	
	self.slots = {}
	for i=0,3 do
		local s = xml:InitStatic("quick_slots:slot", self.quick_slots)
		self.slots[i] = s
		s:SetText(game.translate_string("ui_quick_slot_"..i))
		s:SetWndPos(pos_x, pos_y)
		if horz then
			pos_x = pos_x + s:GetWidth() + indent
		else
			pos_y = pos_y + s:GetHeight() + indent
		end
		s.highlight = xml:InitStatic("quick_slots:slot:highlight", s)
		s.highlight:Show(false)
		s.icon = xml:InitStatic("quick_slots:slot:icon", s)
		s.count = xml:InitStatic("quick_slots:slot:count", s)
		name = "quick_"..i
		self:Register(s, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:QuickOnFocusReceived(i) end, self)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:QuickOnFocusLost(i) end, self)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DB_CLICK, function() self:QuickOnDbClick(i) end, self)
		
		self:DrawSlotIcon(i)
	end
	
	--//loadout
	--//loadout colors
	self.loadout_color_default 		= GetARGB(255, 255, 255, 255)
	self.loadout_color_highlight 	= GetARGB(255, 0, 255, 0)
	self.loadout_color_blocked 		= GetARGB(255, 255, 0, 0)
	self.loadout_color_equiped 		= GetARGB(255, 238, 153, 26)
	self.loadout_color_hidden 		= GetARGB(0, 255, 255, 255)
	
	self.loadout_back = xml:InitStatic("loadout_back", self)
	prefix = "loadout_back:"
	-- name = "loadout_back"
	-- self:Register(self.loadout_back, name)
	-- self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, self.LoadoutBackOnFocusReceived)
	-- self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, self.LoadoutBackOnFocusLost)
	
	self.clear_loadout = xml:Init3tButton(prefix.."clear_loadout_button", self.loadout_back)
	name = "clear_loadout"
	self:Register(self.clear_loadout, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.ClearLoadout, self)

	self.loadout = {
		["pistol_ammo"] 	= {},
		["rifle_ammo"] 		= {},
		["shotgun_ammo"] 	= {},
		["heavy_ammo"] 		= {},
		["grenade"]			= {},
		["medicine"] 		= {},
		["scope"] 			= {},
		["silencer"] 		= {},
	}
	for k,v in pairs(self.loadout) do
		--log3("~%s init loadout slot %s", script_name(), k)
		v.static = xml:InitStatic(prefix..k.."_static", self.loadout_back)
		v.static:SetTextColor(self.loadout_color_default)
		v.icon = xml:InitStatic(prefix..k.."_icon", v.static)
		--v.icon:SetColor(self.loadout_color_default)
		self:Register(v.static, k)
		self:AddCallback(k, ui_events.STATIC_FOCUS_RECEIVED, function() self:LoadoutSlotOnFocusReceived(k) end)
		self:AddCallback(k, ui_events.STATIC_FOCUS_LOST, function() self:LoadoutSlotOnFocusLost(k) end)		
	end
	self:UpdateSlots()
	
	--//show types buttons back
	self.show_buttons_back = xml:InitStatic("show_buttons_back", self)
	prefix = "show_buttons_back:"
	self.show_buttons = {
		[0] = {name = "all"},
		[1] = {name = "weapon"},
		[2] = {name = "ammo"},
		[3] = {name = "outfit"},
		[4] = {name = "eatable"},
		[5] = {name = "artefact"},
		[6] = {name = "device"},
		[7] = {name = "misc"},
	}
	for k,v in pairs(self.show_buttons) do
		v.button = xml:InitCheck(prefix.."show_"..v.name.."_button", self.show_buttons_back)
		v.accel = xml:ReadAttrib(prefix.."show_"..v.name.."_button", "accel", nil)
		if v.accel then
			v.button:SetAccelerator(keyname_to_dik(v.accel), 0)
		end
		v.hint = xml:ReadAttrib(prefix.."show_"..v.name.."_button", "hint", "")
		v.st = xml:InitStatic(prefix.."show_"..v.name.."_button:static", v.button)
		name = "show_"..v.name
		self:Register(v.button, name)
		self:AddCallback(name, ui_events.BUTTON_CLICKED, function() self:OnShowButtonClick(k) end, self)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnShowButtonFocusReceived(k) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnShowButtonFocusLost(k) end)	
	end
	
	--//floating tooltip
	self.tooltip_frame = xml:InitFrame("tooltip_frame", self)
	self.tooltip_frame:Show(false)
	self.tooltip = xml:InitStatic("tooltip_frame:tooltip", self.tooltip_frame)
	local tmp_tbl = split_string(xml:ReadAttrib("tooltip_frame", "offset", "0,0"), ",")
	self.tooltip_frame.offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.tooltip_frame_base_height = self.tooltip_frame:GetHeight()	
	
	--//character info
	self.char_info_back = xml:InitStatic("char_info_back", self)
	self.char_info_icon = xml:InitStatic("char_info_icon", self.char_info_back)
	self.char_info_icon_comm = xml:InitStatic("char_info_icon_comm", self.char_info_back)
	self.char_info_text = xml:InitStatic("char_info_text", self.char_info_back)
	self.char_info_text_header = xml:InitStatic("char_info_text_header", self.char_info_back)
	
	--//character info NPC or date/time/money in inventory mode
	self.char_info_back_npc = xml:InitStatic("char_info_back_npc", self)
	self.char_info_icon_npc = xml:InitStatic("char_info_icon_npc", self.char_info_back_npc)
	self.char_info_icon_comm_npc = xml:InitStatic("char_info_icon_comm_npc", self.char_info_back_npc)
	self.char_info_text_npc = xml:InitStatic("char_info_text_npc", self.char_info_back_npc)
	self.char_info_text_header_npc = xml:InitStatic("char_info_text_header_npc", self.char_info_back_npc)	
	
	--//weight static
	self.inv_weight = xml:InitStatic("weight_static", self)
	self:UpdateWeightText()

	--//date/time static
	self.time_static = xml:InitStatic("time_static", self)
	
	--//exit button
	self.exit_button = xml:Init3tButton("exit_button", self)
	name = "exit_button"
	self:Register(self.exit_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.Exit, self)	
	
	--//organize button
	self.organize_button = xml:Init3tButton("organize_button", self)
	name = "organize_button"
	self:Register(self.organize_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.Organize, self)
	
	--//carbody mode
	--//take all button
	self.take_all_button = xml:Init3tButton("take_all_btn", self)
	name = "take_all_button"
	self:Register(self.take_all_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.TakeAll, self)	
	--//move all ruck button
	self.move_all_ruck_button = xml:Init3tButton("move_all_ruck_btn", self)
	name = "move_all_ruck_button"
	self:Register(self.move_all_ruck_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.MoveAllRuck, self)	
	
	--//trade mode
	--//trade button
	self.trade_button = xml:Init3tButton("trade_button", self)
	name = "trade_button"
	self:Register(self.trade_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.PerformTrade, self)	
	--//to talk button
	self.to_talk_button = xml:Init3tButton("to_talk_button", self)
	name = "to_talk_button"
	self:Register(self.to_talk_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.SwitchToTalk, self)
end

function ActorMenuOverlay:QuickOnFocusReceived(slot_num)
	quick_slots.set_selected(slot_num)
	self.slots[slot_num].highlight:Show(true)--SetColor(self.quick_color_highlight)
	ogse_signals.get_mgr():call("on_quick_item_focus", quick_slots.get_item(slot_num))
end

function ActorMenuOverlay:QuickOnFocusLost(slot_num)
	quick_slots.set_selected(nil)
	self.slots[slot_num].highlight:Show(false)--SetColor(self.quick_color_default)
	ogse_signals.get_mgr():call("on_quick_item_focus_lost", quick_slots.get_item(slot_num))
end

function ActorMenuOverlay:OnCellItemFocus(obj)
	local highlight_quick_slots = read_if_exists(sys_ini, "r_bool", obj:section(), "quick_slot", false)
	if highlight_quick_slots then
		for i=0,3 do
			self.slots[i].highlight:Show(true)--.back:SetColor(self.quick_color_highlight)
		end
	end
	local slot_type = loadout.get_slot_type(obj)
	if slot_type then
		for k,v in pairs(self.loadout) do
			if slot_type == k then
				local color = self.loadout_color_blocked
				if loadout.can_remove(obj) then
					color = self.loadout_color_equiped
				end
				if loadout.can_add(obj) then
					color = self.loadout_color_highlight
				end
				v.static:SetTextColor(color)
				--v.icon:SetColor(color)
			end
		end
	end
end

function ActorMenuOverlay:OnCellItemFocusLost(obj)
	for i=0,3 do
		self.slots[i].highlight:Show(false)--.back:SetColor(self.quick_color_default)
	end
	for k,v in pairs(self.loadout) do
		v.static:SetTextColor(self.loadout_color_default)
		--v.icon:SetColor(self.loadout_color_default)
	end
end

function ActorMenuOverlay:OnCellItemSelect(obj)
end

function ActorMenuOverlay:OnCellItemMouse(obj, x, y, action)
	if action == ui_events.WINDOW_RBUTTON_DOWN then
		--log3("~RB clicked item %s", obj:section())
	end
end

function ActorMenuOverlay:DrawSlotIcon(slot_num)
	local s = self.slots[slot_num]
	local sect = quick_slots.get_item_sect(slot_num)
	local show_icon = sect ~= ""
	s.icon:Show(show_icon)
	if show_icon then
		CIconParams(sect):set_shader(s.icon)
	end	
	
	local count = quick_slots.get_item_count(slot_num)
	local count_text = string.format("x%s", count)
	s.count:SetText(count_text)
	s.count:Show(count > 0)
			
	if count > 0 then
		s.icon:SetColor(self.quick_color_has_item)
	else
		s.icon:SetColor(self.quick_color_no_item)
	end
end

function ActorMenuOverlay:QuickOnDbClick(slot_num)
	quick_slots.set_item("", slot_num)
	self:UpdateSlots()
end

function ActorMenuOverlay:UpdateSlots()
	for i=0,3 do
		self:DrawSlotIcon(i)
	end
	
	local loadout_slot_text
	for k,v in pairs(self.loadout) do
		loadout_slot_text = string.format("[%s/%s]", loadout.get_current(k), loadout.get_max(k))
		v.static:SetText(loadout_slot_text)
	end
end

function ActorMenuOverlay:CheckNeedUpdate(obj, prev_place)
	local item_allowed = read_if_exists(sys_ini, "r_bool", obj:section(), "quick_slot", false)
	if not item_allowed then
		return
	end
	self:UpdateSlots()
end

function ActorMenuOverlay:ConditionOnFocusReceived(cond_name)
	self.conditions[cond_name].percent:Show(true)
	if cond_name ~= "bleeding_" and cond_name ~= "injure_" then
		self.conditions[cond_name].icon:SetColor(self.loadout_color_equiped)
	end
	local cond_descr = game.translate_string(string.format("%s%s%s","st_", cond_name, "hint"))
	if cond_name == "injure_" then
		cond_descr = game.translate_string(string.format("%s%s%s%s","st_", cond_name, self.conditions[cond_name].condition(), "_hint"))
	end
	local cond_text = game.translate_string(string.format("%s%s%s","st_", cond_name, "hint_text"))
	if cond_name == "injure_" then
		local pain_eff = body_health.get_pain_effect()
		local pain = pain_eff == 0 and "" or pain_eff > 0 and "_more_pain" or "_less_pain"
		cond_text = game.translate_string(string.format("%s%s%s%s%s","st_", cond_name, self.conditions[cond_name].condition(), pain, "_hint_text"))
		--log3("~hint string: %s", cond_text)
	end
	local tip_text = string.format("%s\\n---------------------------------\\n%s", cond_descr, cond_text)	
	self:SetTooltip(tip_text)
end

function ActorMenuOverlay:ConditionOnFocusLost(cond_name)
	self.conditions[cond_name].percent:Show(false)
	if cond_name ~= "bleeding_" and cond_name ~= "injure_" then
		self.conditions[cond_name].icon:SetColor(self.loadout_color_default)
	end
	self:SetTooltip(nil)
end

function ActorMenuOverlay:LoadoutSlotOnFocusReceived(slot_name)
	self.loadout[slot_name].static:SetTextColor(self.loadout_color_equiped)
	local type_descr = game.translate_string(slot_name)
	local type_text = game.translate_string(string.format("%s%s%s","st_", slot_name, "_hint_text"))	
	local tip_text = string.format("%s\\n---------------------------------\\n%s", type_descr, type_text)	
	self:SetTooltip(tip_text)
end

function ActorMenuOverlay:LoadoutSlotOnFocusLost(slot_name)
	self.loadout[slot_name].static:SetTextColor(self.loadout_color_default)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:SetTooltip(text)
	self.tooltip_frame:Show(not not text)
	self.tooltip_frame:SetHeight(self.tooltip_frame_base_height)
	self.tooltip:SetHeight(0)
	if text then
		self.tooltip:SetText(text)
		self.tooltip:AdjustHeightToText()
		self:BringToTop(self.tooltip_frame)
		if self.tooltip:GetHeight() > self.tooltip_frame_base_height - 10 then
			self.tooltip_frame:SetHeight(self.tooltip:GetHeight() + 15)
		end
	end
end

function ActorMenuOverlay:UpdateTooltip()
	if not self.tooltip_frame:IsShown() then
	return end
	
	local pos = vector2():set(self.owner:GetMousePosX(), self.owner:GetMousePosY())
	pos.x = pos.x + self.tooltip_frame.offset.x
	pos.y = pos.y + self.tooltip_frame.offset.y
	local wnd_size = {x = self.tooltip_frame:GetWidth(), y = self.tooltip_frame:GetHeight()}
	local delta = {x = pos.x + wnd_size.x - UI_BASE_WIDTH, y = pos.y + wnd_size.y - UI_BASE_HEIGHT}
    if delta.x > 0 then
        pos.x = pos.x - delta.x
	end		
    if delta.y > 0 then
        pos.y = pos.y - delta.y
	end		
	self.tooltip_frame:SetWndPos(pos.x, pos.y)	
end

local account_slots = {
	[OUTFIT_SLOT] = true,
	[HELMET_SLOT] = true,
	[BACKPACK_SLOT] = true,
}
function ActorMenuOverlay:UpdateEffectsInfo()
	self.effects_info:Show(self:GetMode() == "inventory")
	if not self.effects_info:IsShown() then
	return end
	
	self.effects_info.scroll_view:Clear()
	
	local text = ""
	local sn, sn_boost
	local sn_time = game.translate_string("st_time_minute")
	local actor_obj = get_actor_obj()
	local conds = actor.conditions
	
	local outfit, helmet, backpack = actor_get_outfit(), actor_get_helmet(), actor_get_backpack()
	
	for _i=1, table.size(self.effects_info.effects) do
		local val, val_boost, boost_time = 0, 0, 0
		
		local i = _i-1
		
		local t = self.effects_info.effects[_i]
		
		if i > 19 then
			if t.param == "boost_somnolence" or t.param == "boost_pain" then
				for b_sect,b_time in pairs(boosters.get_all()) do
					val_boost = read_if_exists(sys_ini, "r_float", b_sect, t.param, 0)
					if val_boost ~= 0 then
						boost_time = b_time
					end
				end
			else
				local item
				for i,_ in pairs(account_slots) do
					item = actor:item_in_slot(i)
					if item then
						val = val + item:get_inventory_item().power_loss
					end
				end				
			end	
		else
		
			val_boost = conds:get_boosted_params(i)
			boost_time = conds:get_boosted_time(i)
			
			if i < 11 then 				--//effects
				if i < 8 then			--//additional_sprint
					val = val + actor_obj:get_items_effect(i)
				else
					val = val + actor_obj:get_artefacts_effect(i)
					if outfit then
						val = val + outfit:get_inventory_item():item_effect(i)
					end
					if helmet then
						val = val + helmet:get_inventory_item():item_effect(i)
					end
					if backpack then
						val = val + backpack:get_inventory_item():item_effect(i)
					end				
				end
			else 						--//protection
				local ii = i - 11
				val = val + actor_obj:get_artefacts_protection(ii)
				if outfit then
					val = val +outfit:get_inventory_item():hit_type_protection(ii)
				end
				if helmet then
					val = val +helmet:get_inventory_item():hit_type_protection(ii)
				end			
			end
		
		end
				
		if not math.fsimilar(val, 0) or not math.fsimilar(val_boost, 0) then
		
			if t.param ~= "radiation_restore_speed" then
				val = val * 100
				val_boost = val_boost * 100
				sn = "%"
				sn_boost = "%"
			else
				sn = game.translate_string("st_rad")
				sn_boost = game.translate_string("st_rad")
			end
		
			local color = val > 0 and "%c[green]" or "%c[red]"
			local color_boost = val_boost > 0 and "%c[green]" or "%c[red]"
		
			if t.param == "radiation_restore_speed" or t.param == "alcohol_restore_speed" or t.param == "boost_somnolence" or t.param == "boost_pain" or t.param == "power_loss" then
				color = val > 0 and "%c[red]" or "%c[green]"
				color_boost = val_boost > 0 and "%c[red]" or "%c[green]"
			end
		
			local name = game.translate_string(t.name)
		
			if val ~= 0 and val_boost ~= 0 then
				text = string.format("%s %s%+.f%s %s%+.f%s [%.f %s]", name, color, val, sn, color_boost, val_boost, sn_boost, boost_time, sn_time)
			elseif val ~= 0 then
				text = string.format("%s %s%+.f%s", name, color, val, sn)
			elseif val_boost ~= 0 then
				text = string.format("%s %s%+.f%s [%.f %s]", name, color_boost, val_boost, sn_boost, boost_time, sn_time)
			end
		
			t.static:SetText(text)
			t.static:AdjustHeightToText()
			self.effects_info.scroll_view:AddWindow(t.static)
		end
	end
end

function ActorMenuOverlay:Update()
	CUIScriptWnd.Update(self)
	
	local val
	for k,v in pairs(self.conditions) do
		val = k ~= "injure_" and math.clamp(v.condition(), 0, 1) or v.condition()
		if k ~= "bleeding_" and k ~= "injure_" then
			v.progress:SetProgressPos(val)
		else
			if k == "injure_" then
				v.static:Show(val ~= "none")
				if v.static:IsShown() then
					local actual_icon = "ui_hud_trauma_"..val
					if self.limbs_injure_icon ~= actual_icon then
						v.static:InitTexture(actual_icon)
						self.limbs_injure_icon = actual_icon
					end
					color = GetARGB(100, 238, 153, 26)
					local pain_eff = body_health.get_pain_effect()
					if pain_eff > 0 then
						color = GetARGB(100, 255, 0, 0)
					elseif pain_eff < 0 then
						color = GetARGB(100, 0, 255, 0)
					end
					v.static:SetColor(color)					
				end
			else
				v.static:Show(val>0)
				if val>0 then
					v.static:SetColor(GetARGB(255,val*255,(1-val)*255,0))
				else
					if self.conditions[k].percent:IsShown() then
						self.conditions[k].percent:Show(false)
					end
				end
			end
		end
		if k ~= "injure_" then
			v.percent:SetText(string.format("%.0f%s", val*100, "%"))
		end
	end
	
	self:UpdateEffectsInfo()
	self:UpdateWeightText()
	self:UpdateDateTimeText()
	self:UpdateTooltip()
end

function ActorMenuOverlay:ClearLoadout()
	loadout.clear_all()
end

function ActorMenuOverlay:OnShow()
	self.owner = get_current_owner()
	self.owner:AttachChild(self)
	self:Show(true)
	
	self.target = self:GetTarget()
	self.take_all_button:Show(self:GetMode() == "carbody")
	self.move_all_ruck_button:Show(self:GetMode() == "carbody")	
	self.trade_button:Show(self:GetMode() == "trade")
	self.to_talk_button:Show(self:GetMode() == "trade")	
	self:OnShowButtonClick(0)
	self:OnActorIconUpdate()
	self:OnNPCIconUpdate()
	self:SetCharacterText()	
	self:SetCharacterTextNPC()
end

function ActorMenuOverlay:OnHide()
	self:OnShowButtonClick(0)
	inventory.set_item_visibility(actor, 0)
	inventory.set_item_visibility(self.target, 0)
	self.target = nil
	
	self:Show(false)
	if self.owner then
		self.owner:DetachChild(self)
	end
	self.owner = nil
end

function ActorMenuOverlay:Exit()
	level.start_stop_menu(level.main_input_receiver(), true)
end

--//switching of item visibility functions
function ActorMenuOverlay:OnShowButtonClick(show_type)
	inventory.set_item_visibility(actor, show_type)
	inventory.set_item_visibility(self.target, show_type)	
	for k,v in pairs(self.show_buttons) do
		v.button:SetCheck(k == show_type)
	end
	update_inventory_window()
end

function ActorMenuOverlay:OnShowButtonFocusReceived(show_type)
	self:SetTooltip(game.translate_string(self.show_buttons[show_type].hint))
end

function ActorMenuOverlay:OnShowButtonFocusLost(show_type)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:OnActorIconUpdate(icon)
	if not icon then
		icon = actor:get_character_icon()
	end
	self.char_info_icon:InitTexture(icon)
	self.char_info_icon_comm:InitTexture(community.get_icon_sect(actor:character_community()))
end

function ActorMenuOverlay:OnNPCIconUpdate()
	local show = self.target and not self.target:get_inventory_box()
	
	self.char_info_icon_npc:Show(show)
	self.char_info_icon_comm_npc:Show(show)
	
	if not show then return end
	
	local npc_icon = self.target:get_character_icon()
	local icon = npc_icon and npc_icon or read_if_exists(sys_ini, "r_string", self.target:section(), "icon", nil)
	self.char_info_icon_npc:Show(icon)
	if not icon then
	return end
	self.char_info_icon_npc:InitTexture(icon)
	self.char_info_icon_comm_npc:InitTexture(community.get_icon_sect(self.target:character_community()))
end

function ActorMenuOverlay:SetCharacterText()
	local name_header = game.translate_string("ui_st_name")
	local name = game.translate_string(actor:character_name())
	
	local comm_header = game.translate_string("ui_st_community")
	local comm = game.translate_string(actor:character_community())
	
	local rank_header = game.translate_string("ui_st_rank")
	local rank = game.translate_string(ranks.get_obj_rank_name(actor))
	
	local rept_header = game.translate_string("ui_st_reputation")
	local rept_color = game.translate_string(reputation.get_obj_reputation_color(actor))
	local rept = game.translate_string(reputation.get_obj_reputation_name(actor))
	
	local money_header = game.translate_string("ui_inv_money")
	local money = actor:money()
	local money_unit = game.translate_string("ui_st_money_regional")
	
	local char_text_header = string.format("%s:\\n%s:\\n%s:\\n%s:\\n%s:", 
									name_header,
									comm_header,
									rank_header,
									rept_header,
									money_header)
	
	local char_text = string.format("%s\\n%s\\n%s\\n%s%s\\n%s%s %s", 
									name,
									comm,
									rank,
									rept_color,rept,
									"%c[default]",money, money_unit)
									
	self.char_info_text_header:SetText(char_text_header)
	self.char_info_text:SetText(char_text)
end

function ActorMenuOverlay:SetCharacterTextNPC()
	local show = self.target and not self.target:get_inventory_box()
	
	self.char_info_text_header_npc:Show(show)
	self.char_info_text_npc:Show(show)
	
	if not show then return end
	
	local name_header = game.translate_string("ui_st_name")
	local name = game.translate_string(self.target:character_name())
	
	local comm_header = game.translate_string("ui_st_community")
	local comm = game.translate_string(self.target:character_community())
	
	local rank_header = game.translate_string("ui_st_rank")
	local rank = game.translate_string(self.target:is_trader() and "experienced" or ranks.get_obj_rank_name(self.target))
	
	local rel_header = game.translate_string("ui_st_relation")
	local rel_color = color_by_relation[self.target:relation(actor)]
	local rel = game.translate_string(name_by_relation[self.target:relation(actor)])
	
	local money_header = game.translate_string("ui_inv_money")
	local money = (self.target:infinitive_money() or not self.target:alive()) and "---" or self.target:money()
	local money_unit = game.translate_string("ui_st_money_regional")
	
	local char_text_header = string.format("%s:\\n%s:\\n%s:\\n%s:\\n%s:", 
									name_header,
									comm_header,
									rank_header,
									rel_header,
									money_header)
	
	local char_text = string.format("%s\\n%s\\n%s\\n%s%s\\n%s%s %s", 
									name,
									comm,
									rank,
									rel_color,rel,
									"%c[default]",money, money_unit)
									
	self.char_info_text_header_npc:SetText(char_text_header)
	self.char_info_text_npc:SetText(char_text)
end

function ActorMenuOverlay:UpdateWeightText()
	local inv = actor.inventory
	local weight = actor:get_inventory_weight()
	local max_weight = actor:get_max_weight()
	
	local weight_color = weight < max_weight and "%c[UI_orange]" or "%c[red]"
	local weight_unit = game.translate_string("st_kg")
	
	local weight_text = string.format("%s%.1f/%.1f %s", 
									weight_color,
									weight,
									max_weight,
									weight_unit)
									
	self.inv_weight:SetText(weight_text)
end

function ActorMenuOverlay:PerformTrade()
	actor:perform_trade()
	self:UpdateCharInfos()
end

function ActorMenuOverlay:SwitchToTalk()
	actor:switch_to_talk()
end

function ActorMenuOverlay:UpdateCharInfos()
	self:SetCharacterText()
	self:SetCharacterTextNPC()		
end

function ActorMenuOverlay:UpdateDateTimeText()
	local _time = game.get_game_time()
	local date = _time:dateToString(game.CTime.DateToDay)
	local time = _time:timeToString(game.CTime.TimeToMinutes)
	local time_text = string.format("%s %s", date, time)
	self.time_static:SetText(time_text)
end

function ActorMenuOverlay:Organize()
	update_inventory_window()
end

function ActorMenuOverlay:TakeAll()
	inventory.take_all(self.target)
end
function ActorMenuOverlay:MoveAllRuck()
	inventory.move_all_ruck(self.target)
end