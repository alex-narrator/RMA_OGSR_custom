-- -*- mode: lua; coding: windows-1251-dos -*-

--DESCRIBED WINDOW MODES:
--"inventory"
--"carbody"
--"trade"
--"repair"

_G.actor_menu = nil
local OVERLAY_XML = "script_overlays\\actor_menu_overlay.xml"

function attach(sm)
	sm:subscribe({signal = "on_spawn",   			fun = this.create_window})
	sm:subscribe({signal = "on_destroy",   			fun = this.destroy_window})
	sm:subscribe({signal = "on_update",   			fun = this.on_update})
	sm:subscribe({signal = "on_take",   			fun = this.on_take})
end

local subscribed = false
local new_items = {}

function create_window()
	if actor_menu then
		destroy_window()
	end
	_G.actor_menu = ActorMenuOverlay()
end

function destroy_window()
	if actor_menu then
		actor_menu:DetachWnd()
		_G.actor_menu = nil
	end
end

function on_update()
	if actor_menu.was_shown and not actor_menu:IsShown() then
		actor_menu.was_shown = false
		local mode = actor_menu:GetMode()
		if mode == "trade" or mode == "repair" then
			level.get_talk_wnd():Show(true)
			level.add_call(
				function()
					return level.get_talk_wnd():IsShown()
				end,
				function()
					level.start_stop_menu(level.main_input_receiver(), true)
				end
			)
		end
		actor_menu:OnHide()
	end
end

function on_take(item)
	if not actor_menu or actor_menu:IsShown() or xr_conditions.black_screen() then
	return end
	new_items[item:id()] = true
end

function get_menu()
	return actor_menu
end

function ShowHideMenu(mode, target)
	level.start_stop_menu(actor_menu, true)
	actor_menu.was_shown = actor_menu:IsShown()
	if actor_menu.was_shown then
		actor_menu:SetMode(mode)
		actor_menu:SetTarget(target)
		actor_menu:OnShow()
	else
		actor_menu:OnHide()
	end
end

class "ActorMenuOverlay" (CUIScriptWnd)

function ActorMenuOverlay:__init() super()
	self.sm = ogse_signals.get_mgr()
	self:InitControls()
	--self:Subscribe()
end

function ActorMenuOverlay:GetMode()
	return self.mode
end

function ActorMenuOverlay:SetMode(mode)
	self.mode = mode
end

function ActorMenuOverlay:GetTarget()
	return self.target
end

function ActorMenuOverlay:SetTarget(target)
	self.target = target
end

function ActorMenuOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_cell_item_focus", self = self, fun = self.OnCellItemFocus},
			{signal = "on_cell_item_focus_lost", self = self, fun = self.OnCellItemFocusLost},
			{signal = "on_cell_item_select", self = self, fun = self.OnCellItemSelect},
			{signal = "on_cell_item_start_drag", self = self, fun = self.OnCellItemStartDrag},
			
			{signal = "on_cell_item_rb_click", self = self, fun = self.OnCellItemRBClick},
			{signal = "on_cell_item_db_click", self = self, fun = self.OnCellItemDBClick},
			
			{signal = "on_cell_item_container_focus", self = self, fun = self.OnContainerFocus},
			{signal = "on_cell_item_container_focus_lost", self = self, fun = self.OnContainerFocusLost},
			
			{signal = "on_drag_item_drop", self = self, fun = self.OnDragItemDrop},
			
			{signal = "on_quick_item_set", self = self, fun = self.UpdateSlots},
			{signal = "on_quick_item_use", self = self, fun = self.UpdateSlots},
			{signal = "on_loadout_update_count", self = self, fun = self.UpdateSlots},
			{signal = "on_loadout_update_max_count", self = self, fun = self.UpdateSlots},
			{signal = "on_actor_icon_update", self = self, fun = self.OnActorIconUpdate},
			
			{signal = "on_ruck", self = self, fun = self.OnRuck},
			{signal = "on_drop", self = self, fun = self.OnDrop},
			{signal = "on_slot", self = self, fun = self.OnSlot},
			{signal = "on_belt", self = self, fun = self.OnBelt},
			{signal = "on_use", self = self, fun = self.OnUse},
			{signal = "on_place_item_to_box", self = self, fun = self.OnItemToPartner},
			
			{signal = "on_ruck_npc", self = self, fun = self.OnItemToPartner},
			{signal = "on_slot_npc", self = self, fun = self.OnItemToPartner},
			{signal = "on_ruck_trader", self = self, fun = self.OnItemToPartner},
			
			{signal = "on_drop_npc", self = self, fun = self.OnItemFromPartner},
			{signal = "on_take_from_box", self = self, fun = self.OnItemFromPartner},			
			
			{signal = "on_loadout_update_count", self = self, fun = self.OnMoveLoadout},
			
			{signal = "on_max_belt_set", self = self, fun = self.OnMaxBeltSet},
			
			{signal = "on_warning_icon_focus", self = self, fun = self.OnWarningIconFocus},
			{signal = "on_warning_icon_focus_lost", self = self, fun = self.OnWarningIconFocusLost},
			
			{signal = "on_use_animation_start", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_use_animation_stop", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_attach_addon_start", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_attach_addon_stop", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_detach_addon_start", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_detach_addon_stop", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_loot_box_unpack_start", self = self, fun = self.SetUseAnimProgres},
			{signal = "on_loot_box_unpack_stop", self = self, fun = self.SetUseAnimProgres},
			
			{signal = "on_hud_state_switch", self = self, fun = self.OnHudStateSwitch},
		}
		for _, s in ipairs( self.subscribed ) do
			self.sm:subscribe( s )
		end
	end
end

function ActorMenuOverlay:Unsubscribe()
	if self.subscribed then
		for _, s in ipairs( self.subscribed ) do
			self.sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function ActorMenuOverlay:DetachWnd()
	quick_slots.set_selected(nil)
	--self:Unsubscribe()
	self:ClearCallbacks()
end

function ActorMenuOverlay:InitControls()
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	
	self.service_back = CUIStatic()
	self.service_back:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	self:AttachChild(self.service_back)
	
	local name = "service_back"
	self:Register(self.service_back, name)
	self:AddCallback(name, ui_events.WINDOW_LBUTTON_UP, function() self:ServiceOnLButtonUp() end, self)
	
	self.key_accels = {}
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	xml:InitAutoStaticGroup("w:auto_static", self)
	
	-- dragdrops
	--//actor ruck and belt
	self.ruck_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_ruck", self)
	self.ruck_list:SetID("ruck_list")
	self.belt_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_belt", self)
	self.belt_list:SetID("belt_list")
	--//loadout
	self.loadout_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_loadout", self)
	self.loadout_list:SetID("loadout_list")	
	--//actor slots
	local inv = actor.inventory
	self.slot_list = {}
	for i = 0, sys_ini:r_u32("inventory","slots") - 1 do
		self.slot_list[i] = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_slot_"..i, self)
		self.slot_list[i]:SetID("slot_"..i)
	end
	--//carbody/trade_partner
	self.target_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_target", self)
	self.target_list:SetID("target_list")
	--//buy/sell
	self.sell_buy_back = xml:InitStatic("sell_buy_back", self)
	--//background
	self.buy_list_back = xml:InitStatic("buy_back", self.sell_buy_back)
	self.sell_list_back = xml:InitStatic("sell_back", self.sell_buy_back)
	--//list
	self.buy_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_buy", self.sell_buy_back)
	self.buy_list:SetID("buy_list")
	self.sell_list = ui_cell_item_container.UICellItemContainer(xml, "dragdrop_sell", self.sell_buy_back)
	self.sell_list:SetID("sell_list")
	--//costs
	self.buy_cost = xml:InitStatic("buy_cost", self.sell_buy_back)
	self.buy_cost.base_color = self.buy_cost:GetTextColor()
	self.sell_cost = xml:InitStatic("sell_cost", self.sell_buy_back)
	self.sell_cost.base_color = self.sell_cost:GetTextColor()

	self.properties_box = ui_properties_box.UIPropertiesBox(self)

	self.conditions_background = xml:InitStatic("conditions_background", self)
	
	--// actor condition progressbars
	local actor_cond = actor_obj.condition
	self.conditions = {
		["health_"] 	= { 
			condition = function() return actor.health end,
			restore_speed = function() return 3600 * actor_cond.health_restore_v end,
		},
		["psy_health_"] = { 
			condition = function() return actor.psy_health end,
			restore_speed = function() return 3600 * actor_cond.psy_health_v end,
		},
		["power_"] 		= { 
			condition = function() return actor.power end,
			restore_speed = function() return 3600 * actor_cond.power_v end,
		},
		["satiety_"] 	= { 
			condition = function() return actor.satiety end,
			restore_speed = function() return 3600 * -actor_cond.satiety_v end,
		},
		["alcohol_"] 	= { 
			condition = function() return actor.alcohol end,
			restore_speed = function() return 3600 * actor_cond.alcohol_v end,
		},
		["radiation_"] 	= { 
			condition = function() return dosimeter.can_detect_radiation() and actor.radiation or 0 end,
			restore_speed = function() return 3600 * actor_cond.radiation_v end,
		},
		["somnolence_"] = { 
			condition = function() return somnolence.get_val() end,
			restore_speed = function() return 3600 * somnolence.get_v() end,
		},
	}
	local prefix = "conditions_background:"
	for k, v in pairs(self.conditions) do
		v.static = xml:InitStatic(prefix..k.."static", self.conditions_background)
		v.icon = xml:InitStatic(prefix..k.."icon", v.static)
		v.progress = xml:InitProgressBar(prefix..k.."progress", v.static)
		v.percent = xml:InitStatic(prefix.."condition_percent", v.static)
		v.percent:Show(false)

		self:Register(v.static, k)
		self:AddCallback(k, ui_events.STATIC_FOCUS_RECEIVED, function() self:ConditionOnFocusReceived(k) end)
		self:AddCallback(k, ui_events.STATIC_FOCUS_LOST, function() self:ConditionOnFocusLost(k) end)
	end
	
	--//warning icons
	self.warning_icons = ui_warning_icons.WarningIcons(xml, self.conditions_background)	
	
	name = "effects_info"
	self.effects_info = xml:InitStatic(name, self)
	self.effects_info.scroll_view = xml:InitScrollView(name..":scroll_view", self.effects_info)
	self.effects_info.effects = {
		{param = "health_restore_speed", 		name = "ui_inv_health_boost"},
		{param = "power_restore_speed", 		name = "ui_inv_power"},
		{param = "max_power_restore_speed", 	name = "ui_inv_max_power"},
		{param = "satiety_restore_speed", 		name = "ui_inv_satiety"},
		{param = "radiation_restore_speed", 	name = "ui_inv_radiation"},
		{param = "psy_health_restore_speed", 	name = "ui_inv_psy_health"},
		{param = "alcohol_restore_speed", 		name = "ui_inv_alcohol"},
		{param = "wounds_heal_speed", 			name = "ui_inv_wounds_heal"},
		--//
		{param = "additional_sprint", 			name = "ui_inv_sprint"},
		{param = "additional_jump", 			name = "ui_inv_jump"},
		{param = "additional_weight", 			name = "ui_inv_weight"},
		--//
		{param = "burn_immunity", 				name = "ui_inv_burn_protection"},
		{param = "shock_immunity", 				name = "ui_inv_shock_protection"},
		{param = "strike_immunity", 			name = "ui_inv_strike_protection"},
		{param = "wound_immunity", 				name = "ui_inv_wound_protection"},
		{param = "radiation_immunity", 			name = "ui_inv_radiation_protection"},
		{param = "telepatic_immunity", 			name = "ui_inv_telepatic_protection"},
		{param = "chemical_burn_immunity", 		name = "ui_inv_chemical_burn_protection"},
		{param = "explosion_immunity", 			name = "ui_inv_explosion_protection"},
		{param = "fire_wound_immunity", 		name = "ui_inv_fire_wound_protection"},
		--//
		{param = "boost_somnolence", 			name = "ui_inv_somnolence"},
		{param = "boost_pain", 					name = "ui_inv_painkiller"},
		{param = "power_loss", 					name = "st_power_loss"},	
	}
	for k,v in pairs (self.effects_info.effects) do
		v.static = xml:InitStatic(name..":static_item", self.effects_info.scroll_view)
		v.static:SetAutoDelete(false)
	end
	
	--// quick slots
	self.quick_slots = xml:InitStatic("quick_slots", self)
	
	--//quick item icon colors
	self.quick_color_has_item 	= GetARGB(255, 255, 255, 255)
	self.quick_color_no_item 	= GetARGB(120, 255, 255, 255)
	
	local pos_x = xml:ReadAttribFlt("quick_slots:slot", "x", 0)
	local pos_y = xml:ReadAttribFlt("quick_slots:slot", "y", 0)
	local horz = (xml:ReadAttribInt("quick_slots", "horz", 1) > 0) and true or false
	local indent = xml:ReadAttribFlt("quick_slots", "indent", 0)
	
	self.slots = {}
	for i=0,3 do
		local s = xml:InitStatic("quick_slots:slot", self.quick_slots)
		self.slots[i] = s
		s:SetText(game.translate_string("ui_quick_slot_"..i))
		s:SetWndPos(pos_x, pos_y)
		if horz then
			pos_x = pos_x + s:GetWidth() + indent
		else
			pos_y = pos_y + s:GetHeight() + indent
		end
		s.highlight = xml:InitStatic("quick_slots:slot:highlight", s)
		s.highlight:Show(false)
		s.highlight:SetLightAnim("ui_slow_blinking", true, true, false, true)
		s.icon = xml:InitStatic("quick_slots:slot:icon", s)
		s.icon.image = CUIStatic()
		s.icon.image:SetStretchTexture(true)
		s.icon:AttachChild(s.icon.image)
		s.count = xml:InitStatic("quick_slots:slot:count", s)
		name = "quick_"..i
		self:Register(s, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:QuickOnFocusReceived(i) end, self)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:QuickOnFocusLost(i) end, self)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DB_CLICK, function() self:QuickOnDbClick(i) end, self)
		
		self:DrawSlotIcon(i)
	end
	
	--//loadout
	--//loadout colors
	self.loadout_color_default 		= GetARGB(255, 255, 255, 255)
	self.loadout_color_highlight 	= GetARGB(255, 0, 255, 0)
	self.loadout_color_blocked 		= GetARGB(255, 255, 0, 0)
	self.loadout_color_equiped 		= GetARGB(255, 238, 153, 26)
	self.loadout_color_hidden 		= GetARGB(0, 255, 255, 255)
	
	self.loadout_back = xml:InitStatic("loadout_back", self)
	prefix = "loadout_back:"
	-- name = "loadout_back"
	-- self:Register(self.loadout_back, name)
	-- self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, self.LoadoutBackOnFocusReceived)
	-- self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, self.LoadoutBackOnFocusLost)
	
	-- self.clear_loadout = xml:Init3tButton(prefix.."clear_loadout_button", self.loadout_back)
	-- name = "clear_loadout"
	-- self:Register(self.clear_loadout, name)
	-- self:AddCallback(name, ui_events.BUTTON_CLICKED, self.ClearLoadout, self)

	self.loadout = loadout.slots_table()
	for k,v in pairs(self.loadout) do
		--log3("~%s init loadout slot %s", script_name(), k)
		v.static = xml:InitStatic(prefix..k.."_static", self.loadout_back)
		v.static:SetTextColor(self.loadout_color_default)
		v.icon = xml:InitStatic(prefix..k.."_icon", v.static)
		--v.icon:SetColor(self.loadout_color_default)
		self:Register(v.static, k)
		self:AddCallback(k, ui_events.STATIC_FOCUS_RECEIVED, function() self:LoadoutSlotOnFocusReceived(k) end)
		self:AddCallback(k, ui_events.STATIC_FOCUS_LOST, function() self:LoadoutSlotOnFocusLost(k) end)		
	end
	self:UpdateSlots()
	
	--//show types buttons back
	self.show_buttons_back = xml:InitStatic("show_buttons_back", self)
	prefix = "show_buttons_back:"
	self.show_buttons = {
		[0] = {name = "all"},
		[1] = {name = "weapon"},
		[2] = {name = "ammo"},
		[3] = {name = "outfit"},
		[4] = {name = "eatable"},
		[5] = {name = "artefact"},
		[6] = {name = "device"},
		[7] = {name = "misc"},
	}
	for k,v in pairs(self.show_buttons) do
		v.button = xml:InitCheck(prefix.."show_"..v.name.."_button", self.show_buttons_back)
		v.accel = xml:ReadAttrib(prefix.."show_"..v.name.."_button", "accel", nil)
		if v.accel then
			v.button:SetAccelerator(keyname_to_dik(v.accel), 0)
			self.key_accels[v.button:GetAccelerator(0)] = true
		end
		--v.hint = xml:ReadAttrib(prefix.."show_"..v.name.."_button", "hint", "")
		v.st = xml:InitStatic(prefix.."show_"..v.name.."_button:static", v.button)
		name = "show_"..v.name
		self:Register(v.button, name)
		self:AddCallback(name, ui_events.BUTTON_CLICKED, function() self:OnShowButtonClick(k) end, self)
		--self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnShowButtonFocusReceived(k) end)
		--self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnShowButtonFocusLost(k) end)	
	end
	
	--//floating tooltip
	self.tooltip_frame = xml:InitFrame("tooltip_frame", self)
	self.tooltip_frame:Show(false)
	self.tooltip = xml:InitStatic("tooltip_frame:tooltip", self.tooltip_frame)
	local tmp_tbl = split_string(xml:ReadAttrib("tooltip_frame", "offset", "0,0"), ",")
	self.tooltip_frame.offset = {x = tmp_tbl[1], y = tmp_tbl[2]}
	self.tooltip_frame_base_height = self.tooltip_frame:GetHeight()
	
	--//use anim progress
	self.use_anim = xml:InitStatic("use_anim", self)
	self.use_anim.progress = xml:InitProgressShape("use_anim:progress", self.use_anim)
	self.use_anim.offset = split_string(xml:ReadAttrib("use_anim", "offset", "0,0"), ",", true)
	self.use_anim:Show(false)
	
	--//character info
	self.char_info_back = xml:InitStatic("char_info_back", self)
	self.char_info_icon = xml:InitStatic("char_info_icon", self.char_info_back)
	self.char_info_icon_comm = xml:InitStatic("char_info_icon_comm", self.char_info_back)
	name = "char_info_icon_comm"
	self:Register(self.char_info_icon_comm, name)
	self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnCommIconFocus(true) end, self)
	self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnCommIconFocusLost() end, self)
	self.char_info_icon_rank = xml:InitStatic("char_info_icon_rank", self.char_info_back)
	name = "char_info_icon_rank"
	self:Register(self.char_info_icon_rank, name)	
	self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnRankIconFocus(true) end, self)
	self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnRankIconFocusLost() end, self)	
	self.char_info_text = xml:InitStatic("char_info_text", self.char_info_back)
	
	--//character info NPC or date/time/money in inventory mode
	self.char_info_back_npc = xml:InitStatic("char_info_back_npc", self)
	self.char_info_icon_npc = xml:InitStatic("char_info_icon_npc", self.char_info_back_npc)
	self.char_info_icon_comm_npc = xml:InitStatic("char_info_icon_comm_npc", self.char_info_back_npc)
	name = "char_info_icon_comm_npc"
	self:Register(self.char_info_icon_comm_npc, name)
	self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnCommIconFocus(false) end, self)
	self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnCommIconFocusLost() end, self)	
	self.char_info_icon_rank_npc = xml:InitStatic("char_info_icon_rank_npc", self.char_info_back_npc)
	name = "char_info_icon_rank_npc"
	self:Register(self.char_info_icon_rank_npc, name)
	self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnRankIconFocus(false) end, self)
	self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnRankIconFocusLost() end, self)	
	self.char_info_text_npc = xml:InitStatic("char_info_text_npc", self.char_info_back_npc)
	
	--//weight static
	self.inv_weight = xml:InitStatic("weight_static", self)
	self.inv_weight_progress = xml:InitProgressBar("weight_static:progress", self.inv_weight)
	self:UpdateWeightText()

	--//date/time static
	self.time_static = xml:InitStatic("time_static", self)
	
	--//exit button
	self.exit_button = xml:Init3tButton("exit_button", self)
	name = "exit_button"
	self:Register(self.exit_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.Exit, self)	
	
	--//organize button
	self.organize_button = xml:Init3tButton("organize_button", self)
	self.key_accels[self.organize_button:GetAccelerator(0)] = true	
	name = "organize_button"
	self:Register(self.organize_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.Organize, self)
	
	--//inventory mode
	--//craft button
	self.craft_button = xml:Init3tButton("craft_btn", self)
	self.key_accels[self.craft_button:GetAccelerator(0)] = true
	name = "craft_button"
	self:Register(self.craft_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.Craft, self)
	
	--//skip time button
	self.skip_time_button = xml:Init3tButton("skip_time_btn", self)
	self.key_accels[self.skip_time_button:GetAccelerator(0)] = true
	name = "skip_time_button"
	self:Register(self.skip_time_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.SkipTime, self)		
	
	--//carbody mode
	--//take all button
	self.take_all_button = xml:Init3tButton("take_all_btn", self)
	self.key_accels[self.take_all_button:GetAccelerator(0)] = true	
	name = "take_all_button"
	self:Register(self.take_all_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.TakeAll, self)
	--//move all ruck button
	self.move_all_ruck_button = xml:Init3tButton("move_all_ruck_btn", self)
	self.key_accels[self.move_all_ruck_button:GetAccelerator(0)] = true
	name = "move_all_ruck_button"
	self:Register(self.move_all_ruck_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.MoveAllRuck, self)	
	
	--//trade mode
	--//trade button
	self.trade_button = xml:Init3tButton("trade_button", self)
	name = "trade_button"
	self:Register(self.trade_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.PerformTrade, self)

	--//repair mode
	--//repair back
	self.repair_back = xml:InitStatic("repair_back", self)
	self.repair_condition = xml:InitStatic("repair_back:condition", self.repair_back)
	self.repair_condition_progress = xml:InitProgressBar("repair_back:condition_progress_bar", self.repair_back)
	self.repair_item_back = xml:InitStatic("repair_back:repair_item_back", self.repair_back)
	self.repair_item = xml:InitStatic("repair_back:repair_item_back:repair_item", self.repair_item_back)
	--//repair button
	self.repair_button = xml:Init3tButton("repair_button", self)
	name = "repair_button"
	self:Register(self.repair_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.PerformRepair, self)
	
	--//to talk button
	self.to_talk_button = xml:Init3tButton("to_talk_button", self)
	name = "to_talk_button"
	self:Register(self.to_talk_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.SwitchToTalk, self)
	
	--//action sounds
	name = "action_sounds"
	self.action_sounds = {}
	local sound_names = {
		"open",
		"close",
		"to_slot",
		"to_belt",
		"to_ruck",
		"properties",
		"drop",
		"repair_weapon",
		"repair_armor",
		"trade",
	}
	for k,snd_name in pairs(sound_names) do
		self.action_sounds[snd_name] = xr_sound.get_safe_sound_object(xml:ReadAttrib(name, snd_name, ""))
	end
	
	--//operate sounds
	name = "operate_sounds"
	self.operate_sounds = {}
	local sound_names = {
		"ammo",
		"grenade",
		"bottle",
		"cloth",
		"generic",
		"key",
		"knife",
		"parts",
		"pills",
		"weapon",
		"weapon_heavy",
	}
	for k,snd_name in pairs(sound_names) do
		local params = split_string(xml:ReadAttrib(name, snd_name, nil), ",")
		if params then
			self.operate_sounds[snd_name] = {sound_name = params[1], rnd_count = params[2]}
		end
	end	
	
	--//selected item tip
	self.selected_item_tip = xml:InitStatic("selected_item_tip", self)
end

function ActorMenuOverlay:QuickOnFocusReceived(slot_num)
	quick_slots.set_selected(slot_num)
	self.slots[slot_num].highlight:Show(true)
	self.sm:call("on_quick_item_focus", quick_slots.get_item(slot_num))
end

function ActorMenuOverlay:QuickOnFocusLost(slot_num)
	quick_slots.set_selected(nil)
	self.slots[slot_num].highlight:Show(false)
	self.sm:call("on_quick_item_focus_lost", quick_slots.get_item(slot_num))
end

function ActorMenuOverlay:OnCellItemFocus(obj, cell_item)
	local sect = obj:section()
	local highlight_quick_slots = read_if_exists(sys_ini, "bool", sect, "quick_slot", false)
	if highlight_quick_slots then
		for i=0,3 do
			self.slots[i].highlight:Show(true)
		end
	end
	local slot_type = loadout.get_slot_type(obj)
	if slot_type then
		for k,v in pairs(self.loadout) do
			if slot_type == k then
				local color = self.loadout_color_blocked
				if loadout.can_remove(obj) then
					color = self.loadout_color_equiped
				end
				if loadout.can_add(obj) then
					color = self.loadout_color_highlight
				end
				v.static:SetTextColor(color)
				--v.icon:SetColor(color)
			end
		end
	end
	--//dragdrop
	if cell_item then
		self.cell_item_focused = cell_item
		cell_item:SetBlinking(false)
		if new_items[obj:id()] then
			new_items[obj:id()] = nil
		end
	end
	if read_if_exists(sys_ini, "bool", sect, "belt", false) and not actor:is_on_belt(obj) then
		self.belt_list:Highlight(true)
	end
	if loadout.is_loadout_item(obj) then
		self.loadout_list:Highlight(not loadout.can_remove(obj))
	end
	local slots = read_if_exists(sys_ini, "string", sect, "slot", nil)
	if slots then
		slots = split_string(slots, ",", true)
		for k,v in pairs(slots) do
			if not actor:item_in_slot(v) or actor:item_in_slot(v):id() ~= obj:id() then
				self.slot_list[v]:Highlight(true)
			end
		end
	end
	--//trade
	if self:GetMode() == "trade" and trade_manager.tradable(obj) then
		if parent_is_actor(obj) and cell_item:GetOwnerList():GetID() ~= "sell_list" then
			self.sell_list:Highlight(true)
		end
		if not parent_is_actor(obj) and cell_item:GetOwnerList():GetID() ~= "buy_list" then
			self.buy_list:Highlight(true)
		end	
	end
end

function ActorMenuOverlay:OnCellItemFocusLost(obj, cell_item)
	for i=0,3 do
		self.slots[i].highlight:Show(false)--.back:SetColor(self.quick_color_default)
	end
	for k,v in pairs(self.loadout) do
		v.static:SetTextColor(self.loadout_color_default)
		--v.icon:SetColor(self.loadout_color_default)
	end
	
	--//dragdrop
	self.cell_item_focused = nil
	
	self.belt_list:Highlight(false)
	self.loadout_list:Highlight(false)
	for k,v in pairs(self.slot_list) do
		v:Highlight(false)
	end
	--//trade
	if self:GetMode() == "trade" then
		self.sell_list:Highlight(false)
		self.buy_list:Highlight(false)
	end	
end

function ActorMenuOverlay:OnCellItemSelect(item, cell_item)
	self.ruck_list:UnselectAll()
	self.belt_list:UnselectAll()
	self.loadout_list:UnselectAll()
	for k,v in pairs(self.slot_list) do
		v:UnselectAll()
	end
	self.target_list:UnselectAll()
	self.buy_list:UnselectAll()
	self.sell_list:UnselectAll()
	cell_item:SetSelected(true)
	
	self.cell_item_selected = cell_item
	
	self.ruck_list:ColorizeCompatible(item)
	self.belt_list:ColorizeCompatible(item)
	self.loadout_list:ColorizeCompatible(item)
	for i,list in pairs(self.slot_list) do
		list:ColorizeCompatible(item)
	end
	if self.target_list:IsShown() then
		self.target_list:ColorizeCompatible(item)
	end
	
	self:UpdateRepair(cell_item)
	self:UpdateInvTip(cell_item)
end

function ActorMenuOverlay:ResetCellItemSelected()
	if not self.cell_item_selected then
	return end
	self.cell_item_selected:GetOwnerList():UnselectAll()
	self.cell_item_selected:ClearColorize()
	self.cell_item_selected = nil
	self:UpdateInvTip()	
end

function ActorMenuOverlay:OnCellItemStartDrag(cell_item)
	local item = cell_item:GetAnyItem()
	local cell_pos = vector2():set(1, 1)
	self.drag_item = ui_cell_item.UICellItem(self, item, cell_pos, cell_item:GetCellSize(), cell_item:GetOwnerList())
	self.drag_item:SetInteractive(false)
	self.drag_item.orig_pos = vector2():set(cell_item:GetMousePosX(), cell_item:GetMousePosY())
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:UpdateDragItem()
	if not self.drag_item then
	return end
	
	local pos = vector2():set(self:GetMousePosX(), self:GetMousePosY())
	local orig_pos = self.drag_item.orig_pos
	self.drag_item:SetWndPos(pos.x - orig_pos.x, pos.y - orig_pos.y)
end

function ActorMenuOverlay:ServiceOnLButtonUp()
	if self.drag_item then
		self.sm:call("on_drag_item_drop", self.drag_item)
		self:DestroyDragItem()
	end
end

function ActorMenuOverlay:DestroyDragItem()
	if not self.drag_item then
	return end
	self.drag_item:DetachWnd()
	self.drag_item = nil
end

function ActorMenuOverlay:OnDragItemDrop(cell_item)
	self:ResetCellItemSelected()
	
	local item = cell_item:GetItem()
	local parent = cell_item:GetOwnerList()
	
	self:PlayOperateSound(item)
	
	local ci_f = self.cell_item_focused
	if ci_f then
		local on_item = ci_f:GetAnyItem()
		self.sm:call( "inv_drag_drop", item, on_item )
		return
	end
	
	local cic_f = self.cell_container_focused
	if cic_f then
		if cic_f:GetID() == parent:GetID() then
		return end
		
		local mode = self:GetMode()
		if mode == "trade" then
			if not trade_manager.tradable(item) then
			return end
			if parent_is_actor(item) then
				if cic_f:GetID() == "sell_list" then
					ui_cell_item_utils.move_cell_item(cell_item, parent, cic_f)
				elseif parent:GetID() == "sell_list" then
					local target = self.ruck_list
					if actor:is_in_slot(item) then
						target = self.slot_list[item:get_slot()]
					elseif actor:is_on_belt(item) then
						target = self.belt_list
					elseif loadout.can_remove(item) then
						target = self.loadout_list						
					end
					ui_cell_item_utils.move_cell_item(cell_item, parent, target)
				end
			else
				if cic_f:GetID() == "buy_list" then
					ui_cell_item_utils.move_cell_item(cell_item, parent, self.buy_list)
				else
					ui_cell_item_utils.move_cell_item(cell_item, parent, self.target_list)
				end
			end
			self:UpdatePrices()
			return
		else
			if cic_f:GetID() == "target_list" then
				ui_cell_item_utils.transfer_cell_item(cell_item, self.target)
				return
			end
			if not parent_is_actor(item) then
				ui_cell_item_utils.transfer_cell_item(cell_item, actor)
				return
			end
			if cic_f:GetID() == "ruck_list" then
				actor:move_to_ruck(item)
				loadout.try_set_item(item)
			elseif cic_f:GetID() == "belt_list" then
				actor:move_to_belt(item)
			elseif cic_f:GetID() == "loadout_list" then
				loadout.try_set_item(item)
			else
				local slots = read_if_exists(sys_ini, "string", item:section(), "slot", nil)
				if slots then
					slots = split_string(slots, ",", true)
					for k,i in pairs(slots) do
						if self.slot_list[i]:GetID() == cic_f:GetID() then
							local slot_item = actor:item_in_slot(i)
							if slot_item then
								actor:move_to_ruck(slot_item)
							end
							item:set_slot(i)
							actor:move_to_slot(item)
							break
						end
					end
				end
			end
		end
	end
end

function ActorMenuOverlay:OnContainerFocus(container)
	self.cell_container_focused = container
end

function ActorMenuOverlay:OnContainerFocusLost(container)
	self.cell_container_focused = nil
end

function ActorMenuOverlay:DrawSlotIcon(slot_num)
	local s = self.slots[slot_num]
	local sect = quick_slots.get_item_sect(slot_num)
	local show_icon = sect ~= ""
	s.icon:Show(show_icon)
	if show_icon then
		local params = CIconParams(sect)
		SetCellIcon(s.icon.image, params)
		ui_inv_utils.CellItemFitToSize(params, s.icon.image, s.icon)
		ui_inv_utils.UpdateLayerIcons(sect, s.icon.image)
	end	
	
	local count = quick_slots.get_item_count(slot_num)
	local count_text = string.format("x%s", count)
	s.count:SetText(count_text)
	s.count:Show(count > 0)

	if count > 0 then
		s.icon.image:SetColor(self.quick_color_has_item)
	else
		s.icon.image:SetColor(self.quick_color_no_item)
	end
end

function ActorMenuOverlay:QuickOnDbClick(slot_num)
	quick_slots.set_item("", slot_num)
	self:UpdateSlots()
end

function ActorMenuOverlay:UpdateSlots()
	for i=0,3 do
		self:DrawSlotIcon(i)
	end
	
	local loadout_slot_text
	for k,v in pairs(self.loadout) do
		loadout_slot_text = string.format("[%s/%s]", loadout.get_current(k), loadout.get_max(k))
		v.static:SetText(loadout_slot_text)
	end
end

function ActorMenuOverlay:CheckNeedUpdate(obj, prev_place)
	local item_allowed = read_if_exists(sys_ini, "bool", obj:section(), "quick_slot", false)
	if not item_allowed then
		return
	end
	self:UpdateSlots()
end

function ActorMenuOverlay:ConditionOnFocusReceived(cond_name)
	self.conditions[cond_name].percent:Show(true)
	self.conditions[cond_name].icon:SetColor(self.loadout_color_equiped)
	local cond_descr = game.translate_string(string.format("%s%s%s","st_", cond_name, "hint"))
	local cond_restore_text = ""
	local restore_speed = self.conditions[cond_name].restore_speed and self.conditions[cond_name].restore_speed() or nil
	if restore_speed then
		local for_rad = false--cond_name == "radiation_"
		local _k = for_rad and 1 or 100
		local round = for_rad and 3 or 1
		if restore_speed > 1 then
			restore_speed = math.round(restore_speed/60*_k, round)
			cond_restore_text = string.format("%s: %s %s", game.translate_string("st_"..cond_name.."restore_hint"), restore_speed, game.translate_string(for_rad and "st_radiation_per_minute" or "st_percent_per_minute"))
		else
			restore_speed = math.round(restore_speed*_k, round)
			cond_restore_text = string.format("%s: %s %s", game.translate_string("st_"..cond_name.."restore_hint"), restore_speed, game.translate_string(for_rad and "st_radiation_per_hour" or "st_percent_per_hour"))
		end
	end
	local cond_text = game.translate_string(string.format("%s%s%s","st_", cond_name, "hint_text"))
	if cond_name == "injure_" then
		local pain_eff = body_health.get_pain_effect()
		local pain = pain_eff == 0 and "" or pain_eff > 0 and "_more_pain" or "_less_pain"
		cond_text = game.translate_string(string.format("%s%s%s%s%s","st_", cond_name, self.conditions[cond_name].condition(), pain, "_hint_text"))
		--log3("~hint string: %s", cond_text)
	end
	local tip_text = string.format("%s\\n---------------------------------\\n%s\\n---------------------------------\\n%s", cond_descr, cond_restore_text, cond_text)	
	self:SetTooltip(tip_text)
end

function ActorMenuOverlay:ConditionOnFocusLost(cond_name)
	self.conditions[cond_name].percent:Show(false)
	self.conditions[cond_name].icon:SetColor(self.loadout_color_default)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:OnWarningIconFocus(name, icon)
	if name == "limbs_injure" then
		local condition = body_health.get_injured_limb()
		local cond_descr = game.translate_string(string.format("%s%s%s%s%s","st_", name, "_", condition, "_hint"))
		local pain_eff = body_health.get_pain_effect()
		local pain = pain_eff == 0 and "" or pain_eff > 0 and "_more_pain" or "_less_pain"
		local cond_text = game.translate_string(string.format("%s%s%s%s%s%s","st_", name, "_", condition, pain, "_hint_text"))		
		local tip_text = string.format("%s\\n---------------------------------\\n%s", cond_descr, cond_text)
		self:SetTooltip(tip_text)		
	end
end

function ActorMenuOverlay:OnWarningIconFocusLost(name, icon)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:LoadoutSlotOnFocusReceived(slot_name)
	self.loadout[slot_name].static:SetTextColor(self.loadout_color_equiped)
	local type_descr = game.translate_string(slot_name)
	local type_text = game.translate_string(string.format("%s%s%s","st_", slot_name, "_hint_text"))	
	local tip_text = string.format("%s\\n---------------------------------\\n%s", type_descr, type_text)	
	self:SetTooltip(tip_text)
end

function ActorMenuOverlay:LoadoutSlotOnFocusLost(slot_name)
	self.loadout[slot_name].static:SetTextColor(self.loadout_color_default)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:SetTooltip(text)
	self.tooltip_frame:Show(not not text)
	self.tooltip_frame:SetHeight(self.tooltip_frame_base_height)
	self.tooltip:SetHeight(0)
	if text then
		self.tooltip:SetText(text)
		self.tooltip:AdjustHeightToText()
		self:BringToTop(self.tooltip_frame)
		if self.tooltip:GetHeight() > self.tooltip_frame_base_height - 10 then
			self.tooltip_frame:SetHeight(self.tooltip:GetHeight() + 15)
		end
	end
end

function ActorMenuOverlay:UpdateTooltip()
	if not self.tooltip_frame:IsShown() then
	return end
	
	local pos = vector2():set(self:GetMousePosX(), self:GetMousePosY())
	pos.x = pos.x + self.tooltip_frame.offset.x
	pos.y = pos.y + self.tooltip_frame.offset.y
	local wnd_size = {x = self.tooltip_frame:GetWidth(), y = self.tooltip_frame:GetHeight()}
	local delta = {x = pos.x + wnd_size.x - UI_BASE_WIDTH, y = pos.y + wnd_size.y - UI_BASE_HEIGHT}
    if delta.x > 0 then
        pos.x = pos.x - delta.x
	end		
    if delta.y > 0 then
        pos.y = pos.y - delta.y
	end		
	self.tooltip_frame:SetWndPos(pos.x, pos.y)	
end

function ActorMenuOverlay:UpdateConditions()
	local val
	for k,v in pairs(self.conditions) do
		val = math.clamp(v.condition(), 0, 1)
		v.progress:SetProgressPos(val)
		-- if k == "radiation_" then
			-- v.percent:SetText(string.format("%.2f %s", val, game.translate_string("st_rad")))
		-- else
			v.percent:SetText(string.format("%.0f%s", val*100, game.translate_string("st_percent")))
		--end
	end
end

local account_slots = {
	[OUTFIT_SLOT] = true,
	[HELMET_SLOT] = true,
	[BACKPACK_SLOT] = true,
}
local plus_are_bad = {
	["radiation_restore_speed"] = true,
	["alcohol_restore_speed"] = true,
	["boost_somnolence"] = true,
	["boost_pain"] = true,
	["power_loss"] = true,
}
function ActorMenuOverlay:UpdateEffectsInfo()
	self.effects_info:Show(self:GetMode() == "inventory")
	if not self.effects_info:IsShown() then
	return end
	
	self.effects_info.scroll_view:Clear()
	
	local text = ""
	local sn, sn_boost
	local sn_time = game.translate_string("st_time_minute")
	local conds = actor.conditions
	
	local outfit, helmet, backpack = actor_get_outfit(), actor_get_helmet(), actor_get_backpack()
	
	for _i=1, table.size(self.effects_info.effects) do
		local val, val_boost, boost_time = 0, 0, 0
		
		local i = _i-1
		
		local t = self.effects_info.effects[_i]
		
		if t.param == "power_loss" then
			local item
			for i,_ in pairs(account_slots) do
				item = actor:item_in_slot(i)
				if item then
					val = val + item:get_inventory_item().power_loss
				end
			end
		else
			val_boost = boosters.get_boosted_params(_i)
			boost_time = boosters.get_boosted_time(_i)
			
			if i < 11 then 				--//effects
				if i < 8 then			--//additional_sprint
					val = val + actor_obj:get_items_effect(i)
				else
					val = val + actor_obj:get_artefacts_effect(i)
					if outfit then
						val = val + outfit:get_inventory_item():item_effect(i)
					end
					if helmet then
						val = val + helmet:get_inventory_item():item_effect(i)
					end
					if backpack then
						val = val + backpack:get_inventory_item():item_effect(i)
					end				
				end
			else 						--//protection
				local ii = i - 11
				val = val + actor_obj:get_artefacts_protection(ii)
				if outfit then
					val = val +outfit:get_inventory_item():hit_type_protection(ii)
				end
				if helmet then
					val = val +helmet:get_inventory_item():hit_type_protection(ii)
				end			
			end
		
		end

		if i < 8 or t.param == "boost_somnolence" then
			local for_rad = false--t.param == "radiation_restore_speed"
			local _k = for_rad and 1 or 100
			sn = string.format(" %s", game.translate_string(for_rad and "st_radiation_per_minute" or "st_percent_per_minute"))
			val = val * 60 * _k
			if  math.abs(val) < 0.1 then
				sn = string.format(" %s", game.translate_string(for_rad and "st_radiation_per_hour" or "st_percent_per_hour"))
				val = val * 60
			end
			
			sn_boost = string.format(" %s", game.translate_string(for_rad and "st_radiation_per_minute" or "st_percent_per_minute"))
			val_boost = val_boost * 60 * _k
			if  math.abs(val_boost) < 0.1 then
				sn_boost = string.format(" %s", game.translate_string(for_rad and "st_radiation_per_hour" or "st_percent_per_hour"))
				val_boost = val_boost * 60
			end				
		else
			val = val * 100
			val_boost = val_boost * 100
			sn = game.translate_string("st_percent")
			sn_boost = game.translate_string("st_percent")
		end		
		
		if not math.fsimilar(val, 0) or not math.fsimilar(val_boost, 0) then
				
			local color = val > 0 and "%c[green]" or "%c[red]"
			local color_boost = val_boost > 0 and "%c[green]" or "%c[red]"
		
			if plus_are_bad[t.param] then
				color = val > 0 and "%c[red]" or "%c[green]"
				color_boost = val_boost > 0 and "%c[red]" or "%c[green]"
			end
		
			local name = game.translate_string(t.name)
			
			local fmt
			
			if val ~= 0 and val_boost ~= 0 then
				fmt = "%s %s%+.1f%s %s%+.1f%s [%.f %s]"
				text = string.format(fmt, name, color, val, sn, color_boost, val_boost, sn_boost, boost_time, sn_time)
			elseif val ~= 0 then
				fmt = "%s %s%+.1f%s"
				text = string.format(fmt, name, color, val, sn)
			elseif val_boost ~= 0 then
				fmt = "%s %s%+.1f%s [%.f %s]"
				text = string.format(fmt, name, color_boost, val_boost, sn_boost, boost_time, sn_time)
			end
		
			t.static:SetText(text)
			--t.static:AdjustHeightToText()
			self.effects_info.scroll_view:AddWindow(t.static)
		end
	end
end

function ActorMenuOverlay:Update()
	CUIScriptWnd.Update(self)
	
	if not actor:alive() then
		self:Exit()
	return end	
	
	self:UpdateConditions()
	self:UpdateEffectsInfo()
	self:UpdateWeightText()
	self:UpdateDateTimeText()
	self:UpdateTooltip()
	self:UpdateDragItem()
	
	local mode = self:GetMode()
	if mode ~= "inventory" and self.target then
		aim_camera_to_target(self.target)
		if distance_between_safe(actor, self.target) > actor.inventory.take_dist + self.target:radius() then
			self:Exit()
		end
	end
end

function ActorMenuOverlay:ClearLoadout()
	loadout.clear_all()
end

function ActorMenuOverlay:OnShow()
	self.sm:call("on_actor_menu_show", self:GetMode(), self:GetTarget())
	self:Subscribe()
	
	local cursor_pos = vector2():set(UI_BASE_WIDTH * 0.5, UI_BASE_HEIGHT * 0.7)
	level.set_cursor_pos(cursor_pos)	
	
	local mode = self:GetMode()
	self.target = self:GetTarget()
	
	local inv_box = self.target and self.target:get_inventory_box()
	if inv_box then
		inv_box.in_use = true
	end
	
	if mode == "repair" then
		self.repair = repair_manager.RepairManager(self.target)
	end
	
	self.craft_button:Show(mode == "inventory" and campfire_effects.actor_used_campfire())
	self.skip_time_button:Show(mode == "inventory" and campfire_effects.actor_used_campfire())
	self.take_all_button:Show(mode == "carbody")
	self.move_all_ruck_button:Show(mode == "carbody")	
	self.trade_button:Show(mode == "trade")
	self.repair_button:Show(mode == "repair")
	self.repair_back:Show(mode == "repair")
	self.to_talk_button:Show(mode == "trade" or mode == "repair")
	self.sell_buy_back:Show(mode == "trade")
	--self.conditions_background:Show(mode ~= "trade")
	--self.loadout_back:Show(mode ~= "trade")
	--self.quick_slots:Show(mode ~= "trade")
	self:OnShowButtonClick(0)
	self:OnActorIconUpdate()
	self:OnNPCIconUpdate()
	self:SetCharacterText()	
	self:SetCharacterTextNPC()
	self:UpdatePrices()
	self:UpdateSlots()
	
	self.use_anim:Show(false)
	
	self:PlayActionSound("open")
end

function ActorMenuOverlay:OnHide()
	self.sm:call("on_actor_menu_hide", self:GetMode(), self:GetTarget())
	self:Unsubscribe()
	
	inventory.repack_power_sources()
	-- actor:repack_ammo()
	-- if self.target then
		-- self.target:repack_ammo()
	-- end
	inventory.repack_ammo(actor)
	if self.target then
		inventory.repack_ammo(self.target)
	end
	
	local inv_box = self.target and self.target:get_inventory_box()
	if inv_box then
		inv_box.in_use = true
	end	
	
	self.target = nil
	self.mode = nil
	self.repair = nil
	
	self:PlayActionSound("close")
	
	new_items = {}
end

function ActorMenuOverlay:Exit()
	level.start_stop_menu(self, true)
end

--//switching of item visibility functions
function ActorMenuOverlay:OnShowButtonClick(show_type)
	for k,v in pairs(self.show_buttons) do
		v.button:SetCheck(k == show_type)
	end
	self:ReinitLists(show_type)
end

function ActorMenuOverlay:OnShowButtonFocusReceived(show_type)
	self:SetTooltip(game.translate_string(self.show_buttons[show_type].hint))
end

function ActorMenuOverlay:OnShowButtonFocusLost(show_type)
	self:SetTooltip(nil)
end

function ActorMenuOverlay:OnActorIconUpdate(icon)
	if not icon then
		icon = actor:get_character_icon()
	end
	self.char_info_icon:InitTexture(icon)
	self.char_info_icon_comm:InitTexture(community.get_icon_sect(actor:character_community()))
	self.char_info_icon_rank:InitTexture(ranks.get_icon_sect(actor))
end

function ActorMenuOverlay:OnNPCIconUpdate()
	
	--self.char_info_icon_npc:Show(self.target)
	self.char_info_icon_comm_npc:Show(self.target and not self.target:get_inventory_box())
	self.char_info_icon_rank_npc:Show(self.target and not self.target:get_inventory_box())

	if not self.target then
		self.char_info_icon_npc:InitTexture("ui_icon_backpack")
		return	
	elseif self.target and self.target:get_inventory_box() then
		self.char_info_icon_npc:InitTexture("ui_icon_chest")
		return
	end
	
	local npc_icon = self.target:get_character_icon()
	local icon = npc_icon and npc_icon or read_if_exists(sys_ini, "string", self.target:section(), "icon", nil)
	self.char_info_icon_npc:Show(icon)
	if not icon then
	return end
	self.char_info_icon_npc:InitTexture(icon)
	self.char_info_icon_comm_npc:InitTexture(community.get_icon_sect(self.target:character_community()))
	self.char_info_icon_rank_npc:InitTexture(ranks.get_icon_sect(self.target))
end

function ActorMenuOverlay:SetCharacterText()
	local name = game.translate_string(actor:character_name())
	local rept_color = game.translate_string(reputation.get_obj_reputation_color(actor))
	local money = actor:money()
	local money_unit = game.translate_string("ui_st_money_regional")
	local char_text = string.format("%s%s\\n%s%s %s", rept_color, name, "%c[default]", money, money_unit)
	self.char_info_text:SetText(char_text)
end

function ActorMenuOverlay:SetCharacterTextNPC()
	local show = self.target and not self.target:get_inventory_box()
	self.char_info_text_npc:Show(show)
	if not show then return end
	local name = game.translate_string(self.target:character_name())
	local rel_color = color_by_relation[self.target:relation(actor)]
	local money = (self.target:infinitive_money() or not self.target:alive()) and "---" or self.target:money()
	local money_unit = game.translate_string("ui_st_money_regional")
	local char_text = string.format("%s%s\\n%s%s %s", rel_color, name, "%c[default]", money, money_unit)
	self.char_info_text_npc:SetText(char_text)
end

function ActorMenuOverlay:OnCommIconFocus(for_actor)
	local obj = for_actor and actor or self.target
	if not obj then
	return end
	local text = string.format("%s %s", game.translate_string("st_community"), game.translate_string(obj:character_community()))
	self:SetTooltip(text)
end

function ActorMenuOverlay:OnCommIconFocusLost()
	self:SetTooltip(nil)
end

function ActorMenuOverlay:OnRankIconFocus(for_actor)
	local obj = for_actor and actor or self.target
	if not obj then
	return end
	local text = string.format("%s: %s", game.translate_string("ui_st_rank"), game.translate_string(ranks.get_obj_rank_name(obj)))
	self:SetTooltip(text)
end

function ActorMenuOverlay:OnRankIconFocusLost()
	self:SetTooltip(nil)
end

function ActorMenuOverlay:UpdateWeightText()
	local inv = actor.inventory
	local weight = actor:get_inventory_weight()
	local max_weight = actor:get_max_weight()
	
	local weight_color = weight < max_weight and "%c[UI_orange]" or "%c[red]"
	local weight_unit = game.translate_string("st_kg")
	
	local weight_text = string.format("%s%.1f/%.1f %s", 
									weight_color,
									weight,
									max_weight,
									weight_unit)
									
	self.inv_weight:SetText(weight_text)
	
	self.inv_weight_progress:SetProgressPos(weight/max_weight)
end

function ActorMenuOverlay:PerformTrade()
	local money_give = self.money_from_actor
	local money_take = self.money_to_actor

	if money_give == 0 and money_take == 0 then
	return end
	
	if money_give > actor:money() + money_take then
		local text = string.format("%s - %s", game.translate_string(actor:character_name()), game.translate_string("st_not_enough_money_to_trade"))
		self.sell_buy_back:SetText(text)
	return end
	
	if money_take > self.target:money() + money_give then
		local text = string.format("%s - %s", game.translate_string(self.target:character_name()), game.translate_string("st_not_enough_money_to_trade"))
		self.sell_buy_back:SetText(text)
	return end	

	local function trade_operation(trade_list, money, seller, buyer)
		local sell_buy = (seller:id() == actor:id())
		buyer:transfer_money(money, seller)
		local item
		for cell_item,v in pairs(trade_list:GetCellItems()) do
			for id,v in pairs(cell_item:GetChilds()) do
				item = level.object_by_id(id)
				seller:transfer_item(item, buyer)
				self.sm:call("on_trade", item, sell_buy, trade_manager.get_trade_cost(item))
			end
			item = cell_item:GetItem()
			seller:transfer_item(item, buyer)
			trade_list:RemoveItem(item)
			self.sm:call("on_trade", item, sell_buy, trade_manager.get_trade_cost(item))
		end		
	end
	
	-- if money_give > 0 then
		-- trade_operation(self.buy_list, money_give, self.target, actor)
		-- game_stats.money_trade_update(-money_give) --//воно не треба насправді але нехай поки буде
	-- end
	-- if money_take > 0 then
		-- trade_operation(self.sell_list, money_take, actor, self.target)
		-- game_stats.money_trade_update(money_take) --//воно не треба насправді але нехай поки буде
	-- end
	
	if actor:money() < money_give then
		if money_take > 0 then
			trade_operation(self.sell_list, money_take, actor, self.target)
			game_stats.money_trade_update(money_take) --//воно не треба насправді але нехай поки буде
		end
		if money_give > 0 then
			trade_operation(self.buy_list, money_give, self.target, actor)
			game_stats.money_trade_update(-money_give) --//воно не треба насправді але нехай поки буде
		end		
	else
		if money_give > 0 then
			trade_operation(self.buy_list, money_give, self.target, actor)
			game_stats.money_trade_update(-money_give) --//воно не треба насправді але нехай поки буде
		end
		if money_take > 0 then
			trade_operation(self.sell_list, money_take, actor, self.target)
			game_stats.money_trade_update(money_take) --//воно не треба насправді але нехай поки буде
		end		
	end

	self.sm:call("on_perform_trade", self.target, money_give, money_take)
	self:PlayActionSound("trade")
	
	self:UpdateCharInfos()
	self:UpdatePrices()
end

-- function ActorMenuOverlay:PerformRepair()
-- end

function ActorMenuOverlay:SwitchToTalk()
	--actor:switch_to_talk()
	--self:Exit()
	ShowHideMenu()
	level.get_talk_wnd():Show(true)
end

function ActorMenuOverlay:UpdateCharInfos()
	self:SetCharacterText()
	self:SetCharacterTextNPC()		
end

function ActorMenuOverlay:UpdateDateTimeText()
	if not actor_get_pda() or not actor_get_pda():is_power_on() then
		self.time_static:SetText("")
		return
	end
	local game_time = game.get_game_time()
	local _date = string.format("%s %s", get_current_weekday_name(true), game_time:dateToString(game.CTime.DateToDay))
	local _time = game_time:timeToString(game.CTime.TimeToMinutes)
	local time_text = string.format("%s %s", _time, _date)
	self.time_static:SetText(time_text)
end

function ActorMenuOverlay:Organize()
	inventory.repack_power_sources()
	-- actor:repack_ammo()
	-- if self.target then
		-- self.target:repack_ammo()
	-- end
	inventory.repack_ammo(actor)
	if self.target then
		inventory.repack_ammo(self.target)
	end	
	add_update_delayed_action(1, function() self:OnShowButtonClick(0) end)
end

function ActorMenuOverlay:TakeAll()
	inventory.take_all(self.target)
	add_update_delayed_action(1, function() self:Exit() end)
--	self:Exit()
end
function ActorMenuOverlay:MoveAllRuck()
	inventory.move_all_ruck(self.target)
end

function ActorMenuOverlay:Craft()
	ui_craft.CraftOverlay("craft_campfire")
end

function ActorMenuOverlay:SkipTime()
	local function wait_time(skeep_h)
		level.add_pp_effector("blink.ppe", 999, false)
		local total_minutes = skeep_h * 60
		local time_quant_minutes = 15
		--//рахуємо цілу частину та залишок від ділення
		local iter_count, remainder = math.modf(total_minutes / time_quant_minutes)
		--log_news("~iter_count %s, remainder %s", iter_count, remainder)
		--//промотаємо час на фіксовані проміжки
		for i = 1, iter_count do
			change_game_time(0, 0, time_quant_minutes)
		end
		--//промотаємо час на залишок хвилин
		if remainder > 0 then
			change_game_time(0, 0, remainder)
		end		
	end
	ui_skip_time.show_skip_time_window("wait", wait_time)
end

function ActorMenuOverlay:ReinitLists(show_type)
	if show_type == 0 then
		show_type = nil	
	end
	
	self:DestroyDragItem()
	self.cell_item_selected = nil
	self.cell_item_focused = nil
	self.cell_container_focused	= nil
	self:UpdateInvTip()
	self:UpdateRepair()
	
	self.ruck_list:Reinit()
	self.belt_list:Reinit()
	self.loadout_list:Reinit()
	for i,list in pairs(self.slot_list) do
		list:Reinit()
		list:SetLocked(not actor.inventory:is_slot_allowed(i))
	end
	
	local mode = self:GetMode()	
	
	local function show_item(item)
		return not get_inv_item_hidden(item) and (not show_type or show_type == ui_inv_utils.get_type(item) or ui_inv_utils.get_type(item) == 0) and (mode ~= "trade" or trade_manager.tradable(item)) and (mode ~= "repair" or (self.repair:RepairAllowed(item) or self.repair:HackAllowed(item)))
	end
	
	local ruck_items, belt_items, loadout_items = {}, {}, {}
	
	function fill_list(dummy, item)
		if loadout.can_remove(item) then
			table.insert(loadout_items, item)
		elseif actor:is_in_ruck(item) then
			if show_item(item) then
				table.insert(ruck_items, item)
			end
		elseif actor:is_on_belt(item) then
			table.insert(belt_items, item)
		else
			self.slot_list[item:get_slot()]:AddItem(item)
		end
	end
	actor:iterate_inventory(fill_list, nil)
	
	table.sort(ruck_items, ui_inv_utils.sort_by_size_type)
	for k, item in pairs(ruck_items) do
		self.ruck_list:AddItem(item)
	end
	
	table.sort(belt_items, ui_inv_utils.sort_by_size)
	for k, item in pairs(belt_items) do
		self.belt_list:AddItem(item)
	end
	
	table.sort(loadout_items, ui_inv_utils.sort_by_size)
	for k, item in pairs(loadout_items) do
		self.loadout_list:AddItem(item)
	end	
	
	self.target_list:Reinit()
	self.target_list:Show(mode == "carbody" or mode == "trade")
	if self.target_list:IsShown() then
		local target_items = {}
		function fill_target_list(dummy, item)
			if show_item(item) then
				table.insert(target_items, item)
			end
		end		
		self.target:iterate_inventory(fill_target_list, nil)
		table.sort(target_items, ui_inv_utils.sort_by_size_type)
		for k, item in pairs(target_items) do
			self.target_list:AddItem(item)
		end
	end
	
	self:UpdateCustomDraw()
	
	self.buy_list:Reinit()
	self.sell_list:Reinit()
	self.sell_buy_back:SetText("")
	self:UpdatePrices()
	
	for id, v in pairs(new_items) do
		local item = level.object_by_id(id)
		if item then
			local ci = self:GetCellItem(item)
			if ci then
				ci:SetBlinking(true)
			end
		end
	end
end

function ActorMenuOverlay:UpdateCustomDraw()
	for i,list in pairs(self.slot_list) do
		list:SetLocked(not actor.inventory:is_slot_allowed(i))
	end
	self:OnMaxBeltSet(actor.inventory.max_belt)
end

function ActorMenuOverlay:OnCellItemRBClick(item, cell_item)
	self:ShowPropertiesBox(item, cell_item)
end

function ActorMenuOverlay:OnCellItemDBClick(item, cell_item)
	local item = cell_item:GetAnyItem()
	
	local mode = self:GetMode()
	local key_all = key_state(bind_to_dik(key_bindings.kADDITIONAL_ACTION))
	
	if mode == "repair" then
		self:ShowRepairRequest()
		return
	elseif mode == "inventory" then
		if actor:is_in_slot(item) or actor:is_on_belt(item) then
			actor:move_to_ruck(item)
			return
		end
	
		local slots = read_if_exists(sys_ini, "string", item:section(), "slot", nil)
		if slots then
			slots = split_string(slots, ",", true)
			for k,i in pairs(slots) do
				if actor:can_put_in_slot(item, i) and parent_is_actor(item) then
					item:set_slot(i)
					actor:move_to_slot(item)
					return
				end
			end
		end
	
		if actor:can_put_in_belt(item) and parent_is_actor(item) then
			actor:move_to_belt(item)
			return
		end
	elseif mode == "carbody" then
		local new_owner = parent_is_actor(item) and self.target or actor
		ui_cell_item_utils.transfer_cell_item(cell_item, new_owner, key_all)
		return
	else
		local parent = cell_item:GetOwnerList()
		local target = nil
		
		if not trade_manager.tradable(item) then
		return end
		
		if parent_is_actor(item) then
			if parent:GetID() ~= "sell_list" then
				target = self.sell_list
			else
				target = self.ruck_list
				if actor:is_in_slot(item) then
					target = self.slot_list[item:get_slot()]
				elseif actor:is_on_belt(item) then
					target = self.belt_list
				end					
			end
		else
			target = parent:GetID() == "buy_list" and self.target_list or self.buy_list
		end		
		
		if target then
			ui_cell_item_utils.move_cell_item(cell_item, parent, target, key_all)
			self:UpdatePrices()
		end
		return
	end
end

function ActorMenuOverlay:OnRuck(item)
	self:UpdateSlots()
	local ci = self:GetCellItem(item)
	if ci then
		ci:GetOwnerList():RemoveItem(item)
	end
	self.ruck_list:AddItem(item)
	self:UpdateCustomDraw()
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnDrop(item)
	self:UpdateSlots()
	local ci = self:GetCellItem(item)
	if ci then
		ci:GetOwnerList():RemoveItem(item)
	end
	self:UpdateCustomDraw()
	-- self:PlayActionSound("drop")
	-- self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnSlot(item)
	local ci = self:GetCellItem(item)
	if ci then
		ci:GetOwnerList():RemoveItem(item)
	end	
	self.slot_list[item:get_slot()]:AddItem(item)
	self:UpdateCustomDraw()
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnBelt(item)
	local ci = self:GetCellItem(item)
	if ci then
		ci:GetOwnerList():RemoveItem(item)
	end
	self.belt_list:AddItem(item)
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnMoveLoadout(item, item_in)
	if not item then return end
	
	local ci = self:GetCellItem(item)
	if ci then
		ci:GetOwnerList():RemoveItem(item)
	end
	
	if item_in then
		self.loadout_list:AddItem(item)
	else
		self.ruck_list:AddItem(item)
	end
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnUse(item)
	if parent_is_actor(item) then
		self:UpdateSlots()
	end
	local ci = self:GetCellItem(item)	
	if ci then
		if item:get_eatable_item().eat_portions_num > 0 then
			ci:ForceUpdate()
		else
			ci:GetOwnerList():RemoveItem(item)
		end
	end
end

function ActorMenuOverlay:OnItemToPartner(partner, item)
	if not self.target then
	return end
	if partner:id() ~= self.target:id() then
	return end
	if not self.target_list:IsShown() then
	return end
	if self:GetMode() == "trade" and not trade_manager.tradable(item) then
	return end
	self.target_list:AddItem(item)
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnItemFromPartner(partner, item)
	if not self.target then
	return end
	if partner:id() ~= self.target:id() then
	return end
	if not self.target_list:IsShown() then
	return end
	if self:GetMode() == "trade" and not trade_manager.tradable(item) then
	return end
	self.target_list:RemoveItem(item)
	self:PlayOperateSound(item)
end

function ActorMenuOverlay:OnMaxBeltSet(max_belt)
	if self.belt_list:GetColsNum() ~= max_belt then
		self.belt_list:SetColsNum(max_belt)
		self.belt_list:Reinit()
		for i = 0, actor:belt_count() - 1 do
			local item = actor:item_on_belt(i)
			if item then
				self.belt_list:AddItem(item)			
			end
		end		
	end
end

local quick_action = {
	[key_bindings.kQUICK_SLOT_0] = true,
	[key_bindings.kQUICK_SLOT_1] = true,
	[key_bindings.kQUICK_SLOT_2] = true,
	[key_bindings.kQUICK_SLOT_3] = true,
}

function ActorMenuOverlay:OnKeyboard(dik, keyboard_action)
	CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
	
	local game_action = dik_to_bind(dik)
	
	if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		local mode = self:GetMode()
		
		if game_action == key_bindings.kUSE then 
			if mode == "carbody" then
				self:Exit()
				return true
			end
			if self.cell_item_selected then
				local item = self.cell_item_selected:GetAnyItem()
				if script_actions.can_eat(item) then
					script_actions.eat(item)
					self:ResetCellItemSelected()
					return true
				end
				if pda.can_try_hack(item) then
					pda.try_hack(item)
					self:ResetCellItemSelected()
					return true
				end
				if glowstick.can_be_activated(item) then
					glowstick.activate(item)
					self:ResetCellItemSelected()
					return true
				end				
			end
		elseif game_action == key_bindings.kDROP then
			if mode == "inventory" then
				if self.cell_item_selected then
					if ui_cell_item_utils.can_drop(self.cell_item_selected) then
						ui_cell_item_utils.drop_cell_item(self.cell_item_selected)
						return true
					end
				end
			end
		elseif game_action == key_bindings.kINVENTORY then
			if mode == "inventory" then
				self:Exit()
				return true
			end			
		elseif quick_action[game_action] then
			if self.cell_item_selected then
				local item = self.cell_item_selected:GetAnyItem()
				local item_sect = item:section()
				if read_if_exists(sys_ini, "bool", item_sect, "quick_slot", false) then
					local slot_num = game_action - key_bindings.kQUICK_SLOT_0
					quick_slots.set_item(item_sect, slot_num)
					return true
				end
			end
		elseif dik == DIK_keys.DIK_X then
			if self.cell_item_selected then
				local item = self.cell_item_selected:GetAnyItem()
				if service_kit.can_disassemble(item) then
					service_kit.disassemble(item)
					return true
				end
			end
		elseif dik == DIK_keys.DIK_R then
			if self.cell_item_selected then
				local item = self.cell_item_selected:GetAnyItem()
				if ui_repair.can_repair(item) then
					ui_repair.create_overlay(item)
					return true
				end
			end			
		end
	end
	return self.key_accels[dik]
end

function ActorMenuOverlay:StopAnyMove()
	CUIScriptWnd.StopAnyMove(self)
	return false--self:GetMode() ~= "inventory"
end

function ActorMenuOverlay:ShowPropertiesBox(item, cell_item)
	local item = cell_item:GetAnyItem()
	local cell_item = cell_item
	
	local pbox = self.properties_box
	
	pbox:Clear()
	
	--//move to slot
	ui_cell_item_utils.add_move_to_slot(pbox, item)
	--//move to belt
	ui_cell_item_utils.add_move_to_belt(pbox, item)
	--//move to ruck
	ui_cell_item_utils.add_move_to_ruck(pbox, item)
	--//eat
	ui_cell_item_utils.add_eat(pbox, item)
	--//play music
	ui_cell_item_utils.add_play_music(pbox, item)
	--//deploy landmine
	ui_cell_item_utils.add_deploy_landmine(pbox, item)
	--//deploy rc explosive
	ui_cell_item_utils.add_deploy_rc_explosive(pbox, item)
	--//set quick slot
	ui_cell_item_utils.add_set_quick_slot(pbox, item)
	--//to loadout
	ui_cell_item_utils.add_to_loadout(pbox, item)
	--//from loadout
	ui_cell_item_utils.add_from_loadout(pbox, item)
	--//service
	ui_cell_item_utils.add_service(pbox, item)
	--//reload weapon
	ui_cell_item_utils.add_reload_weapon(pbox, cell_item)	
	--//unload weapon
	ui_cell_item_utils.add_unload_weapon(pbox, cell_item)
	--//attach addon
	ui_cell_item_utils.add_attach_addon(pbox, cell_item)	
	--//detach addon
	ui_cell_item_utils.add_detach_addon(pbox, cell_item)
	--//download info
	ui_cell_item_utils.add_download_info(pbox, item)
	--//attach power source
	ui_cell_item_utils.add_attach_power_source(pbox, cell_item)
	--//detach power source
	ui_cell_item_utils.add_detach_power_source(pbox, cell_item)
	--//attach armor plate
	ui_cell_item_utils.add_attach_armor_plate(pbox, item)
	--//detach armor plate
	ui_cell_item_utils.add_detach_armor_plate(pbox, cell_item)
	--//activate glowstick
	ui_cell_item_utils.add_activate_glowstick(pbox, item)		
	--//move to carbody
	ui_cell_item_utils.add_move_to_carbody(pbox, cell_item)
	--//move to trade
	ui_cell_item_utils.add_move_to_trade(pbox, cell_item)
	--//donate
	ui_cell_item_utils.add_donate(pbox, cell_item)
	--//donate
	ui_cell_item_utils.add_repair(pbox, item)	
	--//saw off
	ui_cell_item_utils.add_saw_off(pbox, item)
	--//disassemble
	ui_cell_item_utils.add_disassemble(pbox, cell_item)
	--//unpack loot spawn box
	ui_cell_item_utils.add_unpack_loot_spawn_box(pbox, item)	
	--//inspect artefact
	ui_cell_item_utils.add_item_inspect(pbox, item)
	--//item info
	ui_cell_item_utils.add_info(pbox, item)
	--//item custom info
	ui_cell_item_utils.add_custom_info(pbox, item)
	--//weapon addon info
	ui_cell_item_utils.add_wpn_addon_info(pbox, item)
	--//drop item
	ui_cell_item_utils.add_drop(pbox, cell_item)
	--//debug item action
	ui_cell_item_utils.add_debug_action(pbox, item)	
	
	--pbox:AddCustomAction(item)
	if pbox:Activate() then
		self:PlayActionSound("properties")
	end
end

function ActorMenuOverlay:GetCellItem(item)
	local ci = self.ruck_list:FindItem(item)
	if ci then
	return ci end
	ci = self.belt_list:FindItem(item)
	if ci then
	return ci end
	ci = self.loadout_list:FindItem(item)
	if ci then
	return ci end	
	for i,list in pairs(self.slot_list) do
		ci = list:FindItem(item)
		if ci then
		return ci end
	end
	if self.target_list:IsShown() then
		ci = self.target_list:FindItem(item)
		if ci then
		return ci end
	end
	if self:GetMode() == "trade" then
		ci = self.buy_list:FindItem(item)
		if ci then
		return ci end
		ci = self.sell_list:FindItem(item)
		if ci then
		return ci end
	end
	return nil
end

function ActorMenuOverlay:UpdatePrices()
	if self:GetMode() ~= "trade" then
	return end
	
	self.sell_buy_back:SetText("")
	self.money_from_actor = nil
	self.money_to_actor = nil
	
	local total_price = 0
	local item = nil
	local text, color
	
	for cell_item,v in pairs(self.buy_list:GetCellItems()) do
		for id,v in pairs(cell_item:GetChilds()) do
			item = level.object_by_id(id)
			total_price = total_price + trade_manager.get_trade_cost(item)
		end
		item = cell_item:GetItem()
		total_price = total_price + trade_manager.get_trade_cost(item)
	end
	
	self.money_from_actor = total_price
	text = string.format("%s %s", total_price, game.translate_string("ui_st_money_regional"))
	if total_price > 0 then
		text = "-"..text
	end
	self.buy_cost:SetText(text)
	self.buy_cost:Show(total_price ~= 0)
	
	total_price = 0
	item = nil
	for cell_item,v in pairs(self.sell_list:GetCellItems()) do
		for id,v in pairs(cell_item:GetChilds()) do
			item = level.object_by_id(id)
			total_price = total_price + trade_manager.get_trade_cost(item)
		end
		item = cell_item:GetItem()
		total_price = total_price + trade_manager.get_trade_cost(item)
	end
	
	self.money_to_actor = total_price
	text = string.format("%s %s", total_price, game.translate_string("ui_st_money_regional"))
	if total_price > 0 then
		text = "+"..text
	end	
	self.sell_cost:SetText(text)
	self.sell_cost:Show(total_price ~= 0)

	color = (self.money_from_actor > actor:money() + self.money_to_actor) and GetARGB(255, 255, 0, 0) or self.buy_cost.base_color
	self.buy_cost:SetTextColor(color)
	color = (self.money_to_actor > self.target:money() + self.money_from_actor) and GetARGB(255, 255, 0, 0) or self.sell_cost.base_color
	self.sell_cost:SetTextColor(color)
	
	self.trade_button:Enable((self.money_from_actor > 0 or self.money_to_actor > 0) and self.money_from_actor <= actor:money() + self.money_to_actor and self.money_to_actor <= self.target:money() + self.money_from_actor)	
	
	self:PlayActionSound("to_ruck")
end

function ActorMenuOverlay:PlayActionSound(name)
	local snd = self.action_sounds[name]
	if not snd then
		log_news("![%s]: action sound name [%s] not found in self.sounds", script_name(), name)
	return end
	snd:play(actor, 0, sound_object.s2d)
end

function ActorMenuOverlay:PlayOperateSound(item)
	local sound_type = read_if_exists(sys_ini, "string", item:section(), "inv_operate_snd_type", "generic")
	local sound_data = self.operate_sounds[sound_type]
	if not sound_data then
		log_news("!%s - operate sound type [%s] not found in self.operate_sounds", script_name(), sound_type)
	return end
	local sound_name = sound_data.sound_name
	if sound_data.rnd_count then
		sound_name = sound_name..math.random(1, tonumber(sound_data.rnd_count))
	end
	local snd = xr_sound.get_safe_sound_object(sound_name)
	snd:play(actor, 0, sound_object.s2d)
end

function ActorMenuOverlay:UpdateInvTip(cell_item)
	local item = cell_item and cell_item:GetAnyItem()
	local text = ""
	if self:GetMode() == "inventory" and item then
		text = game.translate_string(read_if_exists(sys_ini, "string", item:section(), "selected_tip", ""))		
		if read_if_exists(sys_ini, "bool", item:section(), "quick_slot", false) then
			text = text.."\\n"..game.translate_string("st_tip_quick_slot")
		end
		if service_kit.can_disassemble(item) then
			text = text.."\\n"..game.translate_string("st_tip_disassembly")
		end
		if pda.can_try_hack(item) then
			text = text.."\\n"..game.translate_string("st_tip_hack_pda")
		end
		if ui_repair.can_repair(item) then
			text = text.."\\n"..game.translate_string("st_tip_repair")
		end
		if glowstick.can_be_activated(item) then
			text = text.."\\n"..game.translate_string("st_tip_activate_glowstick")
		end		
	end
	self.selected_item_tip:SetText(text)
end

function ActorMenuOverlay:UpdateRepair(cell_item)
	if self:GetMode() ~= "repair" then
	return end
	
	self.repair_button:SetText(game.translate_string("ui_st_repair"))
	self.repair_button:Enable(false)
	
	local item = cell_item and cell_item:GetAnyItem()
	
	local can_action = item and (self.repair:RepairAllowed(item) or self.repair:HackAllowed(item))
	
	if not can_action then
		self.repair_item:Show(false)
		self.repair_back:SetText("")
		self.repair_item_back:SetText("")
		self.repair_condition_progress:Show(false)
		self.repair_condition:Show(false)
	return end
	
	self.repair_item:Show(true)
	
	local is_hack = self.repair:HackAllowed(item)
	self.repair_button:SetText(game.translate_string(is_hack and "ui_st_hack" or"ui_st_repair"))
	
	local icon_sect = read_if_exists(sys_ini, "string", item:section(), "repair_icon_sect", item:section())
	local params = CIconParams(icon_sect)
	--params:set_shader(self.repair_item)
	SetCellIcon(self.repair_item, params)
	ui_inv_utils.CellItemFitToSize(params, self.repair_item, self.repair_item_back)
	local offset = ui_inv_utils.GetOffset("center", self.repair_item, self.repair_item_back)
	self.repair_item:SetWndPos(offset.x, offset.y)
	
	local has_money = self.repair:HasMoneyToRepair(item)
	if is_hack then 
		has_money = self.repair:HasMoneyToHack(item)
	end
	local color = has_money and "%c[default]" or "%c[red]"
	
	--log3("has_money %s",has_money)
	
	local text = string.format("%s%s %s %s", color, game.translate_string(is_hack and "ui_inv_hack_cost" or "ui_inv_repair_cost"), is_hack and self.repair:GetHackCost(item) or self.repair:GetRepairCost(item), game.translate_string("ui_st_money_regional"))
	self.repair_item_back:SetText(text)
	text = get_inv_name(item:section())
	self.repair_back:SetText(text)

	ui_inv_utils.AttachRepairMenuIcons(item, self.repair_item)
	
	local cond = item:condition()
	self.repair_condition_progress:Show(cond < 1)
	self.repair_condition:Show(cond < 1)
	if self.repair_condition_progress:IsShown() then
		--self.repair_condition_progress:SetWidth(self.repair_item:GetWidth())
		self.repair_condition_progress:SetProgressPos(cond)
		local cond_text = string.format("%.f%s", cond*100, "%")
		self.repair_condition:SetText(cond_text)
	end
	
	self.repair_button:Enable(has_money)
end

function ActorMenuOverlay:PerformRepair()
	local cell_item = self.cell_item_selected
	if not cell_item then
	return end
	local item = cell_item:GetAnyItem()
	
	local is_hack = self.repair:HackAllowed(item)
	local cost = is_hack and self.repair:GetHackCost(item) or self.repair:GetRepairCost(item)
	
	dialogs.relocate_money(self.target, cost, "out")
	--item:set_condition(1)
	--cell_item:ForceUpdate()
	
	if not is_hack then
		item:set_condition(1)
		local sound_name = item:is_weapon() and "repair_weapon" or "repair_armor"
		self:PlayActionSound(sound_name)
	else
		pda.on_pda_hack(item:id())
	end
	
	self.cell_item_selected = nil
	--self:UpdateRepair()
	self:ReinitLists()
	self:UpdateCharInfos()
end

function ActorMenuOverlay:ShowRepairRequest()
	local cell_item = self.cell_item_selected
	if not cell_item then
	return end
	local item = cell_item:GetAnyItem()
	
	if not self.repair:CanRepair(item) then
	return end
	
	local repair_msg_box = ui_message_box.MessageBoxWnd()
	local msg_text = string.format(
		"%s %s\\n%s %s %s ?", 
		game.translate_string("st_repair_item"), 
		get_inv_name(item:section()), 
		game.translate_string("st_repair_pay"), 
		self.repair:GetRepairCost(item),
		game.translate_string("ui_st_money_regional")
		)
	repair_msg_box:InitAction(msg_text, function() self:PerformRepair() end)
end

function ActorMenuOverlay:SetUseAnimProgres(item, use_delay, anm_length)
	if not use_delay then
		self.use_anim:Show(false)
		self.selected_item_tip:SetText("")
	else
		self.use_anim:Show(true)
		self.selected_item_tip:SetText(game.translate_string("st_key_to_stop_anim"))
		
		local cell_item = self:GetCellItem(item)
		if cell_item then
			local rect = Frect()
			cell_item:GetAbsoluteRect(rect)
			local pos = vector2():set(rect.x1, rect.y1)
			pos.x = pos.x + (cell_item:GetWidth() - self.use_anim:GetWidth()) * 0.5
			pos.y = pos.y + (cell_item:GetHeight() - self.use_anim:GetHeight()) * 0.5
			self.use_anim:SetWndPos(pos.x, pos.y)
		end
		
		local end_time = time_global() + use_delay
		level.add_call(
			function()
				local val = math.clamp((end_time - time_global()) / use_delay, 0, 1)
				val = 1 - val
				self.use_anim.progress:SetPos(val)
				return val >= 1 or not self.use_anim:IsShown()
			end,
			function()
			end		
		)
	end
end

function ActorMenuOverlay:OnHudStateSwitch(item, state, old_state)
	if state == global_flags.eReload then
		--log_news("~%s start reloading", item:name())
	elseif old_state == global_flags.eReload then
		--log_news("~%s finish reloading", item:name())
	end
end