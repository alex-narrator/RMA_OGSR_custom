-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\repair_overlay.xml"

class "RepairOverlay" (CUIScriptWnd)

local overlay = nil
local repair_sound_weapon = [[interface\inv_repair_kit_use_fast]]
local repair_sound_armor = [[interface\inv_repair_sewing_kit_fast]]

function create_overlay(condition_limit, cost_k, uniquie_k, armor_repair_infop)
	if not condition_limit then
		condition_limit = 1
	end
	if not cost_k then
		cost_k = 1
	end
	if not uniquie_k then
		uniquie_k = 1
	end
	if not overlay then
		overlay = RepairOverlay()		
		overlay:SetRepairParams(condition_limit, cost_k, uniquie_k, armor_repair_infop)
		overlay:Reinit()
	end
end

function is_hidden()
	return not overlay or not overlay:IsShown()
end

function RepairOverlay:__init(owner) super()
	self.owner = level.main_input_receiver()
	self:InitControls()
	self:Subscribe()
	ogse_signals.get_mgr():call("on_repair_show")
	self.owner:FindChild("---UIQuestionsList"):Show(false)
	self.owner:FindChild("---UIAnswersList"):Show(false)
end

function RepairOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			{signal = "on_dialog_show", self = self, fun = self.DetachWnd},
			{signal = "on_dialog_hide", self = self, fun = self.DetachWnd},
			{signal = "on_talk_show", self = self, fun = self.DetachWnd},
			{signal = "on_talk_hide", self = self, fun = self.DetachWnd},
			{signal = "on_trade_show", self = self, fun = self.DetachWnd},
			{signal = "on_trade_hide", self = self, fun = self.DetachWnd},
			{signal = "on_cell_item_select", self = self, fun = self.SetSelectedItem},
			{signal = "on_cell_item_dbclick", self = self, fun = self.ShowRepairRequest},
		}
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function RepairOverlay:Unsubscribe()
	if self.subscribed then
		local sm = ogse_signals.get_mgr()
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function RepairOverlay:DetachWnd()
	quick_slots.set_selected(nil)
	self:Unsubscribe()
	self:ClearCallbacks()
	self.owner:DetachChild(self)
	self.cell_container:DetachWnd()
	overlay = nil
	ogse_signals.get_mgr():call("on_repair_hide")
	self.owner:FindChild("---UIQuestionsList"):Show(true)
	self.owner:FindChild("---UIAnswersList"):Show(true)
end

function RepairOverlay:InitControls()
	self.owner:AttachChild(self)
	self:Init(0, 0, 1024, 768)
	self:Enable(true)
	self:Show(true)
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)

	local name
	
	self.repair_back = xml:InitStatic("repair_back", self)
	
	xml:InitAutoStaticGroup("repair_back:auto_static", self.repair_back)
	
	self.selected_item_back = xml:InitStatic("repair_back:selected_item_back", self.repair_back)
	self.repair_cost 		= xml:InitStatic("repair_back:repair_cost", self.repair_back)
	
	self.actor_money = xml:InitStatic("repair_back:actor_money", self.repair_back)
	
	self.repair_button = xml:Init3tButton("repair_back:repair_button", self.repair_back)
	name = "repair_button"
	self:Register(self.repair_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.ShowRepairRequest, self)
	
	self.exit_button = xml:Init3tButton("repair_back:exit_button", self.repair_back)
	name = "exit_button"
	self:Register(self.exit_button, name)
	self:AddCallback(name, ui_events.BUTTON_CLICKED, self.DetachWnd, self)
	
	self.cell_container = ui_cell_item_container.UICellItemContainer(xml, "repair_back:cell_container_repair", self.repair_back)
end

function RepairOverlay:Update()
	CUIScriptWnd.Update(self)
end

function RepairOverlay:Reinit()
	self.selected_item_back:SetText("")
	self.selected_item_back:DetachAll()
	self.repair_cost:Show(false)
	self.repair_button:Enable(false)
	self:InitItemsList()
	self.actor_money:SetText(string.format("%s: %s %s", game.translate_string("ui_inv_money"), actor:money(), game.translate_string("ui_st_money_regional")))
end

function RepairOverlay:InitItemsList()
	local cell_item, params, name
	
	self.selected_item_id = nil
	
	local items = {}
	function perform_action(dummy, item)
		if self:RepairAllowed(item) then
			table.insert(items, item)
		end
	end
	actor:iterate_inventory(perform_action, nil)
	
	self.cell_container:Reinit()
	table.sort(items, ui_inv_utils.sort_items)
	for k,item in ipairs(items) do
		self.cell_container:AddItem(item)
	end
end

function RepairOverlay:SetSelectedItem(item)
	if item:id() == self.selected_item_id then
	return end
	self.selected_item_id = item:id()
	self.selected_item_back:DetachAll()
	local icon = ui_cell_item.UICellItem(item,1,self.selected_item_back)
	icon:SetScaleToWnd(self.selected_item_back)
	icon:SetOffsetToWnd(self.selected_item_back, "center")
	icon:SetUpdatable(false)
	ui_inv_utils.AttachRepairMenuIcons(item, icon:GetIcon())
	self.selected_item_back:SetText(game.translate_string(get_inv_name(item:section())))
	self:UpdateRepairInfo()
end

function RepairOverlay:UpdateRepairInfo()
	local cost_text
	local color = self:HasMoneyToRepairItem(self.selected_item_id) and "%c[default]" or "%c[red]"
	cost_text = string.format("%s%s %s %s", 
								color,
								game.translate_string("ui_inv_repair_cost"), 
								self:GetRepairCost(self.selected_item_id), 
								game.translate_string("ui_st_money_regional"))
	self.repair_cost:SetText(cost_text)
	self.repair_cost:Show(true)
	self.repair_button:Enable(self:CanRepairItem(self.selected_item_id))
	
end

function RepairOverlay:SetRepairParams(condition_limit, cost_k, uniquie_k, armor_repair_infop)
	self.condition_limit = condition_limit
	self.cost_k = cost_k
	self.uniquie_k = uniquie_k
	self.repair_armor = (not armor_repair_infop or has_alife_info(armor_repair_infop))
	--log3("armor_repair_infop %s, self.repair_armor %s", armor_repair_infop and armor_repair_infop or "NONE", self.repair_armor)
end

function RepairOverlay:NeedRepairItem(id)
	--log3("item %s | condition %s | cond_limit %s", level.object_by_id(id):name(), level.object_by_id(id):condition(), self.condition_limit)
	return level.object_by_id(id):condition() < self.condition_limit
end

function RepairOverlay:HasMoneyToRepairItem(id)
	return actor:money() >= self:GetRepairCost(id)
end

function RepairOverlay:RepairAllowed(item)
	local outfit_item = item:is_outfit() or item:is_helmet() or item:get_container()
	local item_allowed = item:is_weapon() or (outfit_item and self.repair_armor)
	return item_allowed and self:NeedRepairItem(item:id())
end

function RepairOverlay:CanRepairItem(id)
	return self:NeedRepairItem(id) and self:HasMoneyToRepairItem(id)
end

function RepairOverlay:GetRepairCost(id)
	local item = level.object_by_id(id)
	local item_cost = item:cost() * self.cost_k
	local item_corruption = 1 - item:condition()
	local unique_k = read_if_exists(sys_ini, "r_bool", item:section(), "unique_item", false) and self.uniquie_k or 1
	return math.floor(item_cost * item_corruption * unique_k)
end

function RepairOverlay:ShowRepairRequest()
	if not self:CanRepairItem(self.selected_item_id) then
	return end
	local repair_msg_box = ui_message_box.MessageBoxWnd()
	local msg_text = string.format(
		"%s %s\\n%s %s %s ?", 
		game.translate_string("st_repair_item"), 
		game.translate_string(get_inv_name(level.object_by_id(self.selected_item_id):section())), 
		game.translate_string("st_repair_with"), 
		self:GetRepairCost(self.selected_item_id),
		game.translate_string("ui_st_money_regional")
		)
	repair_msg_box:InitAction(msg_text, function() self:Repair() end)
end

function RepairOverlay:Repair()
	dialogs.relocate_money(level.get_second_talker(), self:GetRepairCost(self.selected_item_id), "out")
	local item = level.object_by_id(self.selected_item_id)
	item:set_condition(1)
	self:UpdateRepairInfo()
	
	local sound = item:is_weapon() and repair_sound_weapon or repair_sound_armor
	xr_sound.get_safe_sound_object(sound,sound_object.s3d):play_at_pos(level.get_second_talker(),level.get_second_talker():position())
	
	self:Reinit()
end