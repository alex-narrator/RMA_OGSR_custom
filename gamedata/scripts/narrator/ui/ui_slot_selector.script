-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\slot_selector_overlay.xml"

local subscribed = false
local sm = ogse_signals.get_mgr()

local color_default = GetARGB(0, 255, 255, 255)
local color_focused = GetARGB(255, 255, 255, 0)
local color_defaul_compat = GetARGB(255, 255, 255, 255)

class "SlotSelectorOverlay" (CUIScriptWnd)

function SlotSelectorOverlay:__init() super()
	self:InitControls()
end

function SlotSelectorOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
		}
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function SlotSelectorOverlay:Unsubscribe()
	if self.subscribed then
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function SlotSelectorOverlay:InitControls()
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)

	self:DetachAll()
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	local name
	--//background
	self.back = xml:InitStatic("background", self)
	xml:InitAutoStaticGroup("background:auto_static", self.back)
	
	self.offset = xml:ReadAttrib("background", "offset", "center")
	local pos = ui_inv_utils.GetOffset(self.offset, self.back, self)
	self.back:SetWndPos(pos.x, pos.y)
	
	self.service_back = CUIStatic()
	self.service_back:Init(0, 0, self.back:GetWidth(), self.back:GetHeight())
	self.back:AttachChild(self.service_back)
	
	self.menu_time_factor = xml:ReadAttribFlt("background", "menu_time_factor", 1)
	self.slot_icon_scale = xml:ReadAttribFlt("background", "icon_scale", 1)
	self.slot_icon_indent = xml:ReadAttribFlt("background", "icon_indent", 10)

	self.slot_back_texture = xml:ReadAttrib("background", "back_texture", "ui_inv_back_gray")

	local slot_list = split_string(xml:ReadAttrib("background", "slots", ""), ",", true)
	
	local root = "background:"
	
	self.slots = {}
	for _,i in pairs(slot_list) do
		self.slots[i] = {}
		local path = root.."slot_"..i
		local static = xml:InitStatic(path, self.back)
		self.slots[i].static = static
		name = "slot_"..i
		
		self:Register(static, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnSlotFocusReceived(i) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnSlotFocusLost(i) end)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnSlotClick(i) end)
		
		local back = CUIStatic()
		local size = vector2():set(static:GetWidth() * self.slot_icon_scale, static:GetHeight() * self.slot_icon_scale)
		back:Init(0, 0, size.x, size.y)
		local offset = ui_inv_utils.GetOffset("center", back, static)
		back:SetWndPos(offset.x, offset.y)
		self.slots[i].static.back = back
		static:AttachChild(back)
		back:InitTexture(self.slot_back_texture)
		back:SetStretchTexture(true)
	end
	
	self.quick_slots_back = xml:InitStatic(root.."quick_slots", self.back)
	self.quick_slots_back_texture = xml:ReadAttrib(root.."quick_slots", "back_texture", "ui_inv_back_gray")
	self.quick_slot_icon_scale = xml:ReadAttribFlt(root.."quick_slots", "icon_scale", 1)
	
	self.quick_slots = {}
	for i=0,3 do
		self.quick_slots[i] = {}
		local path = root.."quick_slots:slot_"..i
		local static = xml:InitStatic(path, self.quick_slots_back)
		self.quick_slots[i].static = static
		
		name = "quick_slot_"..i
		
		self:Register(static, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnQuickFocusReceived(i) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnQuickFocusLost(i) end)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnQuickClick(i) end)
		
		local back = CUIStatic()
		local size = vector2():set(static:GetWidth() * self.quick_slot_icon_scale, static:GetHeight() * self.quick_slot_icon_scale)
		back:Init(0, 0, size.x, size.y)
		local offset = ui_inv_utils.GetOffset("center", back, static)
		back:SetWndPos(offset.x, offset.y)
		self.quick_slots[i].static.back = back
		static:AttachChild(back)
		back:InitTexture(self.quick_slots_back_texture)
		back:SetStretchTexture(true)
	end
	
	path = root..":center_tip"
	self.center_tip = xml:InitStatic(path, self.back)
	self.center_tip:Show(false)
end

function SlotSelectorOverlay:Update()
	CUIScriptWnd.Update(self)
	if not actor_hands_free() then
		self:ShowHide()
	end
end

function SlotSelectorOverlay:UpdateSlots()
	if level.is_removing_objects() then
	return end
	
	self.center_tip:Show(false)
	
	self.service_back:DetachAll()
	self.compatible_items = {}
	
	for i,v in pairs(self.slots) do
		local item = actor:item_in_slot(i)
		v.static.back:DetachAll()
		v.static.back:SetColor(color_default)
		if item then
			local params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)
			
			local icon = CUIStatic()
			icon:Init(0, 0, icon_size.x, icon_size.y)			
			
			SetCellIcon(icon, params)
			
			ui_inv_utils.CellItemFitToSize(params, icon, v.static)
			
			local offset = ui_inv_utils.GetOffset("center", icon, v.static.back)
			icon:SetWndPos(offset.x, offset.y)
			ui_inv_utils.AttachPanelIcons(item, icon)
			
			v.static.back:AttachChild(icon)
		end
	end
	
	for i,v in pairs(self.quick_slots) do
		local sect = quick_slots.get_item_sect(i)
		local count = quick_slots.get_item_count(i)
		v.static.back:DetachAll()
		v.static.back:SetColor(color_default)
		local show_icon = sect ~= "" and count > 0
		if show_icon then
			local params = CIconParams(sect)
			local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)

			local icon = CUIStatic()
			icon:Init(0, 0, icon_size.x, icon_size.y)

			SetCellIcon(icon, params)
			
			ui_inv_utils.CellItemFitToSize(params, icon, v.static.back)
			ui_inv_utils.UpdateLayerIcons(sect, icon)
			
			local offset = ui_inv_utils.GetOffset("center", icon, v.static.back)
			icon:SetWndPos(offset.x, offset.y)
			
			local text = ""
			local count = quick_slots.get_item_count(i)
			--if count > 1 then
				text = string.format("x%s", count)
			--end
			icon:SetText(text)
			
			v.static.back:AttachChild(icon)			
		end
	end
end

function SlotSelectorOverlay:OnSlotFocusReceived(slot_num)
	--log3("~OnSlotFocusReceived %s", slot_num)
	local item = actor:item_in_slot(slot_num)
	if not item then
	return end
	
	sm:call("on_cell_item_focus", item)
	
	for i,v in pairs(self.slots) do
		v.static.back:SetColor((i == slot_num) and color_focused or color_default)
	end
	
	self.service_back:DetachAll()
	self.compatible_items = {}	
	
	self:ShowCompatible(slot_num)
	
	self.center_tip:Show(true)
	local action = (slot_num == actor:active_slot()) and "ui_st_hide" or "ui_st_show"
	if slot_num == TORCH_SLOT then
		action = "ui_st_switch"
	end
	if slot_num == DETECTOR_SLOT then
		action = actor:active_device() and "ui_st_hide" or "ui_st_show"
	end
	action = game.translate_string(action)
	local name = get_inv_name_short(item:section())
	local text = string.format("%s\\n%s", action, name)
	self.center_tip:SetText(text)
end

function SlotSelectorOverlay:OnSlotFocusLost(slot_num)
	sm:call("on_cell_item_focus_lost", actor:item_in_slot(slot_num))
	self.slots[slot_num].static.back:SetColor(color_default)
	self.center_tip:Show(false)
end

function SlotSelectorOverlay:OnSlotClick(slot_num)
	local slot_item = actor:item_in_slot(slot_num)
	if slot_num == HELMET_SLOT then
		gasmask.wear_mask(slot_item)
		self:UpdateSlots()
		return
	end
	-- if slot_num == BACKPACK_SLOT and backpack.try_drop() then
		-- --add_update_delayed_action(1, function() self:UpdateSlots() end)	
		-- return
	-- end
	if slot_num == TORCH_SLOT then
		if nvd.get_current_nvd() and nvd.get_current_nvd():id() == slot_item:id() then
			switch_nvd_anim.on_key_press(nil, key_bindings.kNIGHT_VISION)
			return
		end
		if actor_get_torch() and actor_get_torch():id() == slot_item:id() then
			switch_torch_anim.on_key_press(nil, key_bindings.kTORCH)
			return
		end
	end
	local slot = (actor:active_slot() ~= slot_num) and slot_num or NO_ACTIVE_SLOT
	actor:activate_slot(slot, false)
end

function SlotSelectorOverlay:OnQuickFocusReceived(quick_slot_num)
	local item = quick_slots.get_item(quick_slot_num)
	if not item then
	return end
	
	sm:call("on_quick_item_focus", item)
	self.quick_slots[quick_slot_num].static.back:SetColor(color_focused)
	
	self.center_tip:Show(true)
	local action = "ui_st_quick_use"
	action = game.translate_string(action)
	local name = get_inv_name_short(item:section())
	local text = string.format("%s\\n%s", action, name)
	self.center_tip:SetText(text)	
end

function SlotSelectorOverlay:OnQuickFocusLost(quick_slot_num)
	local item = quick_slots.get_item(quick_slot_num)
	if not item then
	return end
	
	sm:call("on_quick_item_focus_lost", item)
	self.quick_slots[quick_slot_num].static.back:SetColor(color_default)
	self.center_tip:Show(false)
end

function SlotSelectorOverlay:OnQuickClick(quick_slot_num)
	local sect = quick_slots.get_item_sect(quick_slot_num)
	if sect ~= "" then
		quick_slots.use_quick_item(quick_slot_num)
	end
end

function SlotSelectorOverlay:ShowCompatible(slot_num)
	--log3("~ShowCompatible %s", slot_num)
	
	self.selected_slot = slot_num
	
	local slot_static = self.slots[slot_num].static
	local base_size = vector2():set(slot_static:GetWidth(), slot_static:GetHeight())
	local pos = slot_static:GetWndPos()
	
	local prev_static
	
	function perform_action(dummy, item)
		local can_set = false
		local slots = item:get_inventory_item().slots
		local id = item:id()
		for k,v in pairs(slots) do
			if v == slot_num then
				can_set = true
				break
			end
		end
		--log3("~check item %s | slots %s", item:name(), slots)
		if can_set then
			--log3("~item %s | slot %s", item:name(), slot_num)
			local name = item:name()..id
			
			local back = CUIStatic()
			local size = vector2():set(slot_static:GetWidth() * self.slot_icon_scale, slot_static:GetHeight() * self.slot_icon_scale)
			back:Init(0, 0, size.x, size.y)
			self.service_back:AttachChild(back)
			back:InitTexture(self.slot_back_texture)
			back:SetStretchTexture(true)
			local table_end = self.compatible_items[#self.compatible_items]
			prev_static = table_end and table_end.static or slot_static			
			local offset = ui_inv_utils.GetOffset("center_down_out", back, prev_static, self.slot_icon_indent)
			pos.x = pos.x + offset.x
			pos.y = pos.y + offset.y
			back:SetWndPos(pos.x, pos.y)
			
			params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)		
			
			local icon = CUIStatic()
			icon:Init(0, 0, icon_size.x, icon_size.y)
			
			ui_inv_utils.CellItemFitToSize(params, icon, back)
			
			SetCellIcon(icon, params)
			ui_inv_utils.AttachPanelIcons(item, icon)

			back:AttachChild(icon)
			
			table.insert(self.compatible_items, {back = back})
			
			local idx = #self.compatible_items
			
			self:Register(back, name)
			
			self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnBeltFocusReceived(id, idx) end)
			self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnBeltFocusLost(id, idx) end)
			self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnBeltClick(id) end)		
		end
	end
	
	actor:iterate_belt(perform_action, nil)
	
	self.loadout_items = {}
	local items = {}
	for id,v in pairs(loadout.get_loaded_items()) do
		local item = level.object_by_id(id)
		ui_inv_utils.try_add_to_list(item, items, true)
	end
	for k,v in pairs(items) do
		local item = v.item
		local id = item:id()
		
		local can_set = false
		local slots = item:get_inventory_item().slots
		for k,v in pairs(slots) do
			if v == slot_num then
				can_set = true
				break
			end
		end
		
		can_set = can_set and item:section() ~= actor:item_in_slot(slot_num)
		
		--log3("~item %s | can_set %s", item:name(), can_set)
		
		if can_set then
			local name = item:name()..id
			
			local back = CUIStatic()
			local size = vector2():set(slot_static:GetWidth() * self.slot_icon_scale, slot_static:GetHeight() * self.slot_icon_scale)
			back:Init(0, 0, size.x, size.y)
			self.service_back:AttachChild(back)
			back:InitTexture(self.slot_back_texture)
			back:SetStretchTexture(true)
			local table_end = self.compatible_items[#self.compatible_items]
			prev_static = table_end and table_end.static or slot_static			
			local offset = ui_inv_utils.GetOffset("center_down_out", back, prev_static, self.slot_icon_indent)
			pos.x = pos.x + offset.x
			pos.y = pos.y + offset.y
			back:SetWndPos(pos.x, pos.y)			
			
			params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx(), params.grid_height * CELL_H)
			
			local icon = CUIStatic()
			icon:Init(0, 0, icon_size.x, icon_size.y)
			
			ui_inv_utils.CellItemFitToSize(params, icon, back)
			
			SetCellIcon(icon, params)
			ui_inv_utils.AttachPanelIcons(item, icon)

			back:AttachChild(icon)
			
			table.insert(self.compatible_items, {back = back})
			
			local idx = #self.compatible_items
			
			self:Register(back, name)

			self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnLoadoutFocusReceived(id, idx) end)
			self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnLoadoutFocusLost(id, idx) end)
			self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnLoadoutClick(id) end)			
		end
	end
end

function SlotSelectorOverlay:OnBeltFocusReceived(id, idx)
	sm:call("on_cell_item_focus", level.object_by_id(id))
	self.compatible_items[idx].back:SetColor(color_focused)
	
	self.center_tip:Show(true)
	local action = "ui_st_compat_to_slot"
	action = game.translate_string(action)
	local name = get_inv_name_short(level.object_by_id(id):section())
	local text = string.format("%s\\n%s", action, name)
	self.center_tip:SetText(text)	
end

function SlotSelectorOverlay:OnBeltFocusLost(id, idx)
	sm:call("on_cell_item_focus_lost", level.object_by_id(id))
	self.compatible_items[idx].back:SetColor(color_defaul_compat)
	self.center_tip:Show(false)
end

function SlotSelectorOverlay:OnBeltClick(id)
	local desired_item = level.object_by_id(id)
	if not desired_item then
	return end
	local slot_item = actor:item_in_slot(self.selected_slot)
	if not slot_item then
	return end
	
	add_update_delayed_action(1,
		function()
			actor:move_to_ruck(slot_item)
			actor:move_to_slot(desired_item)
			actor:activate_slot(self.selected_slot, false)
			actor:move_to_belt(slot_item)		
		end
	)
end

function SlotSelectorOverlay:OnLoadoutFocusReceived(id, idx)
	local item = level.object_by_id(id)
	sm:call("on_cell_item_focus", item)
	self.compatible_items[idx].back:SetColor(color_focused)
	
	self.center_tip:Show(true)
	local action = "ui_st_compat_to_slot"
	action = game.translate_string(action)
	local name = get_inv_name_short(item:section())
	local text = string.format("%s\\n%s", action, name)
	self.center_tip:SetText(text)	
end

function SlotSelectorOverlay:OnLoadoutFocusLost(id, idx)
	local item = level.object_by_id(id)
	sm:call("on_cell_item_focus_lost", item)
	self.compatible_items[idx].back:SetColor(color_defaul_compat)
	self.center_tip:Show(false)
end

function SlotSelectorOverlay:OnLoadoutClick(id)
	local desired_item = level.object_by_id(id)
	if not desired_item then
	return end
	local slot_item = actor:item_in_slot(self.selected_slot)
	if not slot_item then
	return end
	
	add_update_delayed_action(1,
		function()
			actor:move_to_ruck(slot_item)
			actor:move_to_slot(desired_item)
			actor:activate_slot(self.selected_slot, false)
			sm:call("on_grenade_type_switch", slot_item, desired_item)		
		end
	)
end

function SlotSelectorOverlay:ShowHide()
	if not level.main_input_receiver() or self:IsShown() then
		level.start_stop_menu(self,false)
		if self:IsShown() then
			self:OnShow()
		else
			self:OnHide()
		end
	end
end

function SlotSelectorOverlay:ProcessSlowMotion(enable)
	local console = get_console()
	local timefactor = enable and self.menu_time_factor or 1
	console:execute("time_factor "..timefactor)
end

function SlotSelectorOverlay:OnShow()
	self:InitControls()
	self:Subscribe()
	self:UpdateSlots()
	local cursor_pos = vector2():set(UI_BASE_WIDTH * 0.5, UI_BASE_HEIGHT * 0.45)
	level.set_cursor_pos(cursor_pos)
	local act_item = actor:active_item()
	if act_item then		
		act_item:zoom_out()
	end
	self:ProcessSlowMotion(true)
	sm:call("on_slot_selector_show")
end

function SlotSelectorOverlay:OnHide()
	sm:call("on_slot_selector_hide")
	self:Unsubscribe()
	self:ClearCallbacks()
	self:ProcessSlowMotion(false)
end

function SlotSelectorOverlay:StopAnyMove()
	CUIScriptWnd.StopAnyMove(self)
	return false
end

local restricted_actions = {
	[key_bindings.kWPN_FIRE] = true,
	[key_bindings.kWPN_ZOOM] = true,
}

function SlotSelectorOverlay:OnKeyboard(dik, keyboard_action)
	CUIScriptWnd.OnKeyboard(self, dik, keyboard_action)
	
	local game_action = dik_to_bind(dik)
	
	if dik_to_bind(dik) == key_bindings.kQUIT then
		self:OnHide()
	end	
	
	if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		if restricted_actions[game_action] then
			return true
		end
	end

	return false
end