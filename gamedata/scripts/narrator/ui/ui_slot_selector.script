-- -*- mode: lua; coding: windows-1251-dos -*-
local OVERLAY_XML = "script_overlays\\slot_selector_overlay.xml"

local subscribed = false
local sm = ogse_signals.get_mgr()

local color_default = GetARGB(255, 255, 255, 255)
local color_focused = GetARGB(255, 0, 128, 0)

class "SlotSelectorOverlay" (CUIScriptWnd)

function SlotSelectorOverlay:__init() super()
	self:InitControls()
	self:Subscribe()
end

function SlotSelectorOverlay:Subscribe()
	self.subscribed = false
	if not self.subscribed then
		self.subscribed = {
			--{signal = "on_key_release", self = self, fun = self.OnKeyRelease},
			{signal = "on_slot_selector_show", self = self, fun = self.ProcessSlowMotion},
			{signal = "on_slot_selector_hide", self = self, fun = self.ProcessSlowMotion},
			{signal = "on_drop", self = self, fun = self.UpdateSlots},
			{signal = "on_use", self = self, fun = self.UpdateSlots},
		}
		for _, s in ipairs( self.subscribed ) do
			sm:subscribe( s )
		end
	end
end

function SlotSelectorOverlay:Unsubscribe()
	if self.subscribed then
		for _, s in ipairs( self.subscribed ) do
			sm:unsubscribe( s )
		end
		self.subscribed = false
	end
end

function SlotSelectorOverlay:InitControls()
	self:Init(0, 0, UI_BASE_WIDTH, UI_BASE_HEIGHT)
	
	local xml = CScriptXmlInit()
	xml:ParseFile(OVERLAY_XML)
	
	local name
	--//background
	self.back = xml:InitStatic("background", self)
	xml:InitAutoStaticGroup("background:auto_static", self.back)
	
	self.offset = xml:ReadAttrib("background", "offset", "center")
	local pos = ui_inv_utils.GetOffset(self.offset, self.back, self)
	self.back:SetWndPos(pos.x, pos.y)
	
	self.menu_time_factor = xml:ReadAttribFlt("background", "menu_time_factor", 1)

	local slot_list = split_string(xml:ReadAttrib("background", "slots", ""), ",", true)
	
	local root = "background:"
	
	self.slots = {}
	for _,i in pairs(slot_list) do
		self.slots[i] = {}
		local path = root.."slot_"..i
		local static = xml:InitStatic(path, self.back)
		self.slots[i].static = static
		name = "slot_"..i
		
		self:Register(static, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnSlotFocusReceived(i) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnSlotFocusLost(i) end)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnSlotClick(i) end)
		
		path = path..":icon"
		local icon = xml:InitStatic(path, static)
		self.slots[i].icon = icon
		
		self.slots[i].icon_scale = xml:ReadAttribFlt(path, "scale", 1)
		self.slots[i].icon_offset = xml:ReadAttrib(path, "offset", "center")
	end
	
	self.quick_slots_back = xml:InitStatic(root.."quick_slots", self.back)
	
	self.quick_slots = {}
	for i=0,3 do
		self.quick_slots[i] = {}
		local path = root.."quick_slots:slot_"..i
		local static = xml:InitStatic(path, self.quick_slots_back)
		self.quick_slots[i].static = static
		
		name = "quick_slot_"..i
		
		self:Register(static, name)
		self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnQuickFocusReceived(i) end)
		self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnQuickFocusLost(i) end)
		self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnQuickClick(i) end)
		
		path = path..":icon"
		local icon = xml:InitStatic(path, static)
		self.quick_slots[i].icon = icon
		
		self.quick_slots[i].icon_scale = xml:ReadAttribFlt(path, "scale", 1)
		self.quick_slots[i].icon_offset = xml:ReadAttrib(path, "offset", "center")
	end
	
	path = root..":belt_items"
	self.belt_items_back = xml:InitStatic(path, self.back)
	self.belt_items_back:Show(false)
	path = path..":icon"
	self.belt_items_icon = {}
	self.belt_items_icon.scale = xml:ReadAttribFlt(path, "scale", 1)
	self.belt_items_icon.indent = xml:ReadAttribFlt(path, "indent", 1)
	self.belt_items_icon.size = vector2():set(xml:ReadAttribFlt(path, "width", 1), xml:ReadAttribFlt(path, "height", 1))
	self.belt_items_icon.pos = vector2():set(xml:ReadAttribFlt(path, "x", 0), xml:ReadAttribFlt(path, "y", 0))
	
	path = root..":weapon_items"
	self.weapon_items_back = xml:InitStatic(path, self.back)
	self.weapon_items_back:Show(false)
	path = path..":icon"
	self.weapon_items_icon = {}
	self.weapon_items_icon.scale = xml:ReadAttribFlt(path, "scale", 1)
	self.weapon_items_icon.indent = xml:ReadAttribFlt(path, "indent", 1)
	self.weapon_items_icon.size = vector2():set(xml:ReadAttribFlt(path, "width", 1), xml:ReadAttribFlt(path, "height", 1))
	self.weapon_items_icon.pos = vector2():set(xml:ReadAttribFlt(path, "x", 0), xml:ReadAttribFlt(path, "y", 0))	
end

function SlotSelectorOverlay:Update()
	CUIScriptWnd.Update(self)
end

function SlotSelectorOverlay:OnKeyboard( dik, keyboard_action )
	CUIScriptWnd.OnKeyboard( self, dik, keyboard_action )
	-- if keyboard_action == ui_events.WINDOW_KEY_PRESSED then
		-- local action = dik_to_bind(dik)
		-- if action == 
	-- end
	-- return true
end

function SlotSelectorOverlay:UpdateSlots()
	if level.is_removing_objects() then
	return end
	
	for i,v in pairs(self.slots) do
		local item = actor:item_in_slot(i)
		v.static:Show(item)
		if v.static:IsShown() then
			local params = CIconParams(item:section())
			params:set_shader(self.slots[i].icon)
			
			if self.slots[i].icon_scale then
				local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx() * self.slots[i].icon_scale, params.grid_height * CELL_H * self.slots[i].icon_scale)
				self.slots[i].icon:SetWidth(icon_size.x)
				self.slots[i].icon:SetHeight(icon_size.y)
			else
				ui_inv_utils.CellItemFitToSize(params, self.slots[i].icon, self.slots[i].static)
			end
			
			local offset = ui_inv_utils.GetOffset(self.slots[i].icon_offset, self.slots[i].icon, self.slots[i].static)
			self.slots[i].icon:SetWndPos(offset.x, offset.y)
			self.slots[i].icon:SetColor(color_default)
			ui_inv_utils.AttachPanelIcons(item, self.slots[i].icon)
		end
	end
	
	for i,v in pairs(self.quick_slots) do
		local sect = quick_slots.get_item_sect(i)
		local count = quick_slots.get_item_count(i)
		v.icon:Show(sect ~= "" and count > 0)
		if v.icon:IsShown() then
			local params = CIconParams(sect)
			params:set_shader(self.quick_slots[i].icon)
			
			if self.quick_slots[i].icon_scale then
				local icon_size = vector2():set(params.grid_width * CELL_W * get_current_kx() * self.quick_slots[i].icon_scale, params.grid_height * CELL_H * self.quick_slots[i].icon_scale)
				self.quick_slots[i].icon:SetWidth(icon_size.x)
				self.quick_slots[i].icon:SetHeight(icon_size.y)
			else
				ui_inv_utils.CellItemFitToSize(params, self.quick_slots[i].icon, self.quick_slots[i].static)
			end
			
			local offset = ui_inv_utils.GetOffset(self.quick_slots[i].icon_offset, self.quick_slots[i].icon, self.quick_slots[i].static)
			self.quick_slots[i].icon:SetWndPos(offset.x, offset.y)
			self.quick_slots[i].icon:SetColor(color_default)
			
			local text = ""
			local count = quick_slots.get_item_count(i)
			--if count > 1 then
				text = string.format("x%s", count)
			--end
			self.quick_slots[i].icon:SetText(text)
		end
	end
	
	self.belt_items_back:DetachAll()
	self.belt_items_back:Show(false)
	
	self.weapon_items_back:DetachAll()
	self.weapon_items_back:Show(false)	
	
	add_update_delayed_action(1, function() self.quick_slots_back:Show(true) end)
end

function SlotSelectorOverlay:OnSlotFocusReceived(slot_num)
	--log3("~OnSlotFocusReceived %s", slot_num)
	sm:call("on_cell_item_focus", actor:item_in_slot(slot_num))
	
	for i,v in pairs(self.slots) do
		self.slots[i].icon:SetColor((i == slot_num) and color_focused or color_default)
	end
	
	self:ShowCompatible(slot_num)
	local has_compat = table.size(self.belt_items) > 0
	self.belt_items_back:Show(has_compat)
	self:ShowWeapon(slot_num)
	local has_weapon = table.size(self.weapon_items) > 0
	self.weapon_items_back:Show(has_weapon)
	self.quick_slots_back:Show(not has_compat and not has_weapon)
end

function SlotSelectorOverlay:OnSlotFocusLost(slot_num)
	sm:call("on_cell_item_focus_lost", actor:item_in_slot(slot_num))
	
	if not self.belt_items_back:IsShown() then
		self.slots[slot_num].icon:SetColor(color_default)
	end
end

function SlotSelectorOverlay:OnSlotClick(slot_num)
	local slot_item = actor:item_in_slot(slot_num)
	if slot_num == HELMET_SLOT then
		gasmask.wear_mask(slot_item)
		self:UpdateSlots()
		return
	end
	if slot_num == BACKPACK_SLOT and backpack.try_drop() then
		--add_update_delayed_action(1, function() self:UpdateSlots() end)	
		return
	end
	if slot_num == TORCH_SLOT then
		if nvd.get_current_nvd() and nvd.get_current_nvd():id() == slot_item:id() then
			switch_nvd_anim.on_key_press(nil, key_bindings.kNIGHT_VISION)
			return
		end
		if actor_get_torch() and actor_get_torch():id() == slot_item:id() then
			switch_torch_anim.on_key_press(nil, key_bindings.kTORCH)
			return
		end
	end
	local slot = (actor:active_slot() ~= slot_num) and slot_num or NO_ACTIVE_SLOT
	actor:activate_slot(slot, false)
end

function SlotSelectorOverlay:OnQuickFocusReceived(quick_slot_num)
	sm:call("on_quick_item_focus", quick_slots.get_item(quick_slot_num))
	self.quick_slots[quick_slot_num].icon:SetColor(color_focused)
end

function SlotSelectorOverlay:OnQuickFocusLost(quick_slot_num)
	sm:call("on_quick_item_focus_lost", quick_slots.get_item(quick_slot_num))
	self.quick_slots[quick_slot_num].icon:SetColor(color_default)
end

function SlotSelectorOverlay:OnQuickClick(quick_slot_num)
	local sect = quick_slots.get_item_sect(quick_slot_num)
	if sect ~= "" then
		quick_slots.use_quick_item(quick_slot_num)
		self:UpdateSlots()
	end
end

function SlotSelectorOverlay:ShowCompatible(slot_num)
	--log3("~ShowCompatible %s", slot_num)
	
	self.selected_slot = slot_num

	local item, params, back_st, item_st, text
	
	self.belt_items_back:DetachAll()
	self.belt_items = {}
	
	local orig_pos = self.belt_items_icon.pos
	local pos = vector2():set(orig_pos.x, orig_pos.y)
	for i = 0, actor:belt_count() - 1 do
		local can_set = false
		item = actor:item_on_belt(i)
		local slots = item:get_inventory_item().slots
		for k,v in pairs(slots) do
			if v == slot_num then
				can_set = true
				break
			end
		end
		--log3("~check item %s | slots %s", item:name(), slots)
		if can_set then
			--log3("~item %s | slot %s", item:name(), slot_num)
			local name = "compatible_"..i
			
			params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * CELL_W * self.belt_items_icon.scale * get_current_kx(), params.grid_height * CELL_H * self.belt_items_icon.scale)
			
			item_st = CUIStatic()
			item_st:Init(pos.x, pos.y, icon_size.x, icon_size.y)
			
			if self.belt_items_icon.scale == 1 then
				ui_inv_utils.CellItemFitToSize(params, item_st, nil, self.belt_items_icon.size)
			end			
			
			params:set_shader(item_st)
			ui_inv_utils.AttachPanelIcons(item, item_st)

			self.belt_items_back:AttachChild(item_st)

			self.belt_items[i] = item_st
			
			pos.x = pos.x + item_st:GetWidth() + self.belt_items_icon.indent
			self:Register(item_st, name)
				
			self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnCompatFocusReceived(i) end)
			self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnCompatFocusLost(i) end)
			self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnCompatClick(i) end)		
		end
	end
end

function SlotSelectorOverlay:OnCompatFocusReceived(idx)
	sm:call("on_cell_item_focus", actor:item_on_belt(idx))
	self.belt_items[idx]:SetColor(color_focused)
end

function SlotSelectorOverlay:OnCompatFocusLost(idx)
	sm:call("on_cell_item_focus_lost", actor:item_on_belt(idx))
	self.belt_items[idx]:SetColor(color_default)
end

function SlotSelectorOverlay:OnCompatClick(idx)
	local desired_item = actor:item_on_belt(idx)
	if not desired_item then
	return end
	local slot_item = actor:item_in_slot(self.selected_slot)
	if not slot_item then
	return end
	
	actor:move_to_ruck(slot_item)
	actor:move_to_slot(desired_item)
	actor:activate_slot(self.selected_slot, false)
	actor:move_to_belt(slot_item)
	
	self:UpdateSlots()
end

function SlotSelectorOverlay:ShowWeapon(slot_num)
	--log3("~ShowCompatible %s", slot_num)
	
	self.selected_slot = slot_num

	local item, params, back_st, item_st, text
	
	self.weapon_items_back:DetachAll()
	self.weapon_items = {}
	
	local slot_item = actor:item_in_slot(slot_num)
	
	local weapon = slot_item:get_weapon()
	
	if not weapon then
	return end
	
	local weapon_m = slot_item:get_weapon_m()
	
	if not weapon_m then
	return end
	
	local orig_pos = self.weapon_items_icon.pos
	local pos = vector2():set(orig_pos.x, orig_pos.y)
	for id,v in pairs(loadout.get_loaded_items()) do
		local can_set = false
		item = level.object_by_id(id)
		
		local ammo_sects = get_ammo_sects(slot_item)
		for k,v in pairs(ammo_sects) do
			if v == item:section() then
				can_set = true
				break
			end
		end
		
		if weapon:addon_attachable(addon.magazine) then
			local magazine_sect = get_magazine_sects(slot_item)
			for k,v in pairs(magazine_sect) do
				if v == item:section() then
					can_set = true
					break
				end
			end
		end	
		
		if weapon:is_addon_attached(addon.launcher) then
			local ammo_sects2 = get_ammo_sects(slot_item)
			for k,v in pairs(ammo_sects2) do
				if v == item:section() then
					can_set = true
					break
				end
			end
		end
		
		local ammo = item:get_weapon_ammo()
		if ammo then
			can_set = can_set and (item:section() ~= get_cur_ammo_sect(slot_item) or item:get_ammo_in_magazine() == 0) and ammo.box_curr > 0
		end
		
		--log3("~check item %s | slots %s", item:name(), slots)
		if can_set then
			--log3("~item %s | slot %s", item:name(), slot_num)
			local name = "weapon_"..id
			
			params = CIconParams(item:section())
			local icon_size = vector2():set(params.grid_width * CELL_W * self.weapon_items_icon.scale * get_current_kx(), params.grid_height * CELL_H * self.weapon_items_icon.scale)
			
			item_st = CUIStatic()
			item_st:Init(pos.x, pos.y, icon_size.x, icon_size.y)
			
			if self.weapon_items_icon.scale == 1 then
				ui_inv_utils.CellItemFitToSize(params, item_st, nil, self.weapon_items_icon.size)
			end
			
			params:set_shader(item_st)
			ui_inv_utils.AttachPanelIcons(item, item_st)

			if ammo and not ammo:is_magazine() then
				local text = string.format("%s", ammo.box_curr)
				item_st:SetText(text)
				
			end

			self.weapon_items_back:AttachChild(item_st)

			self.weapon_items[id] = item_st
			
			pos.x = pos.x + item_st:GetWidth() + self.weapon_items_icon.indent
			self:Register(item_st, name)
				
			self:AddCallback(name, ui_events.STATIC_FOCUS_RECEIVED, function() self:OnWeaponFocusReceived(id) end)
			self:AddCallback(name, ui_events.STATIC_FOCUS_LOST, function() self:OnWeaponFocusLost(id) end)
			self:AddCallback(name, ui_events.WINDOW_LBUTTON_DOWN, function() self:OnWeaponClick(id) end)		
		end
	end
end

function SlotSelectorOverlay:OnWeaponFocusReceived(id)
	local item = level.object_by_id(id)
	sm:call("on_cell_item_focus", item)
	self.weapon_items[id]:SetColor(color_focused)
end

function SlotSelectorOverlay:OnWeaponFocusLost(id)
	local item = level.object_by_id(id)
	sm:call("on_cell_item_focus_lost", item)
	self.weapon_items[id]:SetColor(color_default)
end

function SlotSelectorOverlay:OnWeaponClick(id)
	local item = level.object_by_id(id)
	local weapon = actor:item_in_slot(self.selected_slot)
	
	if actor:active_slot() ~= self.selected_slot then
		actor:activate_slot(self.selected_slot, false)
		level.add_call(
			function()
				return actor:active_slot() == self.selected_slot
			end,
			function()
				weapon:is_direct_reload(item)
			end
		)
	else
		weapon:is_direct_reload(item)
	end
end

function SlotSelectorOverlay:TrySignalHide()
	if self.was_shown and not self:IsShown() then
		sm:call("on_slot_selector_hide")
	end
end

function SlotSelectorOverlay:ShowHideSelector()
	if not level.main_input_receiver() or self:IsShown() then
		level.start_stop_menu(self,false)
		self.was_shown = self:IsShown()
		if self.was_shown then
			self:UpdateSlots()
			sm:call("on_slot_selector_show")
		else
			sm:call("on_slot_selector_hide")
		end
	end
end

function SlotSelectorOverlay:ProcessSlowMotion()
	local console = get_console()
	local timefactor = self:IsShown() and self.menu_time_factor or 1
	console:execute("time_factor "..timefactor)
end