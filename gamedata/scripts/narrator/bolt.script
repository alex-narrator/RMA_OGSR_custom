-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_spawn",   			fun = this.on_spawn})
	sm:subscribe({signal = "on_first_update",   	fun = this.on_first_update})
	sm:subscribe({signal = "on_take",   			fun = this.on_take})
	sm:subscribe({signal = "on_drop",   			fun = this.on_drop})
	sm:subscribe({signal = "on_hud_state_switch",   fun = this.on_state_switch})
	sm:subscribe({signal = "on_key_press",   		fun = this.on_key_press})
end

local LIMITED_BOLTS = read_if_exists(sys_ini, "r_bool", "features", "limited_bolts", false)

local bolts = {}

function on_spawn()
	bolts = {}
end

function on_first_update()
	if not LIMITED_BOLTS and not actor_get_bolt() then
		alife():create("bolt", actor:position(), actor:level_vertex_id(), actor:game_vertex_id(), actor:id())
	end
end

function on_take(item)
	if get_clsid(item) == clsid.obj_bolt then
		log3("~take bolt %s id %s", item:name(), item:id())
		bolts[item:id()] = true
	end
end

function on_drop(item, prev_place)
	if bolts[item:id()] then
		bolts[item:id()] = nil
	end
end

function on_state_switch(item, state, old_state)
	if not LIMITED_BOLTS or get_clsid(item) ~= clsid.obj_bolt then
	return end
	
	log3("item %s, state %s", item:name(), state)
	
	if state == global_flags.eThrowEnd then--and not actor_get_bolt() then
		local bolt = get_same_bolt(item)
		if not bolt then
			bolt = get_next_bolt()
		end
		if not bolt then
		return end
		
		actor:move_to_ruck(actor_get_bolt())
		log3("~item %s, is new bolt", bolt:name())
		actor:move_to_slot(bolt)
		add_update_delayed_action(1,
			function()
				actor:activate_slot(BOLT_SLOT)
			end
		)
	return end
end

function on_key_press(key, game_action)
	if level.main_input_receiver() or 
		game_action ~= key_bindings.kWPN_NEXT or
		not actor_hands_free() or
		not actor:active_item() or
		get_clsid(actor:active_item()) ~= clsid.obj_bolt
	then
	return end
	
	local new_bolt = get_other_bolt(actor:active_item())
	if new_bolt then
		actor:move_to_ruck(actor_get_bolt())
		actor:move_to_slot(new_bolt)
	end
end

function get_next_bolt()
	for k,v in pairs(bolts) do
		return level.object_by_id(k)
	end
	return nil
end

function get_same_bolt(item)
	local bolt = nil
	for k,v in pairs(bolts) do
		bolt = level.object_by_id(k)
		if (bolt:section() == item:section() and bolt:id() ~= item:id()) then
			return bolt
		end
	end
	return nil
end

function get_other_bolt(item)
	local bolt = nil
	for k,v in pairs(bolts) do
		bolt = level.object_by_id(k)
		if (bolt:section() ~= item:section()) then
			return bolt
		end
	end
	return nil
end