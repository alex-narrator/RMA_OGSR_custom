-- -*- mode: lua; coding: windows-1251-dos -*-
------------------------------------------------------------------------------------------
--біндер приладів що використовують джерела живлення
------------------------------------------------------------------------------------------

local POWER_CONSUMING_UPDATE_TIME = 10 --//час оновлення декременту у ігрових секундах
local DEF_WORK_TIME = 1
local LOW_POWER_LEVEL = 0.1

function init(obj)
	if not is_power_device(obj) then
		log3("![%s]:init failed to bind object name:[%s] section:[%s] - not a power device\nsee se_item.script for power devices (must have a self.power_level and self.cur_power_sect field)", script_name(), obj:name(), obj:section())
	return end
    local new_binder = device_binder(obj)
    obj:bind_object(new_binder)
end

--послідовність викликів:
--__init
--reload
--load (if save was called before)
--net_spawn

class "device_binder" (object_binder)
function device_binder:__init(obj) super(obj)
	--log3("%s __init for object %s", script_name(), self.object:name())
	self.power_consumption = false
	self.last_update_time = false
	self.t_power_sources = {}
	self.se_obj = alife():object(self.object:id())
	self.b_was_sended = false
end
 
function device_binder:reload(section)
	--log3("%s reload for object %s", script_name(), self.object:name())
    object_binder.reload(self, section)
	
	local power_str = read_if_exists(sys_ini, "r_string", self.object:section(), "power_source", self.object:section())
	self.t_power_sources = self:parse_sorces(power_str)
	
	-- for k,v in pairs(self.t_power_sources) do
		-- log3("device %s power section %s, work_time %s", self.object:section(), v.section, v.work_time )
	-- end
end

function device_binder:parse_sorces(line)
	local t = se_respawn.parse_names(line)
	local ret_table = {}
	local k = 1
	while k <= #t do
		local sources = {}
		sources.section = t[k]
		-- Проверяем что это не последняя запись
		if t[k+1] ~= nil then
			local p = tonumber(t[k+1])
			if p then
				-- забиваем число
				sources.work_time = p
				k = k + 2
			else
				-- забиваем дефолт
				sources.work_time = DEF_WORK_TIME
				k = k + 1
			end
		else
			sources.work_time = DEF_WORK_TIME
			k = k + 1
		end
		table.insert(ret_table, sources)
	end
	return ret_table
end
 
function device_binder:net_spawn(data)
	--log3("%s net_spawn for object %s", script_name(), self.object:name())
    local spawned = object_binder.net_spawn(self, data)

	self:init_power_source()

	return spawned
end

function device_binder:update(delta)
    object_binder.update(self, delta)
	
	if self:is_working() then
		local item = self.object
		--log3("~[%s]: device %s is working now (power %s)", script_name(), item:name(), self:get_power_level())
		--якщо детектор не в худ-режимі - не витрачаємо батарейку
		if item:get_detector() and (not actor:active_item_2() or item:id() ~= actor:active_item_2():id()) then
		return end
		--якщо ПДА не в худ-режимі - не витрачаємо батарейку
		if item:get_pda() and (not actor:active_item() or item:id() ~= actor:active_item():id()) then
		return end
		self:decrease_power()
	end
end
 
function device_binder:init_power_source()
	self.power_consumption = 1 / (self:get_work_time() * 3600)
	self.last_update_time = false
end

function device_binder:is_working()
	return parent_is_actor(self.object) and self.object:is_power_on()
end

function device_binder:decrease_power()
	if self.object:condition() == 0 or self:get_power_level() == 0 then
		if self.object:is_power_on() then
			self.object:switch_power(false)
		end
	return end
	
	local game_time = game.get_game_time()
	
	if not self.last_update_time then
		self.last_update_time = game_time
	end
	
	--log3("%s:decrease_condition self.last_update_time %s : %s for item %s", script_name(), self.last_update_time:dateToString(game.CTime.DateToDay), self.last_update_time:timeToString(game.CTime.TimeToMilisecs), self.object:name())
	--log3("%s:decrease_condition game_time %s : %s for item %s",script_name(), game_time:dateToString(game.CTime.DateToDay), game_time:timeToString(game.CTime.TimeToMilisecs), self.object:name())
	
	local delta_time = game_time:diffSec(self.last_update_time)
	--log3("%s delta_time %s for %s", script_name(), delta_time, self.object:name())
	
	
	if delta_time < POWER_CONSUMING_UPDATE_TIME then
	return end
	
	self.last_update_time = game_time
	
	self:change_power_level(-self.power_consumption * delta_time)
	
	if self:get_power_level() <= LOW_POWER_LEVEL and not self.b_was_sended and not xr_conditions.black_screen() then
		news_manager.item_tip(self.object, "low_power")
		self.b_was_sended = true
	end
end

function device_binder:power_source_detachable()
	return self.t_power_sources[1] ~= self.object:section()
end

function device_binder:can_attach(obj)
	return self:power_source_detachable() and 
		self.object:condition() > 0 and 
		obj:condition() > 0 and 
		self:get_power_sect_num(obj:section())
end

function device_binder:get_power_sect()
	return self.t_power_sources[self.se_obj.cur_power_sect].section
end

function device_binder:get_work_time()
	return self.t_power_sources[self.se_obj.cur_power_sect].work_time
end

function device_binder:set_power_sect(num)
	if num > #self.t_power_sources then
		log3("![%s]: wrong cur_power_sect [%s/%s] for device [%s] - set default battery section", script_name(), num, #self.t_power_sources, self.object:section())
		num = 1
	end
	self.se_obj.cur_power_sect = num
end

function device_binder:get_power_sect_num(section)
	for k, v in pairs(self.t_power_sources) do
		if section == v.section then
			return k
		end
	end
	return false
end

function device_binder:get_power_level()
	return self.se_obj.power_level or 0
end

function device_binder:set_power_level(val)
	if not self.se_obj.power_level then return end
	self.se_obj.power_level = val
	self.se_obj.power_level = math.clamp(self.se_obj.power_level,0,1)
end

function device_binder:change_power_level(val)
	if not self.se_obj.power_level then return end
	self.se_obj.power_level = self.se_obj.power_level + val
	self.se_obj.power_level = math.clamp(self.se_obj.power_level,0,1)
end

function device_binder:recharge(obj_battery)
	if self:can_detach_power_source() then
		self:detach_power_source()
	end
	
	self:set_power_level(obj_battery:condition())
	self:set_power_sect(self:get_power_sect_num(obj_battery:section()))
	self:init_power_source()
	
	alife():release(alife():object(obj_battery:id()), true)
	if not self.object:is_power_on() then
		self.object:switch_power(true)
	end
	
	self.b_was_sended = false
end

function device_binder:can_detach_power_source()
	return self:get_power_level() > 0 and self:power_source_detachable()
end

function device_binder:detach_power_source()
	local parent = self.object:parent()
	local sobj = alife():create(self:get_power_sect(), parent:position(), parent:level_vertex_id(), parent:game_vertex_id(), parent:id())
	local sobj_iitem = alife():object(sobj.id):get_inventory_item()
	sobj_iitem.item_condition = self:get_power_level()
	self:set_power_level(0)
	local detach_sound = read_if_exists(sys_ini, "r_string", self.object:section(), "use_sound", nil)
	if detach_sound then
		xr_sound.get_safe_sound_object(detach_sound,sound_object.s2d):play_at_pos(parent,parent:position())
	end
end