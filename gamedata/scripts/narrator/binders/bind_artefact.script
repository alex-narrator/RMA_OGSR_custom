-- -*- mode: lua; coding: windows-1251-dos -*-
------------------------------------------------------------------------------------------
--біндер артефактів
------------------------------------------------------------------------------------------

local RND_MULT = 100 --//щоб коректно генерувати рандом для значень з десятковими дробами

function can_detect_artefact(artefact)
	if not actor_obj:IsDetectorActive() then
	return false end

	local device_sect = actor:active_device():section()
	if distance_between_safe(actor, artefact) > read_if_exists(sys_ini, "float", device_sect, "af_vis_radius", 2) then
	return false end
	
	local function can_detect_af_sect(af_section, detector_section)
		for i = 1, 255 do
			local af_sect = read_if_exists(sys_ini, "string", detector_section, "af_class_"..i, nil)
			if af_sect and string.find(af_sect, af_section) then
				return true
			end
		end
		return false
	end
	
	return can_detect_af_sect(artefact:section(), device_sect)
end

function init(obj)
    local new_binder = artefact_binder(obj)
    obj:bind_object(new_binder)
end

--послідовність викликів:
--__init
--reload
--load (if save was called before)
--net_spawn

class "artefact_binder" (object_binder)
function artefact_binder:__init(obj) super(obj)
	--log3("%s __init for object %s", script_name(), self.object:name())
	self.se_obj = alife():object(self.object:id())
	
	self.non_taken_particles = read_if_exists(sys_ini, "string", self.object:section(), "non_taken_particles", nil)
end
 
function artefact_binder:net_spawn(data)
	--log3("%s net_spawn for object %s", script_name(), self.object:name())
    local spawned = object_binder.net_spawn(self, data)
	
	--//затичка від випадків коли на момент ініціалізації біндера серверний об'єкт артефакту не існує (трапляється в Прип'яті)
	level.add_call(
		function()
			if not self.se_obj then
				log_news("!%s : artefact %s | id %s has no server object", script_name(), self.object:name(), self.object:id())
				self.se_obj = alife():object(self.object:id())
			end
			return not not self.se_obj
		end,
		function()
			self:fill_random_k()
		end
	)	
	return spawned
end

function artefact_binder:update(delta)
	object_binder.update(self, delta)
	self:update_particles()
end

function artefact_binder:fill_random_k()
	if self.se_obj.random_k == 1 then
		local random_param = read_if_exists(sys_ini, "string", self.object:section(), "random_k", nil)
		if random_param then
			random_param = split_string(random_param, ",", true)
			if table.size(random_param) > 1 then
				self.se_obj.random_k = math.random(random_param[1] * RND_MULT, random_param[2] * RND_MULT) / RND_MULT
			else
				self.se_obj.random_k = math.random(0.1, random_param[1] * RND_MULT) / RND_MULT
			end
		end
	end
	
	if self.se_obj.random_k ~= 1 then
		local iitem = self.object:get_inventory_item()
		for i=0,10 do
			iitem:item_effect(i, iitem:item_effect(i) * self.se_obj.random_k)
			iitem:hit_type_protection(i, iitem:hit_type_protection(i) * self.se_obj.random_k)
		end
		--log3("~artefact %s | random_k %s", self.object:name(), self.se_obj.random_k)
	end
end

function artefact_binder:update_particles()
	if self.non_taken_particles then
		if self.object:parent() or (self.se_obj and self.se_obj.is_taken) then
			if self.particle then
				if self.particle:playing() then
					self.particle:stop()
				end
				self.particle = nil
			end
		else
			if not self.particle then
				self.particle = particles_object(self.non_taken_particles)
			end
			if not can_detect_artefact(self.object) then
				self.particle:stop()
			elseif not self.particle:playing() then
				self.particle:play_at_pos(self.object:center())
			else
				self.particle:move_to(self.object:center(), vector())
			end		
		end
	end
end