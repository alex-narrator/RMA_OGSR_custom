-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_drop",   fun = this.on_drop})
	sm:subscribe({signal = "on_ruck",   fun = this.on_ruck})
	sm:subscribe({signal = "on_take",   fun = this.on_take})
	sm:subscribe({signal = "on_slot",   fun = this.on_slot})
	sm:subscribe({signal = "on_belt",   fun = this.on_belt})
	sm:subscribe({signal = "on_grenade_type_switch",   fun = this.on_grenade_type_switch})
	--sm:subscribe({signal = "on_cell_item_mouse",   	fun = this.try_set_item})
	sm:subscribe({signal = "on_save",   fun = this.on_save})
	sm:subscribe({signal = "on_load",   fun = this.on_load})
	sm:subscribe({signal = "on_first_update",   fun = this.on_first_update})
	sm:subscribe({signal = "on_move_to_marked_list",   fun = this.on_move_to_marked_list})
	sm:subscribe({signal = "on_move_from_marked_list",   fun = this.on_move_from_marked_list})
end

--//loadout slot types and default capacities
local slots = {
	pistol_ammo 	= {},
	rifle_ammo 		= {},
	shotgun_ammo	= {},
	heavy_ammo 		= {},
	grenade			= {},
	medicine 		= {},
}
for k,v in pairs(slots) do
	v.max_count = read_if_exists(sys_ini, "r_u32", "loadout", k, 0)
	v.current_count = 0
end

function log_slots()
	for k,v in pairs(slots) do
		log3("slots k = %s", k)
	end
end

loaded_items = {}

--//функції для рушійних колбеків переміщення в драгдроп-лист маркованих предметів
function on_move_to_marked_list(item)
	if can_add(item) then
		add(item)
	end
end
function on_move_from_marked_list(item)
	if can_remove(item) then
		remove(item)
	end
end

local unload_states = {
	[global_flags.eReload] = true,
	[global_flags.eShutter] = true,
}
function is_weapon_unloading()
	local weapon = actor:active_item() and actor:active_item():get_weapon_m()
	return weapon and unload_states[weapon.state]
end

function on_save(packet)
	--log3("%s on save", script_name())
	local size = table.size(loaded_items)
	packet:w_u8(size)
	--log3("~saving size %s", size)
	for k, v in pairs(loaded_items) do
		packet:w_stringZ(k)
		--log3("~saving id %s", k)
	end
end

function on_load(reader)
	if reader:r_eof() then
	return end
	--log3("%s on load", script_name())
	local size = reader:r_u8()
	--log3("~loading size %s", size)
	if size == 0 then
	return end
	loaded_items = {}
	local id
	for i=1, size do
		id = tonumber(reader:r_stringZ())
		--log3("~loading id %s", id)
		loaded_items[id] = true
	end
end

function on_first_update()
	local item
	for i=0, actor:ruck_count()-1 do
		item = actor:item_in_ruck(i)
		if loaded_items[item:id()] then
			add(item)
		end			
	end
end

function get_max(slot)
	return slots[slot].max_count
end
function get_current(slot)
	return slots[slot].current_count
end

function get_slot_type(item)
	return read_if_exists(sys_ini, "r_string", item:section(), "loadout_type", nil)
end

function is_module(item)
	local slot_volume
	local sect = item:section()
	for k,v in pairs(slots) do
		slot_volume = read_if_exists(sys_ini, "r_u32", sect, k, 0)
		if slot_volume > 0 then
			--log3("~item %s is module for loadout type %s [%s]", item:name(), k, slot_volume)
			return true
		end
	end
	return false
end

function has_drop_pouch()
	if xr_conditions.black_screen() then
	return true end
	local item
	for i = 0, actor:belt_count() - 1 do
		item = actor:item_on_belt(i)
		if read_if_exists(sys_ini, "r_bool", item:section(), "is_drop_pouch", false) then
		return true end
	end	
	return false
end

function update_item_count(item, item_in)
	local delta = item_in and 1 or -1
	local slot_type = get_slot_type(item)
	slots[slot_type].current_count = slots[slot_type].current_count + delta
	if item_in then
		loaded_items[item:id()] = true
	else
		loaded_items[item:id()] = nil
	end

	ogse_signals.get_mgr():call("on_loadout_update_count", item)
	--log3("~update_item_count item %s [%s] | slot_type %s, slots[slot_type].current_count %s, slots[slot_type].max_count %s", item:name(), item:id(), slot_type, slots[slot_type].current_count, slots[slot_type].max_count)
end

function update_max_count(item, item_in)
	local slot_volume = 0
	local sect = item:section()
	for k,v in pairs(slots) do
		slot_volume = read_if_exists(sys_ini, "r_u32", sect, k, 0)
		if slot_volume > 0 then
			v.max_count = item_in and v.max_count + slot_volume or v.max_count - slot_volume
			if v.max_count < 0 then
				log3("!fixing wrong max_count! : item %s | loadout type %s | max_count %s", item:name(), k, v.max_count)
				v.max_count = 0
			end
			ogse_signals.get_mgr():call("on_loadout_update_max_count", item)
			
			if not item_in then
				local _item
				for _k,_v in pairs(loaded_items) do
					_item = level.object_by_id(_k)
					if not _item then
					return end
					if get_slot_type(_item) == k then
						if v.current_count > v.max_count then
							remove(_item)
						end
					end
				end
			end
		end
	end
end

function on_grenade_type_switch(prev_grenade, next_grenade)
	if can_remove(next_grenade) then
		remove(next_grenade)
	end
	if can_add(prev_grenade) then
		add(prev_grenade)
	end	
end

function on_drop(item, prev_place)
	if can_remove(item) then
		remove(item)
		return
	end
	if is_module(item) and (prev_place == item_place.belt or prev_place == item_place.slot) then
		update_max_count(item, false)
	end
end

function on_take(item)
	local ammo = item:get_weapon_ammo()
	if ammo and is_weapon_unloading() then
		--log3("~ammo %s [%s] unloaded from weapon", item:name(), item:id())
		if xr_conditions.black_screen() or level.main_input_receiver() then
		return end
		
		if ammo.box_curr == 0 and has_drop_pouch() then
		return end
		
		if can_add(item) then
			add(item)
		elseif not has_drop_pouch() then
			drop_item_to_angle(actor, item, 90)
		end
	end
end

function on_slot(item, prev_place)
	if item:is_grenade() and can_remove(item) then
		remove(item)
		return
	end
	if is_module(item) then
		update_max_count(item, true)
	end	
end

function on_belt(item, prev_place)
	if is_module(item) then
		update_max_count(item, true)
	end
end

function on_ruck(item, prev_place)
	if is_module(item) and (prev_place == item_place.belt or prev_place == item_place.slot) then
		update_max_count(item, false)
	end
end

function can_add(item)
	local slot_type = get_slot_type(item)
	if not slot_type or not slots[slot_type] then
	return false end
	
	--local ammo = item:get_weapon_ammo()
	if can_remove(item) or (item:is_grenade() and actor:is_in_slot(item)) then --or (ammo and ammo.box_curr == 0) then
	return false end
	
	--log3("~can_add item %s [%s] slot_type %s, slots[slot_type].current_count %s, slots[slot_type].max_count %s",item:name(), item:id(), slot_type, slots[slot_type].current_count, slots[slot_type].max_count)
	return slots[slot_type].current_count + 1 <= slots[slot_type].max_count
end

function can_remove(item)
	return loaded_items[item:id()]
end

function add(item)
	item.marked = true
	--log3("~add item %s | %s", item:name(), item:id())
	update_item_count(item, true)
	
	--set_item_ungroupable(item)
	-- if level.main_input_receiver() then
		-- update_inventory_window()
	-- end
	xr_sound.get_safe_sound_object("interface\\inv_slot", sound_object.s2d):play_at_pos(actor,actor:position())
	ogse_signals.get_mgr():call("on_item_to_loadout", item)
	actor:invalidate_inventory()
end

function remove(item)
	item.marked = false
	
	update_item_count(item, false)
	
	--set_item_default_grouping(item)
	-- if level.main_input_receiver() then
		-- update_inventory_window()
	-- end
	xr_sound.get_safe_sound_object("interface\\inv_ruck", sound_object.s2d):play_at_pos(actor,actor:position())
	ogse_signals.get_mgr():call("on_item_from_loadout", item)
	actor:invalidate_inventory()
end

function clear_all()
	local item
	for k,v in pairs(loaded_items) do
		item = level.object_by_id(k)
		if item then
			remove(item)
		end
	end
	xr_sound.get_safe_sound_object("interface\\inv_ruck", sound_object.s2d):play_at_pos(actor,actor:position())
end

function menu_tip_to(item)
	local slot_type = get_slot_type(item)
	local tip_text = string.format("%s [%s/%s]", game.translate_string("st_to_loadout"), slots[slot_type].current_count, slots[slot_type].max_count)
	return tip_text
end
function menu_tip_from(item)
	local slot_type = get_slot_type(item)
	local tip_text = string.format("%s [%s/%s]", game.translate_string("st_from_loadout"), slots[slot_type].current_count, slots[slot_type].max_count)
	return tip_text
end

-- static_focused = false
-- function try_set_item(obj, x, y, action)
	-- local action_allowed = can_add(obj) or can_remove(obj)
	-- if action ~= ui_events.DRAG_DROP_ITEM_DROP or 
		-- not static_focused or
		-- not action_allowed
	-- then 
	-- return end
	
	-- if can_add(obj) then
		-- add(obj)
	-- elseif can_remove(obj) then
		-- remove(obj)
	-- end
-- end