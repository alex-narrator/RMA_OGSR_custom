-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_drop",   				fun = this.on_drop})
	sm:subscribe({signal = "on_ruck",   				fun = this.on_ruck})
	sm:subscribe({signal = "on_take",   				fun = this.on_take})
	sm:subscribe({signal = "on_slot",   				fun = this.on_slot})
	sm:subscribe({signal = "on_belt",   				fun = this.on_belt})
	sm:subscribe({signal = "on_grenade_type_switch",   	fun = this.on_grenade_type_switch})
	sm:subscribe({signal = "on_cell_item_mouse",   		fun = this.try_set_item})
	sm:subscribe({signal = "on_save",   				fun = this.on_save})
	sm:subscribe({signal = "on_load",   				fun = this.on_load})
	sm:subscribe({signal = "on_first_update",   		fun = this.on_first_update})
	
	sm:subscribe({signal = "on_inventory_show",   		fun = this.unpack_items})
	sm:subscribe({signal = "on_inventory_hide",   		fun = this.pack_items})
	sm:subscribe({signal = "on_carbody_show",   		fun = this.unpack_items})
	sm:subscribe({signal = "on_carbody_hide",   		fun = this.pack_items})
	sm:subscribe({signal = "on_trade_show",   			fun = this.unpack_items})
	sm:subscribe({signal = "on_trade_hide",   			fun = this.pack_items})	
end

--//loadout slot types and default capacities
local slots = {
	pistol_ammo 	= {},
	rifle_ammo 		= {},
	shotgun_ammo	= {},
	heavy_ammo 		= {},
	grenade			= {},
	medicine 		= {},
}
for k,v in pairs(slots) do
	v.max_count = read_if_exists(sys_ini, "r_u32", "loadout", k, 0)
	v.current_count = 0
end

function log_slots()
	for k,v in pairs(slots) do
		log3("slots k = %s", k)
	end
end

local loaded_items = {}

local packed_items = {}

local unload_states = {
	[global_flags.eReload] = true,
	[global_flags.eShutter] = true,
}
function is_weapon_unloading()
	local weapon = actor:active_item() and actor:active_item():get_weapon_m()
	return weapon and unload_states[weapon.state]
end

function get_loaded_items()
	return loaded_items
end

function get_packed_items()
	return packed_items
end

function on_save(packet)
	xr_vars.save_var("loaded_items", loaded_items)
	xr_vars.save_var("packed_items", packed_items)
end

function on_load(reader)
	loaded_items = xr_vars.load_var("loaded_items", loaded_items)
	packed_items = xr_vars.load_var("packed_items", packed_items)
end

function on_first_update()
	update_ballast_weight()
end

function get_max(slot)
	return slots[slot].max_count
end
function get_current(slot)
	return slots[slot].current_count
end

function get_slot_type(item)
	return read_if_exists(sys_ini, "r_string", item:section(), "loadout_type", nil)
end

function is_module(item)
	local slot_volume
	local sect = item:section()
	for k,v in pairs(slots) do
		slot_volume = read_if_exists(sys_ini, "r_u32", sect, k, 0)
		if slot_volume > 0 then
			--log3("~item %s is module for loadout type %s [%s]", item:name(), k, slot_volume)
			return true
		end
	end
	return false
end

function has_drop_pouch()
	if xr_conditions.black_screen() then
	return true end
	local item
	for i = 0, actor:belt_count() - 1 do
		item = actor:item_on_belt(i)
		if read_if_exists(sys_ini, "r_bool", item:section(), "is_drop_pouch", false) then
		return true end
	end	
	return false
end

function is_inv_wnd_open()
	return has_alife_info("ui_inventory") or has_alife_info("ui_car_body") or has_alife_info("ui_trade")
end

function update_item_count(item, item_in)
	local delta = item_in and 1 or -1
	local slot_type = get_slot_type(item)
	slots[slot_type].current_count = slots[slot_type].current_count + delta
	if item_in then
		loaded_items[item:id()] = true
	else
		loaded_items[item:id()] = nil
	end

	ogse_signals.get_mgr():call("on_loadout_update_count", item)
	--log3("~update_item_count item %s [%s] | slot_type %s, slots[slot_type].current_count %s, slots[slot_type].max_count %s", item:name(), item:id(), slot_type, slots[slot_type].current_count, slots[slot_type].max_count)
end

function update_max_count(item, item_in)
	local slot_volume = 0
	local sect = item:section()
	for k,v in pairs(slots) do
		slot_volume = read_if_exists(sys_ini, "r_u32", sect, k, 0)
		if slot_volume > 0 then
			v.max_count = item_in and v.max_count + slot_volume or v.max_count - slot_volume
			if v.max_count < 0 then
				log3("!fixing wrong max_count! : item %s | loadout type %s | max_count %s", item:name(), k, v.max_count)
				v.max_count = 0
			end
			ogse_signals.get_mgr():call("on_loadout_update_max_count", item)
			
			if not item_in then
				local _item
				for _k,_v in pairs(loaded_items) do
					_item = level.object_by_id(_k)
					if not _item then
					return end
					if get_slot_type(_item) == k then
						if v.current_count > v.max_count then
							remove(_item)
						end
					end
				end
			end
		end
	end
end

function on_grenade_type_switch(prev_grenade, next_grenade)
	if can_remove(next_grenade) then
		remove(next_grenade)
	end
	if can_add(prev_grenade) then
		add(prev_grenade)
	end	
end

function on_drop(item, prev_place)
	if can_remove(item) then
		remove(item)
		return
	end
	if is_module(item) and (prev_place == item_place.belt or prev_place == item_place.slot) then
		update_max_count(item, false)
	end
end

function on_take(item)
	local ammo = item:get_weapon_ammo()
	if ammo and is_weapon_unloading() then
		--log3("~ammo %s [%s] unloaded from weapon", item:name(), item:id())
		if xr_conditions.black_screen() or level.main_input_receiver() then
		return end
		
		if ammo.box_curr == 0 and has_drop_pouch() then
		return end
		
		if can_add(item) then
			add(item)
		elseif not has_drop_pouch() then
			drop_item_to_angle(actor, item, 90)
		end
	elseif not is_inv_wnd_open() then
		if loaded_items[item:id()] then
			add(item)
		else	
			pack_item(item)
		end	
	end
end

function on_slot(item, prev_place)
	if item:is_grenade() and can_remove(item) then
		remove(item)
		return
	end
	if is_module(item) then
		update_max_count(item, true)
	end	
end

function on_belt(item, prev_place)
	if is_module(item) then
		update_max_count(item, true)
	end
end

function on_ruck(item, prev_place)
	if is_module(item) and (prev_place == item_place.belt or prev_place == item_place.slot) then
		update_max_count(item, false)
	end
end

function can_add(item)
	local slot_type = get_slot_type(item)
	if not slot_type or not slots[slot_type] then
	return false end
	
	--local ammo = item:get_weapon_ammo()
	if can_remove(item) or (item:is_grenade() and actor:is_in_slot(item)) then --or (ammo and ammo.box_curr == 0) then
	return false end
	
	--log3("~can_add item %s [%s] slot_type %s, slots[slot_type].current_count %s, slots[slot_type].max_count %s",item:name(), item:id(), slot_type, slots[slot_type].current_count, slots[slot_type].max_count)
	return slots[slot_type].current_count + 1 <= slots[slot_type].max_count
end

function can_remove(item)
	return loaded_items[item:id()]
end

function add(item)
	item.marked = true
	--log3("~add item %s | %s", item:name(), item:id())
	update_item_count(item, true)
	
	--set_item_ungroupable(item)
	-- if level.main_input_receiver() then
		-- update_inventory_window()
	-- end
	xr_sound.get_safe_sound_object("interface\\inv_slot", sound_object.s2d):play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)--play_at_pos(actor,actor:position())
	ogse_signals.get_mgr():call("on_item_to_loadout", item)
	actor:invalidate_inventory()
end

function remove(item)
	item.marked = false
	
	update_item_count(item, false)
	
	--set_item_default_grouping(item)
	-- if level.main_input_receiver() then
		-- update_inventory_window()
	-- end
	xr_sound.get_safe_sound_object("interface\\inv_ruck", sound_object.s2d):play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)--play_at_pos(actor,actor:position())
	ogse_signals.get_mgr():call("on_item_from_loadout", item)
	actor:invalidate_inventory()
end

function clear_all()
	local item
	for k,v in pairs(loaded_items) do
		item = level.object_by_id(k)
		if item then
			remove(item)
		end
	end
	xr_sound.get_safe_sound_object("interface\\inv_ruck", sound_object.s2d):play_no_feedback(actor, sound_object.s2d, 0, vector(), 1.0)--play_at_pos(actor,actor:position())
end

function menu_tip_to(item)
	local slot_type = get_slot_type(item)
	local tip_text = string.format("%s [%s/%s]", game.translate_string("st_to_loadout"), slots[slot_type].current_count, slots[slot_type].max_count)
	return tip_text
end
function menu_tip_from(item)
	local slot_type = get_slot_type(item)
	local tip_text = string.format("%s [%s/%s]", game.translate_string("st_from_loadout"), slots[slot_type].current_count, slots[slot_type].max_count)
	return tip_text
end

function try_set_item(obj, x, y, action)
	if not has_alife_info("ui_inventory") then return end
	local action_allowed = can_add(obj) or can_remove(obj)
	if action ~= ui_events.WINDOW_LBUTTON_DB_CLICK or 
		not action_allowed
	then 
	return end
	
	if can_add(obj) then
		add(obj)
	elseif can_remove(obj) then
		remove(obj)
	end
end


function pack_item(item)
	if item.marked or actor:is_in_slot(item) or actor:is_on_belt(item) then
	return false end
	
	local sect = item:section()
	
	if sect == "ballast" then
	return false end
	
	local class = read_if_exists(sys_ini, "r_string", sect, "class", nil)
	if class ~= "AMMO" and class ~= "G_F1" and class ~= "G_RGD5" then
	return false end
	
	local data = {}
	
	data.sect = sect
	data.weight = item:weight()
	
	if class == "AMMO" then
		local ammo = item:get_weapon_ammo()
		data.count = ammo.box_curr
		data.ammo_type = ammo.box_ammo_type
	end
	
	table.insert(packed_items, data)
	
	local sim = alife()
	sim:release(sim:object(item:id()), true)
	
	--log3("~pack item: %s", item:name())
	
	add_ballast_weght(data.weight)
	
	return true
end

function unpack_items(owner)
	local owner_id = owner and owner:id() or actor:id()
	actor:object("ballast"):get_inventory_item().inv_weight = 0
	
	for k,v in pairs (packed_items) do
		if sys_ini:r_string(v.sect, "class") == "AMMO" then
			spawn_ammo_to_owner(v.sect, owner_id, v.count, v.ammo_type)
		else
			spawn_to_owner(v.sect, owner_id)
		end
	end
end

function pack_items()
	packed_items = {}
	function perform_action(dummy, item)
		pack_item(item)
	end	
	actor:iterate_ruck(perform_action, nil)
end

function update_ballast_weight()
	if not actor:object("ballast") then
		spawn_to_owner("ballast", actor:id())
		log3("~CREATING BALLAST")
		return
	end	
	actor:object("ballast"):get_inventory_item().inv_weight = 0
	for k,v in pairs (packed_items) do
		add_ballast_weght(v.weight)
	end
end

function add_ballast_weght(add_weight)
	local ballast = actor:object("ballast")
	if not ballast then return end
	ballast = ballast:get_inventory_item()
	ballast.inv_weight = ballast.inv_weight + add_weight
end