-- -*- mode: lua; coding: windows-1251-dos -*-
function attach(sm)
	sm:subscribe({signal = "on_save",   		fun = this.on_save})
	sm:subscribe({signal = "on_load",   		fun = this.on_load})
	sm:subscribe({signal = "on_update", 		fun = this.actor_update})
	sm:subscribe({signal = "on_task",   		fun = this.on_task})
	sm:subscribe({signal = "on_npc_death",   	fun = this.on_npc_death})
end

local LIST_SECT = "task_list"
local TASK_UPD_INTERVAL = 3 * 1000
local task_phrase_id = 100

local parent_by_story = {
	[story_ids.Escape_Trader] 				= "trader",
	[story_ids.bar_Barman] 					= "barman",
	[story_ids.yan_general_ecolog] 			= "ecolog",
	[story_ids.bar_dolg_general_voronin] 	= "dolg",
	[story_ids.Mil_Lukash] 					= "freedom",
	[story_ids.Escape_novice_lager_volk] 	= "wolf",
	[story_ids.Escape_shustryi] 			= "shustriy",
	[story_ids.bar_drunk_dolg] 				= "drunk_dolg",
	[story_ids.bar_hunter] 					= "hunter",
	[story_ids.bar_zastava_commander] 		= "zastava_commander",
	[story_ids.bar_dolg_polkovnik_petrenko] = "petrenko",
	[story_ids.bar_lisiy] 					= "lisiy",
	[story_ids.bar_bar_osvedomitel] 		= "mercenary",
}

local story_by_parent = {}
for sid, parent in pairs(parent_by_story) do
	story_by_parent[parent] = sid
end

local return_task_by_type = {
	eliminate_lager = "return_for_reward",
	defend_lager 	= "return_for_reward",
	kill_stalker 	= "return_for_reward",
	artefact 		= "return_for_reward_bring",
	monster_part 	= "return_for_reward_bring",
	find_item 		= "return_for_reward_bring",
}
	
local mob_lagers = {
	["esc_bridge_boar"] 				= true,
	["esc2_dogs_lair"] 					= true,
	["esc_flesh_2"] 					= true,
	["gar_smart_monster_lair2"] 		= true,
	["gar_nest_flesh"] 					= true,
	["val_smart_bloodsucker_lair_2"] 	= true,
	["val_snork_lair_1"] 				= true,
	["bar_zastava_dogs_lair"] 			= true,
	["ros_smart_monster1"] 				= true,
	["ros_smart_monster2"] 				= true,
	["ros_smart_monster5"] 				= true,
	["yan_smart_controler1"] 			= true,
	["yantar2_snork_small4"] 			= true,
	["yan_tonnel_snorks"] 				= true,
	["mil_hunters_bloodsucker"] 		= true,
	["mil_lair2"] 						= true,
	["mil_lair3"] 						= true,
	["mil_village_lair"] 				= true,
}	

local receiver_sid_by_alias = {
	["sidor_box"] 		= story_ids.esc_sidor_store_box,
	["barman_box"] 		= story_ids.bar_barman_store_box,
	["sakharov_box"] 	= story_ids.yan_sakharov_store_box,
	["voronin_box"] 	= story_ids.bar_voronin_store_box,
	["max_box"] 		= story_ids.mil_volya_max_box,
}

--//головна таблиця з даними по таскам
local task_info = {}
--' Создание дополнительных ассоциативных таблиц для облегчения поиска
local task_id_by_type = {}
local task_id_by_parent = {}
local task_id_by_yes_phrase_id = {}
local task_id_by_init_phrase_id = {}
local task_id_by_desc_phrase_id = {}
local active_task_by_type = {}
local task_id_self_inited = {}

function parse_tasks()
	--log3("~parse_tasks")
	ASSERT(sys_ini:section_exist(LIST_SECT), "There is no section [%s] in task_manager.ltx", LIST_SECT)
	local n = sys_ini:line_count(LIST_SECT)
	local id, value = "",""
	local category = ""

	for i=0,n-1 do
		result, id, value	= sys_ini:r_line(LIST_SECT,i,"","")
		
		ASSERT(sys_ini:section_exist(id), "There is no task section [%s] in task_manager.ltx", id)

		task_info[id]					= {}
		local curr_task_info			= task_info[tostring(id)]
		
		curr_task_info.type				= read_if_exists(sys_ini, "r_string", id, "type", nil)
		ASSERT(curr_task_info.type, "There is no type in task section [%s] in task_manager.ltx", id)
		
		--//заголовок завдання
		curr_task_info.title			= read_if_exists(sys_ini, "r_string", id, "title", nil)

		curr_task_info.name				= id
		curr_task_info.parent 			= read_if_exists(sys_ini, "r_string", id, "parent", nil)
		curr_task_info.complex_type 	= curr_task_info.parent and curr_task_info.type .. "_" .. task_info[id].parent or curr_task_info.type

		curr_task_info.target			= read_if_exists(sys_ini, "r_string", id, "target", nil)
		
		curr_task_info.text				= read_if_exists(sys_ini, "r_string", id, "text", "[NO_TEXT]")
		curr_task_info.description		= read_if_exists(sys_ini, "r_string", id, "description", "[NO_DESCRIPTION]")
		
		curr_task_info.time				= read_if_exists(sys_ini, "r_u32", id, "time", nil) --//час на виконання завдання у ігрових годинах
		curr_task_info.idle_time		= read_if_exists(sys_ini, "r_u32", id, "idle_time", 24) * 60 * 60 --' Время между выдачами задания (у ігрових годинах)
		curr_task_info.prior			= read_if_exists(sys_ini, "r_u32", id, "prior", 0) --' Приоритет квеста, выдаются доступные квесты с наименьшим приоритетом
	
		if sys_ini:line_exist(id, "init_condition") then
			curr_task_info.init_condition = xr_logic.parse_condlist(actor, "task_manager", "init_condition", sys_ini:r_string(id, "init_condition"))
		end

		curr_task_info.reward_item 			= read_if_exists(sys_ini, "r_string", id, "reward_item", nil)
		if curr_task_info.reward_item then
			curr_task_info.reward_item 		= se_respawn.parse_names(curr_task_info.reward_item)
			curr_task_info.reward_item_receiver = read_if_exists(sys_ini, "r_string", id, "reward_item_receiver", nil)
		end
		
		curr_task_info.reward_money 		= read_if_exists(sys_ini, "r_s32", id, "reward_money", nil)		
	
		curr_task_info.community 			= read_if_exists(sys_ini, "r_string", id, "community", nil)

		curr_task_info.reward_rank			= read_if_exists(sys_ini, "r_u32", id, "reward_rank", nil)
		curr_task_info.reward_reputation	= read_if_exists(sys_ini, "r_s32", id, "reward_reputation", nil)
		curr_task_info.reward_relation		= parse_key_value(read_if_exists(sys_ini, "r_string", id, "reward_relation", nil))
		curr_task_info.reward_info			= parse_key_value(read_if_exists(sys_ini, "r_string", id, "reward_info", nil))
		
		curr_task_info.penalty_reputation	= read_if_exists(sys_ini, "r_s32", id, "penalty_reputation", nil)
		curr_task_info.penalty_relation		= parse_key_value(read_if_exists(sys_ini, "r_string", id, "penalty_relation", nil))
		
		curr_task_info.condlist				= xr_logic.parse_condlist(actor, "task_manager", "condlist", read_if_exists(sys_ini, "r_string", id, "condlist", "true"))
		
		if sys_ini:line_exist(id, "custom_complete_cond") then
			curr_task_info.custom_complete_cond = xr_logic.parse_condlist(actor, "task_manager", "custom_complete_cond", sys_ini:r_string(id, "custom_complete_cond"))
		end
	
		curr_task_info.need_return			= read_if_exists(sys_ini, "r_bool", id, "need_return", true)
		curr_task_info.remote_reward		= read_if_exists(sys_ini, "r_bool", id, "remote_reward", false)

		curr_task_info.init_phrase_id		= gen_phrase_id()
		curr_task_info.desc_phrase_id		= gen_phrase_id()
		curr_task_info.yes_phrase_id		= gen_phrase_id()
		curr_task_info.no_phrase_id			= gen_phrase_id()

		--' По умолчанию квест доступен для выдачи
		curr_task_info.enabled				= true
		--' Доступен ли квест по своим свойствам. По умолчанию всегда недоступен.
		--' Этот параметр зависит от наличия целей для квестов и того срабатывает ли прекондишн квеста
		curr_task_info.enabled_props		= false

		--' Статус квеста, может быть: "normal", "selected", "completed", "refused", "failed", "rewarded"
		curr_task_info.status				= "normal"
	end

	for k,v in pairs(task_info) do
		--' По типу квеста
		if not task_id_by_type[v.type] then
			task_id_by_type[v.type] = {}
		end
		table.insert(task_id_by_type[v.type], k)

		--' По типу вендора
		if v.parent then
			if not task_id_by_parent[v.parent] then
				task_id_by_parent[v.parent] = {}
			end
			table.insert(task_id_by_parent[v.parent], k)
		end

		--' По id фразы согласия на квест
		task_id_by_yes_phrase_id[tostring(v.yes_phrase_id)] = k
		--' По id фразы выдачи квеста.
		task_id_by_init_phrase_id[tostring(v.init_phrase_id)] = k
		--' По id фрази опису
		task_id_by_desc_phrase_id[tostring(v.desc_phrase_id)] = k
		--' По самовыдаваемости
		if v.init_condition then
			table.insert(task_id_self_inited, k)
		end
	end
end

--' Генератор уникальных ID для фраз
function gen_phrase_id()
	task_phrase_id = task_phrase_id + 1
	return tostring(task_phrase_id)
end

--//одразу парсим таски
parse_tasks()

--' Сохранение
function on_save()
	local task_processed = {}
	for k,v in pairs(task_info) do
		task_processed[k] = {}
		task_processed[k].status = v.status
		task_processed[k].last_task_time = ctime_to_table(v.last_task_time)
		task_processed[k].selected_target = (v.selected_target and v.status == "selected") and v.selected_target or nil		
	end
	xr_vars.save_var("task_processed", task_processed)
	--log3("~on_save task_processed %s", task_processed)
	xr_vars.save_var("active_task_by_type", active_task_by_type)
	--log3("~on_save active_task_by_type %s", active_task_by_type)
end
--' Загрузка
function on_load()
	local task_processed = xr_vars.load_var("task_processed", {})
	--log3("~on_load task_processed %s", task_processed)
	for k,v in pairs (task_processed) do
		task_info[k].status = v.status
		task_info[k].last_task_time = table_to_ctime(v.last_task_time)
		task_info[k].selected_target = v.selected_target or nil
	end
	--//завантажуємо активні таски
	active_task_by_type = xr_vars.load_var("active_task_by_type", active_task_by_type)
	--log3("~on_load active_task_by_type %s", active_task_by_type)
end
--' Возвращает идентификатор вендора, с которым мы говорим
function get_parent(npc)
	local story_id = npc:story_id()
	ASSERT(parent_by_story[story_id], "Task manager error: wrong parent story_id[%s]", story_id)
	return parent_by_story[story_id]
end
--' Может ли вендор выдать квест
function parent_can_task(actor, npc, p1, p2, p3)
	local parent = get_parent(npc)
	local avail = false
	task_avail(actor, npc, nil, nil, nil, "reset")
	for k,v in pairs(task_id_by_parent[parent]) do
		if task_avail(actor, npc, nil, nil, task_info[v].init_phrase_id, true) then
			avail = true
		end
	end
	return avail
end
--' Есть ли у игрока хоть одно задание от данного вендора
function active_parent_task(actor, npc)
	local parent = get_parent(npc)
	for k,v in pairs(active_task_by_type) do
		if task_info[v].parent == parent and
		  (task_info[v].status == "selected" or
		   task_info[v].status == "completed")
		then
			return true
		end				
	end
	return false
end
--' Есть ли игрока завершенные задания (которые осталось только сдать)
function have_completed_job(actor, npc)
	local parent = get_parent(npc)
	for k,v in pairs(active_task_by_type) do
		if task_info[v].parent == parent and
		   task_info[v].status == "completed"
		then
			return true
		end				
	end
	return false
end
--' Выдача квеста игроку
function action_give_task(actor, npc, p1, p2)
	local task = CGameTask()
	
	printf("p1 = %s p2 = %s", tostring(p1), tostring(p2))

	local task_desc = task_info[task_id_by_yes_phrase_id[p2]]
	
	task:load(task_desc.complex_type)
	task:set_title(task_desc.title or task_desc.type)

	local oo = task:get_objective(0)
	oo:set_article_id(task_desc.description)
	if mob_lagers[task_desc.target] then
		oo:set_icon_name("ui_icons_task_eliminate_lair")
	end	
	
	local objective = SGameTaskObjective(task,1)
	objective:set_description(task_desc.name)
	
	local _text = string.format("%s\\n%s\\n%s", game.translate_string(task_desc.text), GetRewardText(task_desc), GetPenaltyText(task_desc))
	
	if task_desc.type == "eliminate_lager" then
		objective:set_map_hint(_text)
		objective:set_map_location(mob_lagers[task_desc.target] and "eliminate_lair_location" or "eliminate_lager_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "defend_lager" then
		objective:set_map_hint(_text)
		objective:set_map_location("defend_lager_location")
		objective:set_object_id(task_desc.selected_target)

		local defend_object = alife():object(task_desc.selected_target)
		local sm_ini = defend_object:spawn_ini()
		task_info[task_id_by_yes_phrase_id[p2]].defend_target = read_if_exists(sm_ini, "r_u32", "random_task", "defend_target", nil)
	elseif task_desc.type == "kill_stalker" then
		objective:set_map_hint(_text)
		objective:set_map_location("kill_stalker_location")
		objective:set_object_id(task_desc.selected_target)
	elseif task_desc.type == "find_item" then
		objective:set_map_hint(_text)
		objective:set_map_location("find_item_location")
		objective:set_object_id(task_desc.selected_target)
	end
	objective:add_complete_func("task_manager.task_complete")
	task:add_objective(objective)

	if task_desc.need_return then
		objective = SGameTaskObjective(task,2)
		objective:set_description(return_task_by_type[task_desc.type])

		objective:set_map_hint(return_task_by_type[task_desc.type])
		objective:set_map_location("blue_location")
		objective:set_object_id(alife():story_object(tonumber(story_by_parent[task_desc.parent])).id)
		task:add_objective(objective)
	end
	
	local task_time = task_desc.time and task_desc.time * 60 * 60 * 1000 or nil
	db.actor:give_task(task, task_time, false)

	--' дизаблим все остальные задания данного типа, так как игрок не может одновременно обладать двумя заданиями одного типа.
	task_info[task_id_by_yes_phrase_id[p2]].status = "selected"
	active_task_by_type[task_desc.complex_type] = task_id_by_yes_phrase_id[p2]
	for k,v in pairs(task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = false
		end
	end
end
--' Отказ игроком от квеста
function action_refuse_task(actor, npc, p1, p2)
	local task_desc = task_info[task_id_by_yes_phrase_id[p2]]

	--' Делаем доступными все задания данного типа
	task_info[task_id_by_yes_phrase_id[p2]].status = "refused"
	task_info[active_task_by_type[task_desc.complex_type]].selected_target = nil
	for k,v in pairs(task_info) do
		if v.complex_type == task_desc.complex_type then
			v.enabled = true
		end
	end
end
--' Проверяем, не выполнен ли таск
function task_complete(p1, p2)
	if not actor then
		return false
	end

	local sel_task = task_info[active_task_by_type[p1]]
	ASSERT(sel_task, "WRONG RANDOM TASK %s %s", p1, p2)
	
	--log3("~active_task_by_type[p1] - %s",active_task_by_type[p1])
	--log3("~task_complete check task %s", sel_task)

	if p2 == 0 then
		if not sel_task.need_return and sel_task.status == "completed" then
			task_info[active_task_by_type[p1]].last_task_time = game.get_game_time()
			--log3("~task completed: task %s has last_task_time %s", task_info[active_task_by_type[p1]].name, task_info[active_task_by_type[p1]].last_task_time)
			if sel_task.remote_reward then
				--log3("~remote rewarded task %s completed, vendor %s", sel_task.name, alife():story_object(story_by_parent[sel_task.parent]):name())
				task_reward_remote(sel_task)
			end
			return true
		end
		if sel_task.status == "rewarded" then
			task_info[active_task_by_type[p1]].last_task_time = game.get_game_time()
			--log3("~task rewarded: task %s has last_task_time %s", task_info[active_task_by_type[p1]].name, task_info[active_task_by_type[p1]].last_task_time)
			return true
		end
	end

	if p2 == 1 then
		
		--//кастомні умови виконання завдання
		if task_info[active_task_by_type[p1]].custom_complete_cond and xr_logic.pick_section_from_condlist(actor, actor, task_info[active_task_by_type[p1]].custom_complete_cond) ~= nil then
			task_info[active_task_by_type[p1]].status = "completed"
			return true
		end
		
		if string.find(p1, "eliminate_lager") ~= nil then
			--log3("~task_complete check task %s - sel_task.selected_target %s", sel_task.name, sel_task.selected_target or "NIL")
			local oo = alife():object(sel_task.selected_target)
			if oo and oo.gulag:get_population_comed() == 0 then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "defend_lager") ~= nil then
			--' Квест выполнен потому что рейд прекратился
			if xr_gulag.getGulagState(sel_task.defend_target) == 0 then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "kill_stalker") ~= nil then
			local oo = alife():object(sel_task.selected_target)

			--' Проверка бага
			ASSERT(oo, "selected target %s for task %s is not exist", sel_task.selected_target, active_task_by_type[p1])

			if oo and not oo:alive() then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "artefact") ~= nil then
			if actor:object(sel_task.target) ~= nil then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "monster_part") ~= nil then
			if actor:object(sel_task.target) ~= nil then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		elseif string.find(p1, "find_item") ~= nil then
			if actor:object(sel_task.target) ~= nil then
				task_info[active_task_by_type[p1]].status = "completed"
				return true
			end
		end
	end
	
	return false
end
--' Проверяем, не профейлен ли таск
function task_fail(p1, p2)
	if p2 == 0 then
		local sel_task = task_info[active_task_by_type[p1]]
		
		ASSERT(sel_task, "WRONG RANDOM TASK %s %s", p1, p2)

		--' Проверяем что жив, выдавший квест.
		local parent = alife():story_object(story_by_parent[sel_task.parent])
		local parent_alive = parent and (parent:get_trader() or parent:alive())
		if not parent_alive then
			task_info[active_task_by_type[p1]].status = "failed"
			task_info[active_task_by_type[p1]].last_task_time = game.get_game_time()
			--log3("~task failed by vendor death: task %s has last_task_time %s", task_info[active_task_by_type[p1]].name, task_info[active_task_by_type[p1]].last_task_time)
			return true		
		end

		if sel_task.status == "refused" or sel_task.status == "failed" then
			task_info[active_task_by_type[p1]].last_task_time = game.get_game_time()
			--log3("~task failed or refused: task %s has last_task_time %s", task_info[active_task_by_type[p1]].name, task_info[active_task_by_type[p1]].last_task_time)
			return true
		end
		if string.find(p1, "defend_lager") ~= nil then
			if alife():object(sel_task.selected_target).gulag:get_population_comed() == 0 then
				task_info[active_task_by_type[p1]].status = "failed"
				task_info[active_task_by_type[p1]].last_task_time = game.get_game_time()
				--log3("~defend lager are all dead: task %s has last_task_time %s", task_info[active_task_by_type[p1]].name, task_info[active_task_by_type[p1]].last_task_time)
				return true
			end
		end
	end
	return false
end
--' Обнуление переменных при завершении или провале таска
function task_callback(p1, p2, state)
	if p2 ~= 0 then
		return
	end

	if active_task_by_type[p1] == nil then
		return
	end

	if state == task.completed then
		task_info[active_task_by_type[p1]].status = "normal"
		--' восстановление других заданий данного типа
		for k,v in pairs(task_info) do
			if v.complex_type == task_info[active_task_by_type[p1]].complex_type then
				v.enabled = true
			end
		end
		active_task_by_type[p1] = nil	

	elseif state == task.fail then
		local task_data = task_info[active_task_by_type[p1]]
		
		--' Проверяем что жив, выдавший квест (хтонічний Сидорович-trader живий завжди).
		local parent = alife():story_object(story_by_parent[task_data.parent])
		local parent_alive = parent and (parent:get_trader() or parent:alive())
		if task_data.status ~= "refused" and parent_alive then
			task_penalty(task_data)
		end
		task_info[active_task_by_type[p1]].status = "normal"
		
		--' восстановление других заданий данного типа
		for k,v in pairs(task_info) do
			if v.complex_type == task_info[active_task_by_type[p1]].complex_type then
				v.enabled = true
			end
		end
		active_task_by_type[p1] = nil	
	end
end
--' Выводит список доступных квестов
function action_task_show(npc, actor)
	local parent = get_parent(npc)	
	for k,v in pairs(task_id_by_parent[parent]) do		
		if task_avail(actor, npc, nil, nil, task_info[v].init_phrase_id, false) then
			local icon_type = (task_info[v].type == "eliminate_lager") and (mob_lagers[task_info[v].target] and "eliminate_layer" or "eliminate_lager") or task_info[v].type
			local task_texture, task_rect = get_texture_info("ui_icons_task_"..icon_type, "ui_iconsTotal_locations")
			db.actor:give_talk_message(game.translate_string(task_info[v].name), task_texture, task_rect,"iconed_trade_info")
		end
	end
end
--' Проверка доступен ли текущий таск для выдачи
function task_avail(actor, npc, p1, p2, p3, calculate)
	local task_desc = task_info[task_id_by_init_phrase_id[p3]]
	--' Если calculate == true то нужно проверять check_task_props, инача просто вернуть значения.
	if calculate == "reset" then		
		current_parent_type_prior = {}
		return
	elseif calculate == true then
		check_task_props(task_id_by_init_phrase_id[p3])

		local t = task_desc.enabled and task_desc.enabled_props and task_desc.init_condition == nil

		--' Устанавливать обрезания по приоритетам тут.
		if t == true and (current_parent_type_prior[task_desc.complex_type] == nil or
		   current_parent_type_prior[task_desc.complex_type] > task_desc.prior )
		then
			current_parent_type_prior[task_desc.complex_type] = task_desc.prior
		end

		return t
	end
	
	return task_desc.enabled and 
		   task_desc.enabled_props and
		   task_desc.init_condition == nil
end
--' Проверка свойств таска
local target_tasks = {
	["kill_stalker"] = true,
	["find_item"] = true,
	["eliminate_lager"] = true,
	["defend_lager"] = true,
}
function check_task_props(task_id)
	--' Проверка по активным заданиям данного типа у вендора.
	if active_task_by_type[task_info[task_id].complex_type] ~= nil then
		task_info[task_id].enabled_props = false
		return
	end

	--' Проверка по кондлисту
	if xr_logic.pick_section_from_condlist(actor, actor, task_info[task_id].condlist) == nil then
		task_info[task_id].enabled_props = false
		return
	end
	
	--' Проверка по таймауту
	-- if task_info[task_id].last_task_time then
		-- log3("~check_task_props %s last_task_time %s", task_id, task_info[task_id].last_task_time)
		-- log3("~check_task_props %s last_task_time %s", task_id, task_info[task_id].last_task_time:timeToString(game.CTime.TimeToSeconds))
	-- end
	if task_info[task_id].last_task_time and game.get_game_time():diffSec(task_info[task_id].last_task_time) < task_info[task_id].idle_time then
		task_info[task_id].enabled_props = false
		return
	end
	
	--перевірка по community
	if task_info[task_id].community and task_info[task_id].community ~= actor:character_community() then
		task_info[task_id].enabled_props = false
		return
	end

	--' проверка по таргету
	if target_tasks[task_info[task_id].type] then
		if not task_info[task_id].selected_target or not alife():object(task_info[task_id].selected_target) then
			task_info[task_id].selected_target = nil
			select_target(task_info[task_id])
		end
		if not task_info[task_id].selected_target then
			task_info[task_id].enabled_props = false
			return
		end
	
		if task_info[task_id].type == "eliminate_lager" then
			local gulag = alife():object(task_info[task_id].selected_target).gulag
			task_info[task_id].enabled_props = gulag:get_population_comed() > 0
			return
		else
			task_info[task_id].enabled_props = true
			return		
		end
	end
	
	task_info[task_id].enabled_props = true
end
--' Проверяем можем ли мы сейчас выдать какой либо самоинициализующийся таск
function actor_update()
	ogse_signals.get_mgr():reschedule(TASK_UPD_INTERVAL)
	--local t = debug_info.p_timer("actor_update()")
	for k,v in pairs(task_id_self_inited) do
		local _task_info = task_info[v]
		if _task_info.status == "normal" then
			check_task_props(v)
			if _task_info.enabled_props == true and
			   _task_info.enabled == true and
			   xr_logic.pick_section_from_condlist(actor, actor, _task_info.init_condition) ~= nil
			then
				--' Нужно автоматически выдать квест
				action_give_task(actor, nil, nil, _task_info.yes_phrase_id)
			end
		end
	end
	--t:stop()
end
--' Проверяется является ли текущий таск выданным игроку
function active_task(actor, npc, p1, p2, p3)
	return task_info[task_id_by_init_phrase_id[p3]].status == "selected"
end
--' Создается диалог актера, в котором будут выдаваться задания.
function init_task_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_seek_new_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_list_job","1","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.action_task_show")
	phrase_script:AddPrecondition("task_manager.precondition_vendor_can_task")
		
	phr = dlg:AddPhrase("tm_"..parent.."_has_no_job","2","0",-10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_vendor_cannot_task")
	
	local _task_info
	for k,v in pairs(task_id_by_parent[parent]) do
		_task_info = task_info[v]
		
		phr = dlg:AddPhrase(_task_info.name, tostring(_task_info.init_phrase_id), "1", -10000)		
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddPrecondition("task_manager.precondition_task_avail")

		phr = dlg:AddPhrase(_task_info.description, tostring(_task_info.desc_phrase_id), tostring(_task_info.init_phrase_id), -10000)
		--phr:SetText(GetDescriptionTextEx(_task_info))
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.show_reward_text")
		
		phr = dlg:AddPhrase("tm_seek_job_yes", tostring(_task_info.yes_phrase_id), tostring(_task_info.desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_give_task")

		phr = dlg:AddPhrase("tm_seek_job_no", tostring(_task_info.no_phrase_id), tostring(_task_info.desc_phrase_id), -10000)
	end

	dlg:AddPhrase("tm_seek_job_abandon","3","1",-10000)
end

function show_reward_text(actor, npc, p1, p2)
	local _task_info = task_info[task_id_by_desc_phrase_id[p2]]
	local icon_type = (_task_info.type == "eliminate_lager") and (mob_lagers[_task_info.target] and "eliminate_layer" or "eliminate_lager") or _task_info.type
	local task_texture, task_rect = get_texture_info("ui_icons_task_"..icon_type, "ui_iconsTotal_locations")
	local text = string.format("%s%s%s%s%s", GetRewardText(_task_info), GetTaskTimeText(_task_info), GetLocationText(_task_info), GetPersonalText(_task_info), GetPenaltyText(_task_info))
	actor:give_talk_message(text, task_texture, task_rect, "iconed_trade_info")
end

function ShowRewardMsg(task_info)
	local icon_type = (task_info.type == "eliminate_lager") and (mob_lagers[task_info.target] and "eliminate_layer" or "eliminate_lager") or task_info.type
	local task_texture, task_rect = get_texture_info("ui_icons_task_"..icon_type, "ui_iconsTotal_locations")
	actor:give_talk_message(GetRewardText(task_info), task_texture, task_rect, "iconed_trade_info")
end

function ShowPenaltyMsg(task_info)
	local icon_type = (task_info.type == "eliminate_lager") and (mob_lagers[task_info.target] and "eliminate_layer" or "eliminate_lager") or task_info.type
	local task_texture, task_rect = get_texture_info("ui_icons_task_"..icon_type, "ui_iconsTotal_locations")
	--actor:give_talk_message(GetPenaltyText(task_info), task_texture, task_rect, "iconed_trade_info")
	actor:give_game_news(GetPenaltyText(task_info), task_texture, task_rect, 0, 3000)
end

function GetRewardText(task_info)
	local reward_text = string.format("%s%s\\n", "%c[white]", game.translate_string("ui_st_reward"))
	local money = task_info.reward_money
	local items = task_info.reward_item
	local reputation = task_info.reward_reputation
	local relation = task_info.reward_relation
	local rank = task_info.reward_rank
	local info = task_info.reward_info
		
	local list_prefix = "%c[UI_orange]•"
	if money then
		money = string.format("%s%s %s\\n",list_prefix, money, game.translate_string("ui_st_money_regional"))
		reward_text = string.format("%s%s", reward_text, money)
	end
	if items then
		local items_list = {}
		for kk,vv in pairs(items) do
			if not items_list[vv] then
				items_list[vv] = 1
			else
				items_list[vv] = items_list[vv] + 1
			end
		end
		local str_sect, str_count
		for sect,count in pairs(items_list) do
			str_count = count > 1 and string.format("x%s ", count) or ""
			str_sect = string.format("%s%s %s\\n",list_prefix, game.translate_string(get_inv_name(sect)), str_count)
			reward_text = string.format("%s%s", reward_text, str_sect)
		end
	end
	if reputation then
		reputation = string.format("%s%s %+1.0f\\n",list_prefix, game.translate_string("ui_st_reputation"), reputation)
		reward_text = string.format("%s%s", reward_text, reputation)
	end
	if relation ~= nil then
		local rel
		for k,v in pairs(relation) do
			rel = string.format("%s%s %s %+1.0f\\n",list_prefix, game.translate_string("ui_st_relation"), game.translate_string(k), v)
			reward_text = string.format("%s%s", reward_text, rel)
		end
	end
	if rank then
		rank = string.format("%s%s %+1.0f\\n",list_prefix, game.translate_string("ui_st_rank"), rank)
		reward_text = string.format("%s%s", reward_text, rank)
	end
	if info then
		local rew_info
		for info_portion,info_name in pairs(info) do
			rew_info = string.format("%s%s %s\\n",list_prefix, game.translate_string("ui_st_info"), game.translate_string(info_name))
			reward_text = string.format("%s%s", reward_text, rew_info)
		end		
	end
	return reward_text
end

function GetTaskTimeText(task_info)
	local task_time = task_info.time
	local time_text = ""
	local list_prefix = "%c[UI_orange]•"
	if task_time then
		local time_header = string.format("%s%s\\n", "%c[white]", game.translate_string("ui_st_task_time"))
		task_time = string.format("%s %s %s\\n",list_prefix, task_time, game.translate_string("ui_st_hours"))
		time_text = string.format("%s%s", time_text, time_header..task_time)
	end
	return time_text
end

function GetLocationText(task_info)
	local location_text = ""
	local list_prefix = "%c[UI_orange]•"
	if task_info.selected_target then
		local sim = alife()
		local target = sim:object(task_info.selected_target)
		local level = target and sim:level_name( game_graph():vertex( target.m_game_vertex_id ):level_id() ) or "ui_st_unknown"
		level = string.format("%s%s\\n",list_prefix, game.translate_string(level))
		local level_header = string.format("%s%s\\n", "%c[white]", game.translate_string("ui_st_location"))		
		location_text = string.format("%s%s%s", location_text, level_header, level)
	end
	return location_text
end

function GetPersonalText(task_info)
	local personal_text = ""
	local list_prefix = "%c[UI_orange]•"
	if task_info.selected_target and task_info.type == "kill_stalker" then
		local sim = alife()
		local target = sim:object(task_info.selected_target)
		local name_community = string.format("%s%s (%s, %s)\\n",list_prefix, target.character_name, game.translate_string(target:community()), game.translate_string(ranks.get_obj_rank_name(target)))
		local personal_header = string.format("%s%s\\n", "%c[white]", game.translate_string("ui_st_task_personal"))		
		personal_text = string.format("%s%s%s", personal_text, personal_header, name_community)
	end
	return personal_text
end

function GetPenaltyText(task_info)
	local penalty_text = ""
	local list_prefix = "%c[UI_orange]•"
	local penalty_reputation = task_info.penalty_reputation
	local penalty_relation = task_info.penalty_relation
	if penalty_reputation or penalty_relation then
		local penalty_header = string.format("%s%s\\n", "%c[white]", game.translate_string("ui_st_penalty"))
		penalty_text = string.format("%s%s", penalty_text, penalty_header)
		
		if penalty_reputation then
			penalty_reputation = string.format("%s%s %+1.0f\\n",list_prefix, game.translate_string("ui_st_reputation"), penalty_reputation)
			penalty_text = string.format("%s%s", penalty_text, penalty_reputation)			
		end
		if penalty_relation ~= nil then
			local rel
			for k,v in pairs(penalty_relation) do
				rel = string.format("%s%s %s %+1.0f\\n",list_prefix, game.translate_string("ui_st_relation"), game.translate_string(k), tonumber(v))
				penalty_text = string.format("%s%s", penalty_text, rel)
			end
		end		
	end	
	return penalty_text
end

function task_penalty(task_info)
	local penalty_reputation = task_info.penalty_reputation
	local penalty_relation = task_info.penalty_relation

	if penalty_reputation then
		actor:change_character_reputation(penalty_reputation)
	end
	
	if penalty_relation then
		for comm,rel in pairs(penalty_relation) do
			relation_registry.change_community_goodwill (comm, actor:id(), tonumber(rel))
		end
	end	
	
	if penalty_reputation or penalty_relation then
		ShowPenaltyMsg(task_info)
	end
end

--' Функция, в которой будет выдаваться вещевая награда за выполненные квесты
function task_reward(npc, actor, p1, p2)
	local parent = get_parent(npc)	
	for k,v in pairs(active_task_by_type) do	
		local task_desc = task_info[v]
		if task_desc.status == "completed" and task_desc.parent == parent then
			--' Забираем у игрока квестовый предмет.
			local can_finish = true
			if task_desc.type == "artefact" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					--dialogs.relocate_item_section(npc, task_desc.target, "out")
					dialogs.take_item_from_actor(task_desc.target)
				end
			elseif task_desc.type == "monster_part" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					--dialogs.relocate_item_section(npc, task_desc.target, "out")
					dialogs.take_item_from_actor(task_desc.target)
				end
			elseif task_desc.type == "find_item" then
				if db.actor:object(task_desc.target) == nil then
					can_finish = false
				else
					--dialogs.relocate_item_section(npc, task_desc.target, "out")
					dialogs.take_item_from_actor(task_desc.target)
				end
			end
	
			if can_finish == true then
				task_info[v].status = "rewarded"
				
				if task_desc.reward_money ~= nil then
					--dialogs.relocate_money(npc, task_desc.reward_money, "in")
					db.actor:give_money(task_desc.reward_money)
					game_stats.money_quest_update(task_desc.reward_money)
				end
				
				if task_desc.reward_item ~= nil then
					for kk,vv in pairs(task_desc.reward_item) do
						--dialogs.relocate_item_section(npc, vv, "in", actor)
						--spawn_to_owner(vv, db.actor:id())
						dialogs.give_item_to_actor(vv)
					end
				end

				if task_desc.reward_reputation ~= nil then
					db.actor:change_character_reputation(task_desc.reward_reputation)
				end

				if task_desc.reward_relation ~= nil then
					for kk,vv in pairs(task_desc.reward_relation) do
						relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
					end
				end
				
				if task_desc.reward_info ~= nil then
					for kk,vv in pairs(task_desc.reward_info) do
						actor:give_info_portion(kk)
					end
				end				

				if task_desc.reward_rank ~= nil then
					actor_stats.add_points("quests", task_desc.name, 1, 1)
					db.actor:change_character_rank(task_desc.reward_rank)
				end
				
				ShowRewardMsg(task_desc)
			end
		end	
	end
end
--//видача винагороди за "віддалені" квести
function task_reward_remote(task_desc)
	--log3("~task_reward_remote remote rewarded task %s completed, vendor %s", task_desc.name, alife():story_object(story_by_parent[task_desc.parent]):name())
	if task_desc.reward_money ~= nil then
		--log3("~reward money %s", task_desc.reward_money)
		--dialogs.relocate_money(npc, task_desc.reward_money, "in")
		actor:give_money(task_desc.reward_money)
		game_stats.money_quest_update(task_desc.reward_money)
		--news_manager.relocate_money(actor, "in", task_desc.reward_money)
	end
				
	if task_desc.reward_item ~= nil then
		local receiver = task_desc.reward_item_receiver and alife():story_object(receiver_sid_by_alias[task_desc.reward_item_receiver]) or alife():actor()
		for k,v in pairs(task_desc.reward_item) do
			--log3("~reward item %s", v)
			spawn_to_owner(v, receiver.id)
			--news_manager.relocate_item(actor, "in", v)
		end
		if task_desc.reward_item_receiver then
			store_box.unlock_by_sid(receiver_sid_by_alias[task_desc.reward_item_receiver], "ui_st_reward_to_box")
		end
	end

	if task_desc.reward_reputation ~= nil then
		--log3("~reward reputation %s", task_desc.reward_reputation)
		actor:change_character_reputation(task_desc.reward_reputation)
	end

	if task_desc.reward_relation ~= nil then
		for k,v in pairs(task_desc.reward_relation) do
			--log3("~reward relation of %s amount %s", k, v)
			relation_registry.change_community_goodwill(k, actor:id(), tonumber(v))
		end
	end

	if task_desc.reward_rank ~= nil then
		--log3("~reward rank %s", task_desc.reward_rank)
		actor_stats.add_points("quests", task_desc.name, 1, 1)
		actor:change_character_rank(task_desc.reward_rank)
	end
	
	local icon_type = (task_desc.type == "eliminate_lager") and (mob_lagers[task_desc.target] and "eliminate_layer" or "eliminate_lager") or task_desc.type
	local task_texture, task_rect = get_texture_info("ui_icons_task_"..icon_type, "ui_iconsTotal_locations")
	actor:give_game_news(GetRewardText(task_desc), task_texture, task_rect, 0, 3000)
end
--' Функция, в которой будет выдаваться вещевая награда за выполненные сторилайновые квесты
function task_reward_storyline(task)
	local task_desc = task_info[task:get_id()]
	if task_desc == nil or task_desc.type ~= "storyline" then
		return
	end

	if task_desc.reward_reputation ~= nil then
		actor:change_character_reputation(task_desc.reward_reputation)
	end

	if task_desc.reward_relation ~= nil then
		for kk,vv in pairs(task_desc.reward_relation) do
			relation_registry.change_community_goodwill (kk, db.actor:id(), tonumber(vv))
		end
	end

	if task_desc.reward_rank ~= nil then
		actor_stats.add_points("quests", task_desc.name, 1, 1)
		actor:change_character_rank(task_desc.reward_rank)
	end
end
--' Создается диалог актера, в котором будут приниматься задания
function init_reward_dialog(dlg, parent)
	local phr = dlg:AddPhrase("tm_reward_job","0","",-10000)
	local phrase_script = phr:GetPhraseScript()

	phr = dlg:AddPhrase("tm_"..parent.."_job_complete", "1", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddAction("task_manager.task_reward")
	phrase_script:AddPrecondition("task_manager.precondition_have_completed_job")
			
	phr = dlg:AddPhrase("tm_"..parent.."_job_ask", "2", "0", -10000)
	phrase_script = phr:GetPhraseScript()
	phrase_script:AddPrecondition("task_manager.precondition_dont_have_completed_job")

	
	-- Список возможных квестов трейдера.
	for k,v in pairs(task_id_by_parent[parent]) do
		phr = dlg:AddPhrase(task_info[v].name, tostring(task_info[v].init_phrase_id), "2", -10000)
		phrase_script = phr:GetPhraseScript()		
		phrase_script:AddPrecondition("task_manager.precondition_active_task")
		
		phr = dlg:AddPhrase("tm_"..parent.."_job_what", tostring(task_info[v].desc_phrase_id), tostring(task_info[v].init_phrase_id), -10000)
		
		phr = dlg:AddPhrase("tm_job_refuse", tostring(task_info[v].yes_phrase_id), tostring(task_info[v].desc_phrase_id), -10000)
		phrase_script = phr:GetPhraseScript()
		phrase_script:AddAction("task_manager.action_refuse_task")
			
		phr = dlg:AddPhrase("tm_job_nothing", tostring(task_info[v].no_phrase_id), tostring(task_info[v].desc_phrase_id),-10000)
	end

end
--' Регистрация целей для квестов.
function register_target(obj)
	if IsStalker(obj) then
		--' Возможно регистрируется цель для квеста "убить сталкера"
		for k,v in pairs(task_id_by_type["kill_stalker"]) do	
			if obj:alive() and obj:profile_name() == task_info[v].target then
				if task_info[v].target_objects == nil then
					task_info[v].target_objects = {}
				end
--				printf("@@@register new target %s[%s] for task %s", obj:name(), obj.id, v)
				table.insert(task_info[v].target_objects, obj.id)
			end
		end

	elseif obj:clsid() == clsid.smart_terrain then
		--' Возможно регистрируется цель для квеста "вынести лагерь"
		for k,v in pairs(task_id_by_type["eliminate_lager"]) do
			if obj:name() == task_info[v].target then
				if task_info[v].target_objects == nil then
					task_info[v].target_objects = {}
				end
				table.insert(task_info[v].target_objects, obj.id)
			end
		end
		--' Либо регистрируется цель для квеста "защитить лагерь"
		for k,v in pairs(task_id_by_type["defend_lager"]) do
			if obj:name() == task_info[v].target then
				--' Проверка что в кастом дате указано от кого защищать
				local sm_ini = obj:spawn_ini()
				local defend_target = read_if_exists(sm_ini, "r_u32", "random_task", "defend_target", nil)
				if task_info[v].target_objects == nil then
					task_info[v].target_objects = {}
				end
				table.insert(task_info[v].target_objects, obj.id)
			end
		end

	else
		--' Возможно регистрируется цель для квеста "найти предмет"
		for k,v in pairs(task_id_by_type["find_item"]) do
			if obj:section_name() == task_info[v].target then
				if task_info[v].target_objects == nil then
					task_info[v].target_objects = {}
				end
				table.insert(task_info[v].target_objects, obj.id)
			end				
		end
	end
end
--' ОТРегистрация целей для квестов.
function unregister_target(obj)
	if IsStalker(obj) then
		--' Возможно регистрируется цель для квеста "убить сталкера"
		for k,v in pairs(task_id_by_type["kill_stalker"]) do
			if task_info[v].selected_target == obj.id then
				task_info[v].selected_target = nil
			end
		end
	elseif obj:clsid() == clsid.smart_terrain then
	else
		--' Возможно регистрируется цель для квеста "найти предмет"
		for k,v in pairs(task_id_by_type["find_item"]) do
			if task_info[v].selected_target == obj.id then
				task_info[v].selected_target = nil
			end
		end
	end
end

--//обрати ціль
function select_target(task)
	if task.type == "eliminate_lager" or task.type == "defend_lager" then
		local name = task.target
		local sobj = name and alife():object(name)
		if sobj and sobj:clsid() == clsid.smart_terrain then
			local proceed = true
			if task.type == "defend_lager" then
				local sm_ini = sobj:spawn_ini()
				task.defend_target = read_if_exists(sm_ini, "r_u32", "random_task", "defend_target", nil)			 
				proceed = task.defend_target
			end
			if proceed then
				task.selected_target = sobj.id
			end
		end
		return
	end
	
	for id, sobj in alife():objects() do
		if task.type == "kill_stalker" then
			if sobj:clsid() == clsid.script_stalker and sobj:alive() and sobj:profile_name() == task.target then
				task.selected_target = id
				--log3("~[%s] task %s select target %s", script_name(), task.name, sobj.character_name)
				return
			end
		elseif task.type == "find_item" then
			if sobj:section_name() == task.target then
				-- Нужно игнорировать предметы, которые находяться у вендоров.
				local ignore = false
				if sobj.parent_id then
					for kk, vv in pairs(parent_by_story) do
						local parent = alife():story_object(kk)
						if parent and sobj.parent_id == parent.id then
							ignore = true
						end
					end
				end
				--
				if not ignore then
					task.selected_target = id 
					return
				end
			end
		end
	end	
end

function stats(obj)
	printf("### TASK STATISTIC ###")
	for k,v in pairs(task_info) do
		if v.init_condition ~= nil then
			printf("[%s] %s : %s", v.status, k, tostring(v.enabled_props))
			print_table(v.init_condition)
		end
	end
end

function init_trader_task_dialog(dlg)
	init_task_dialog(dlg, "trader")
end
function init_barman_task_dialog(dlg)
	init_task_dialog(dlg, "barman")
end
function init_ecolog_task_dialog(dlg)
	init_task_dialog(dlg, "ecolog")
end
function init_dolg_task_dialog(dlg)
	init_task_dialog(dlg, "dolg")
end
function init_freedom_task_dialog(dlg)
	init_task_dialog(dlg, "freedom")
end


function init_shustriy_task_dialog(dlg)
	init_task_dialog(dlg, "shustriy")
end
function init_lisiy_task_dialog(dlg)
	init_task_dialog(dlg, "lisiy")
end
function init_hunter_task_dialog(dlg)
	init_task_dialog(dlg, "hunter")
end
function init_drunk_dolg_task_dialog(dlg)
	init_task_dialog(dlg, "drunk_dolg")
end
function init_petrenko_task_dialog(dlg)
	init_task_dialog(dlg, "petrenko")
end
function init_wolf_task_dialog(dlg)
	init_task_dialog(dlg, "wolf")
end
function init_zastava_commander_task_dialog(dlg)
	init_task_dialog(dlg, "zastava_commander")
end
function init_mercenary_task_dialog(dlg)
	init_task_dialog(dlg, "mercenary")
end



function init_trader_reward_dialog(dlg)
	init_reward_dialog(dlg, "trader")
end
function init_barman_reward_dialog(dlg)
	init_reward_dialog(dlg, "barman")
end
function init_ecolog_reward_dialog(dlg)
	init_reward_dialog(dlg, "ecolog")
end
function init_dolg_reward_dialog(dlg)
	init_reward_dialog(dlg, "dolg")
end
function init_freedom_reward_dialog(dlg)
	init_reward_dialog(dlg, "freedom")
end



function init_shustriy_reward_dialog(dlg)
	init_reward_dialog(dlg, "shustriy")
end
function init_lisiy_reward_dialog(dlg)
	init_reward_dialog(dlg, "lisiy")
end
function init_hunter_reward_dialog(dlg)
	init_reward_dialog(dlg, "hunter")
end
function init_drunk_dolg_reward_dialog(dlg)
	init_reward_dialog(dlg, "drunk_dolg")
end
function init_petrenko_reward_dialog(dlg)
	init_reward_dialog(dlg, "petrenko")
end
function init_wolf_reward_dialog(dlg)
	init_reward_dialog(dlg, "wolf")
end
function init_zastava_commander_reward_dialog(dlg)
	init_reward_dialog(dlg, "zastava_commander")
end
function init_mercenary_reward_dialog(dlg)
	init_reward_dialog(dlg, "mercenary")
end


function has_active_vendor_task(actor, npc)
	return active_parent_task(actor, npc)
end
function precondition_task_avail(actor, npc, p1, p2, p3)
	return task_avail(actor, npc, p1, p2, p3, false)
end
function precondition_active_task(actor, npc, p1, p2, p3)
	return active_task(actor, npc, p1, p2, p3)
end

function precondition_vendor_can_task(npc, actor, p1, p2, p3)
	return parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_vendor_can_task_init(npc, actor, p1, p2, p3)
	return parent_can_task(npc, actor, p1, p2, p3)
end
function precondition_vendor_cannot_task(npc, actor, p1, p2, p3)
	return not parent_can_task(actor, npc, p1, p2, p3)
end
function precondition_have_completed_job(npc, actor, p1, p2, p3)
	return have_completed_job(actor, npc)
end
function precondition_dont_have_completed_job(npc, actor, p1, p2, p3)
	return not have_completed_job(actor, npc)
end

function on_task(_task, _objective, _state)
	task_callback(_task:get_id(), _objective:get_idx(), _state)
	if _objective:get_idx() == 0 and _state == task.completed then
		task_reward_storyline(_task)
	end
end

function on_npc_death(npc)
	unregister_target(npc)
end